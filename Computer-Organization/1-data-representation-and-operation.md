# 数据表示与运算

## 四种数制

### 二进制 <-> 八进制/十六进制

当 八进制/十六进制 转化成 二进制 的时候，要特意注意小数部分

![image-20250226183407318](imgs\image-20250226183407318.png)

### 各种机制的常见前后缀

![image-20250226183450990](imgs\image-20250226183450990.png)

### 十进制转化成其他进制

#### 整数部分：除基取余法

![image-20250226190336941](imgs\image-20250226190336941.png)

#### 小数部分：乘基取整法

![image-20250226190618992](imgs\image-20250226190618992.png)

### 使用拼凑法转换十进制

![image-20250226190813061](imgs\image-20250226190813061.png)

## 真值和机器数

<img src="imgs\image-20250226191028889.png" alt="image-20250226191028889" style="zoom:50%;" />

![image-20250226191657322](imgs\image-20250226191657322.png)

## 定点数

### 定点数 VS 浮点数

![image-20250226191957299](imgs\image-20250226191957299.png)

### 定点数的概括

<img src="imgs\image-20250226192040576.png" alt="image-20250226192040576" style="zoom:50%;" />

### 定点数的表示

#### 无符号数

![image-20250228155429329](imgs\image-20250228155429329.png)

+ 全部二进制位均为数值位，没有符号位，相当于数的绝对值。
+ $n$位无符号数表示范围为$[0,2^n-1]$。
+ 无符号数只有整数的概念，没有小数的概念

#### 有符号数

![image-20250226192616298](imgs\image-20250226192616298.png)

+ 定点整数：最高一位是符号位，$0$正$1$负，默认小数点在最后。定点整数是纯整数
+ 定点小数：最高一位是符号位，$0$正$1$负，默认小数点在符号位后。定点小数是纯小数
+ 原反补码都能表示整数和小数，**移码只能表示整数**

如果要用定点数的方式存储一个既有整数部分也有小数部分的数，则整数部分和小数部分要分开保存

##### 原码

+ 原码的符号位0正1负，数值位表示绝对值
+ 对于整数来说，符号位和数值位之间用 "," 隔开

* 对于小数来说，符号位和数值位之间用 "." 隔开（这只是一种区分符号位和数值位的格式，1.11其实表示-0.11）
* 如果指明机器字长，需要适当补0

##### 反码

* 正数的反码：就是它的原码
* 负数的反码：原码符号位不变，数值位按位取反

##### 补码

* 正数的补码：就是它的原码

* 负数的补码：原码符号位不变，数值位按位取反，末位+1

  例外：补码比原码、反码多表示一个负数，所以补码表示的最小值没办法通过原码/反码得到

+ **$[x]_原 = [[x]_补]_补$**
+ $[-x]_补$ = $[[x]_补]$的全部位取反，末位+1

##### 移码

* 假设补码有 n+1 bit，补码整体 向x轴正方向移动 $2^n$ 得到移码（补码符号位取反）

* 移码只能表示整数

* 移码表示的好处是**可以直观的比较两个数的大小**

> **原码**：符号位表示正负号，数值位表示数字的绝对值大小
>
> **反码、补码、移码**：符号表示正负号，并且**符号相等的时候，数值位越小数字真值越小**



<img src="imgs\image-20250228164000410.png" alt="image-20250228164000410" style="zoom:50%;" />

#### n+1 bit 定点整数取值范围

|    类型    |             范围              |        表示        |
| :--------: | :---------------------------: | :----------------: |
| 无符号整数 |     0 ~~ $$2^{n+1} - 1$$      |  00...0 ~~ 11...1  |
|    原码    | $$-(2^n - 1)$$ ~~ $$2^n - 1$$ | 1,1...1 ~~ 0,1...1 |
|    反码    | $$-(2^n - 1)$$ ~~ $$2^n - 1$$ | 1,0...0 ~~ 0,1...1 |
|    补码    |    $$-2^n$$ ~~ $$2^n - 1$$    | 1,0...0 ~~ 0,1...1 |
|    移码    |    $$-2^n$$ ~~ $$2^n - 1$$    | 0,0...0 ~~ 1,1...1 |

#### n+1 bit 定点小数取值范围

| 类型 |               范围                |        表示        |
| :--: | :-------------------------------: | :----------------: |
| 原码 | -($$1-2^{-n}$$) ~~ $$1 - 2^{-n}$$ | 1.1...1 ~~ 0.1...1 |
| 反码 | -($$1-2^{-n}$$) ~~ $$1 - 2^{-n}$$ | 1.0...0 ~~ 0.1...1 |
| 补码 |       -1 ~~ $$1 - 2^{-n}$$        | 1.0...0 ~~ 0.1...1 |

计算机内部把加减乘除的运算都转化成了**加法运算 + 移位运算**

### 加法替代减法的原理

计算机内部进行运算时，如果超出了存储字长，会保留低位，丢弃高位

![image-20250228165329323](imgs\image-20250228165329323.png)

* 补码就是原码的补数

* 补码的意义是可以把计算机内部所有减法操作转化成加法操作。

### 强制类型转换

![image-20250228182422179](imgs\image-20250228182422179.png)

#### 位数扩展（短数据->长数据）

##### 需要位数扩展的原因

![image-20250228182740692](imgs\image-20250228182740692.png)

##### 零扩展 VS 符号扩展

![image-20250228183048925](imgs\image-20250228183048925.png)

## 逻辑运算

![image-20250228184831475](imgs\image-20250228184831475.png)

### 异或运算的妙用

![image-20250228185149785](imgs\image-20250228185149785.png)

奇数个1异或，结果是1。偶数个1异或，结果是0

### 逻辑运算常见公式

优先级： 非 > 与 > 或

![image-20250228185544529](imgs\image-20250228185544529.png)

### 多路选择器

![image-20250228185815429](imgs\image-20250228185815429.png)

有多个输入和单个输出，控制信号选择哪一个输入是有效的。

### 三态门

![image-20250228190001365](imgs\image-20250228190001365.png)

控制信号选择是否允许进行输入。

当不允许通过时，电路进入高阻态（不是高电平也不是低电平，相当于断电）

![image-20250228190225993](imgs\image-20250228190225993.png)

三态门有时也会和非门结合。非三态门和与非门的区别就在于**是否有控制信号输入**

## 加法器

### 用门电路实现加法

![image-20250228192418772](imgs\image-20250228192418772.png)

#### 一位全加器（FA）

![image-20250228192651993](imgs\image-20250228192651993.png)

#### n bit 全加器

![image-20250228192742554](imgs\image-20250228192742554.png)

#### 串行进位的并行加法器

![image-20250228193123362](imgs\image-20250228193123362.png)

#### 并行进位的并行加法器

![image-20250228193316099](imgs\image-20250228193316099.png)

##### 实现

只要知道了 A, B, C0，每一次的进位都是可预估的（但随着套娃增加复杂度会上升）所以最高支持四位的并行

![image-20250228195503420](imgs\image-20250228195503420.png)

### 带标志位的加法器

![image-20250228193903778](imgs\image-20250228193903778.png)

* OF：带符号数 运算溢出，OF=1溢出
* CF：无符号数 运算溢出，CF=1溢出
* SF：运算结果正负性，SF=1负数
* ZF：运算结果是否为0，ZF=1为0

#### 标志位的生成逻辑

![image-20250228194510309](imgs\image-20250228194510309.png)

![image-20250228194924603](imgs\image-20250228194924603.png)

## 算术逻辑单元 ALU

<img src="imgs\image-20250303145514417.png" alt="image-20250303145514417" style="zoom:50%;" />

* 运算器的核心是ALU，ALU的核心是加法器（加减乘除都是通过加法实现的）

### ALU的功能

![image-20250303145808935](imgs\image-20250303145808935.png)

* 算数运算（加减乘除）、逻辑运算（与或非/异或/移位）、其他（求补码/直送）
* m种控制信号，m的位数和ALU支持的功能数k的关系是：$2^m ≥ k$

### ALU图示

![image-20250303150319155](imgs\image-20250303150319155.png)

* ALU能支持的运算数的比特长度，叫做**机器字长**
* OF/CF/SF/ZF都会存在 PSW中
* **程序状态字寄存器 PSW = 标志寄存器 FR**

![image-20250303150800290](imgs\image-20250303150800290.png)

## 定点数运算

### 移位运算

#### 1. 算数移位（乘除$2^n$）

##### 原码算术移位

![image-20250303151329991](imgs\image-20250303151329991.png)

* 原码左移低位补0，右移高位补0（不管整数小数，正数负数）

##### 反码算术移位

![image-20250303151513196](imgs\image-20250303151513196.png)

* 反码正数，左移低位补0，右移高位补0
* 反码负数，左移低位补1，右移高位补1

##### 补码算术移位

![image-20250303152111660](imgs\image-20250303152111660.png)

* 补码正数，左移低位补0，右移高位补0
* 补码负数，左移低位补0，右移高位补1（低位同原码，高位同反码）

![image-20250303152239658](imgs\image-20250303152239658.png)

#### 2. 逻辑移位

![image-20250303152526585](imgs\image-20250303152526585.png)

* 左移低位补0，右移高位补0

* 移位的使用场景 —— 乘除法
  * 算数移位 = 有符号数乘除法。左移前后符号位不同，相当于溢出；右移移丢1，相当于精度丢失
  * 逻辑移位 = 无符号数乘除法。左移移丢1，相当于溢出；右移移丢1，相当于精度丢失


#### 3. 循环移位

![image-20250303152828199](imgs\image-20250303152828199.png)

* 分为不带进位位的循环移位，和 带进位位的循环移位
* 使用场景：大端存储和小端存储互相转换

![image-20250303153110316](imgs\image-20250303153110316.png)

### 加减运算

#### 原码加减运算

![image-20250303153504653](imgs\image-20250303153504653.png)

* 要考虑符号位
* 如果是一正一负，要判断大小
* 如果是一正一负，要转化成减法
* 正正加，负负加都可能发生溢出

#### 补码加减运算

![image-20250303153940671](imgs\image-20250303153940671.png)

* 不管正数负数，加法减法，总可以转化成加法运算
* $[A+B]_\text{补}=[A]_\text{补}+[B]_\text{补}$（$\mod M$）；$[A-B]_\text{补}=[A]_\text{补}+[-B]_\text{补}$（$\mod M$）
* 提出根据原码求补码、根据补码求相反数补码的简易形式
* 也有可能会发生溢出

##### 溢出判断

补码的加减法运算总能转化成加法运算，所以只需要考虑加法溢出

+ 小于最小值——下溢。负数 + 负数 = 正数
+ 大于最大值——上溢。正数 + 正数 = 负数

###### $V=A_sB_s\overline{S_s}+ \overline{A_s}\overline{B_s}S_s$

![image-20250304140156405](imgs\image-20250304140156405.png)

* $A_sB_s\overline{S_s}(001)$ 是上溢，$\overline{A_s}\overline{B_s}S_s(110)$ 是下溢

###### $V = C_s \bigoplus C_1$

* $C_s$ 指符号位进位，$C_1$ 指最高数值位进位

![image-20250304140555413](imgs\image-20250304140555413.png)

* $\overline{C_s}C_1(01)$ 是上溢，$C_s\overline{C_1}(10)$ 是下溢

###### $V = S_{s1} \bigoplus S_{s2} $ (双符号位)

* 使用双符号位，$S_{s1}$ 指高符号位（本应该得到的符号位），$S_{s2}$ 指低符号位（实际得到的符号位）

![image-20250304141852031](imgs\image-20250304141852031.png)

* $\overline{S_{s1}}S_{s2}(01)$ 是上溢，$S_{s1}\overline{S_{s2}}(10)$ 是下溢
* 双符号位又称 模四补码，单符号位又称 模二补码
* 实际计算时是把符号位复制，并没有实际存储两个符号位

![image-20250304142132278](imgs\image-20250304142132278.png)

#### 无符号数加减运算

![image-20250304144238855](imgs\image-20250304144238855.png)

![image-20250304144429456](imgs\image-20250304144429456.png)

* 无符号数的加法运算，就是正常的按位相加
* 无符号数的减法运算，也像补码一样转化成加补数运算。补数的计算方式也是全部位按位取反，末位加一
* 总之，无符号数的加减法，和带符号数（补码）的加减法实现逻辑是完全一致的。

##### 溢出判断

![image-20250304144938892](imgs\image-20250304144938892.png)

* 手算情况下，直接看运算结果有没有超过无符号数的表示范围

* 机算情况下，无符号数的加法运算，最高位进位是1说明溢出

  ​			无符号数的减法运算，会转化成加法运算，最高位进位是0说明溢出

![image-20250304145136253](imgs\image-20250304145136253.png)

#### 补码的加减运算电路

![image-20250304150638717](imgs\image-20250304150638717.png)

* sub是一个控制信号，控制 $C_{in}$ 和 $Y$ 是否取反
* 无符号数的加减运算和补码的加减运算的逻辑一致，所以以上逻辑电路也可以实现无符号数的加减运算
* 但要注意的是 补码运算的溢出判断 和 无符号数运算的溢出判断 是不一样的

#### 标志位的生成逻辑

![image-20250304151236376](imgs\image-20250304151236376.png)

* ZF：输出结果的所有位进行或非运算（仅当所有位都是0时，ZF=1）
* SF：输出结果的符号位（SF=1说明是负数）
* OF：输出结果最高位的进位  $\bigoplus$ 次高位的进位（补码溢出判断方法2）
* CF：$C_{in} \bigoplus C_{out}$ （加法时 $C_{in} = 0$ ，无符号数加法溢出时$C_{out} = 1$；减法时$C_{in} = 1$，无符号数减法溢出时 $C_{out} = 0$）

### 乘法运算（移位 + 加法）

#### 原码的一位乘法

![image-20250303152338003](imgs\image-20250303152338003.png)

![image-20250304172105620](imgs\image-20250304172105620.png)

* 手算 —— 数值位取绝对值进行乘法运算

  ​		  符号位单独处理

##### 机算

* 用机器实现乘法，需要解决的问题：1. 符号怎么处理 2. 结果的位数翻倍怎么处理 3. 每次的位积都要存在寄存器吗

![image-20250304172842793](imgs\image-20250304172842793.png)

* 一位乘法指的是每次只乘一位的数据
* 数值位有 n 位，就进行 n 轮的 加法 + 移位 操作

原码一位乘法流程：

* 开始前，X存被乘数，MQ存乘数，ACC要清空
* MQ的最后一位是1则(ACC) + (X) -> (ACC)，是0则(ACC) -> (ACC)
* 每次的加法操作结束后，ACC和MQ里的值统一右移一位，MQ最低位移丢
* 继续进行 加法 + 移位 的操作，直到移动至MQ最低位存的是刚开始乘数的符号位
* 最后的结果的符号位，要修改成 被乘数符号位 $\bigoplus$ 乘数符号位
* 最后的结果不能算上MQ的最后一位

##### 手算

![image-20250304174453960](imgs\image-20250304174453960.png)

#### 补码的一位乘法

##### 机算

![image-20250304182836179](imgs\image-20250304182836179.png)

* 原码的乘法，需要寄存器的位数 = 被乘数、乘数的位数 n（如果使用双符号位，也可以是n+1）
* 补码的乘法，位数 = n + 1（因为补码必须使用双符号位）
* 运算器内部的寄存器的存储字长要求统一字长
* 补码乘法和原码乘法的四个区别

补码一位乘法的流程：

* 开始前，X存被乘数（双符号位），MQ存乘数（单符号位，末位是辅助位，辅助位在开始时是0），ACC清零（双符号位）
* 加法操作每次相加的内容由 MQ里的 辅助位 - 最低位 决定
  * 辅助位 - 最低位 = 1，$+[x]_补$
  * 辅助位 - 最低位 = 0，$+0$
  * 辅助位 - 最低位 = -1，$+[-x]_补$
* 移位操作 是算术右移
* 进行n次的加法+移位操作后，再进行一次加法操作
  * 原码乘法里的n次加法+移位，n指数值位位数；
  * 补码乘法里的n次(加法+移位)+1次(加法)，n指总位数
* 最后的结果不能算上MQ的最后一位

##### 手算

![image-20250304203419429](imgs\image-20250304203419429.png)

### 除法运算

#### 原码除法

![image-20250304202028246](imgs\image-20250304202028246.png)

##### 恢复余数法

###### 机算

![image-20250304203151224](imgs\image-20250304203151224.png)

* 原码除法要绝对值运算，所以上商：$(ACC) + [-|y|]_补 -> (ACC)$，恢复：$(ACC) + [|y|]_补 -> (ACC)$
* 机器字长为 n 位，则上商 [+ 恢复] + 左移 n 次，最后多来一次上商 + [ 恢复 ]
* 最后 $(ACC) * 2^{-n} = 余数$ 
* 原码除法运算过程中，符号位不参与运算，最后运算结束，商的符号位单独进行运算

原码除法使用恢复余数法的流程：

* 开始前，X存除数，ACC存被除数/余数，MQ清零
* MQ最低位默认上商1，$(ACC) + ([-|y|]_补) -> (ACC)$（直接相减）
* 判定现在ACC的值是正是负
  * 如果ACC是正数：商1、逻辑左移
  * 如果ACC是负数：商0、$(ACC) + ([|y|]_补) -> (ACC)$ (恢复余数)、逻辑左移

* 持续进行 相减 [ + 恢复] + 移位 的操作，直到MQ的所有位都被商填充
* 计算结果的符号位

* 最后，ACC存余数，MQ存商

###### 手算

![image-20250304204920619](imgs\image-20250304204920619.png)

##### 加减交替法(不恢复余数法)

###### 机算

![image-20250304212032529](imgs\image-20250304212032529.png)

* 加减交替法其实就是在恢复余数法的基础上，改良了 当余数为负数时的情况

* 如果 上商后，ACC的值是 a ，MQ里存的除数是 b

  * a < 0，则下一步要 恢复 + 逻辑左移 + 再上商，算得下次上商后，ACC的值是 2a+b

  * a > 0，则下一步要 逻辑左移 + 再上商，算得下次上商后，ACC的值是 2a-b

* 也就是说，不必再恢复余数，如果上商后 a < 0，则令商为0，下一步上商结果是 2a+b

  ​					  	如果上商后 a > 0，则令商为1，下一步上商结果是 2a-b

###### 手算

![image-20250304212807273](imgs\image-20250304212807273.png)

* 恢复余数法 和 加减交替法 都是原码除法，符号位都是在最后单独计算的
* 最后获得 ACC里的余数 和 MQ里的商 是同号的
* 加减交替法 优化了 恢复余数法的恢复步骤，但是在最后一步如果余数是负，还是要恢复余数的

![image-20250304213321977](imgs\image-20250304213321977.png)

* 机器字长为 n 位，则加/减 n+1(或n+2) 次，左移 n 次（最后一次上商 + [ 恢复 ]，不左移，如果需要恢复，则加减 n+2 次）

* **定点小数相除**的结果也得是定点小数，所以必须要**被除数 < 除数**（第一次上商一定是0）

​	**定点整数相除**的结果也得是定点整数，所以必须要**被除数 > 除数**（第一次上商一定是1）

#### 补码除法

+ 类似原码除法的加减交替法，不恢复余数
+ 双符号位参与运算
+ 依然是逻辑左移
+ 下一步加$[y]_补$ 、$[-y]_补$；上商0、1 —— 都是根据当前余数和商的符号是否相等决定的

![](imgs\image-20250304222957576.png)

补码除法流程：

* 开始前，ACC存被除数，X存除数，MQ清零
* 首先，根据 被除数 和 除数 是否同号，判断 $[y]_补$ 还是 $[-y]_补$
  * 同号，$[-y]_补$
  * 异号，$[y]_补$
* 看当前余数 和 除数 是否同号
  * 同号，商1，逻辑左移，$[-y]_补$
  * 异号，商0，逻辑左移，$[y]_补$

* 共进行 n+1 轮上商，n轮逻辑左移
* 商的最后一位不再进行恢复，统一置为1（有精度误差）

* 最后的余数的正负号，就是计算结果里余数的正负号

|    除法类型    | 符号位参与运算 | 加减次数 | 移位方向 | 移位次数次数 |   上商和加减原则   |            说明            |
| :------------: | :------------: | :------: | :------: | :----------: | :----------------: | :------------------------: |
| 原码加减交替法 |       否       | N+1或N+2 |    左    |      N       |     余数的正负     | 若最终余数为负，需恢复余数 |
| 补码加减交替法 |       是       |   N+1    |    左    |      N       | 余数和除数是否同号 |        商末位恒置1         |

其实本质上原码和补码的上商和加减原则是一样的，只是因为除数被去掉符号为正值，所以余数是负就异号，是正就同号。

## 浮点数

![image-20250304225640661](imgs\image-20250304225640661.png)

* 浮点数 = 阶码（阶符 + 阶码数值部分） + 尾数（数符 + 尾数数值部分）

* 阶码：定点整数，可以是补码、移码

  尾数：定点小数，可以是原码、补码

* **阶码反映 表示范围 和 小数点位置，尾数反映精度**

### 尾数的规格化（左规、右规）

确保 最大程度精度 和 唯一性

![image-20250304231821659](imgs\image-20250304231821659.png)

* **小数点固定不变**，为了规格化而令**尾数**左移右移，称为**左规右规**

* 尾数最高位无效：左规，阶码-1
* 双符号位运算溢出：右规，阶码+1
* 尾数溢出是有救的，但阶码溢出就是溢出

#### 判断尾数最高位是否有效

![image-20250304232534317](imgs\image-20250304232534317.png)

* 原码：尾数应该是 0.1...... 或者 1.1......（尾数第一位是1）
* 补码：尾数应该是 0.1...... 或者 1.0......（尾数第一位和数符异号）

![image-20250304233105536](imgs\image-20250304233105536.png)

### 浮点数标准 IEEE 754

* 组成方式：数符 + 阶码(移码表示) + 尾数(原码表示)

* 但IEEE 754使用了较为特殊的移码标准（偏置值是 $2^{n-1} - 1$）

![image-20250304233758009](imgs\image-20250304233758009.png)

* 全1和全0分别表示最小的负数和次小的负数
* 一般这两种状态有别的作用，所以假如是8位阶码，其实能表示的范围只有 -126 ~ 127

![image-20250304235453754](imgs\image-20250304235453754.png)

* IEEE标准，用移码表示阶码，原码表示尾数
* 因为尾数有效位的要求，原码规定都是$$\pm0.1...$$，所以省略 $$\pm0.1...$$ 中的0.1。
  * 比如0.1101在尾数的表示就表示成101，0.1被省略
* float**真值：$$(-1)^S$$ * 1.M * $$2^{E-127}$$**（1+8+23）
* double真值：$$(-1)^S$$ * 1.M * $$2^{E-1023}$$（1+11+52）

![image-20250307134823044](imgs\image-20250307134823044.png)

* 十进制 转 float : 1. 转化成二进制浮点数表示（确定数符，尾数，阶码真值）2. 1+8+23转

![image-20250307135434251](imgs\image-20250307135434251.png)

* 对于 float 类型：
  * 最小绝对值：尾数全0（则尾数真值是1.00...），阶码最小（真值是-126），即 $(-1)^s * 1.0... *2^{-126}$
  * 最大绝对值：尾数全1（尾数真值是 1.11...），阶码最大（真值是 127），即 $(-1)^s * (2 - 2^{-23}) * 2^{127}$ 
  * 有可能会遇到 |值| < 最小绝对值（下溢） 或 |值| > 最大绝对值（上溢） 的情况

![image-20250307140134346](imgs\image-20250307140134346.png)

* 如果阶码为 全0 (真值是 -127)
  * 尾数 全0，则表示 ±0（根据数符）
  * 尾数 不全0，表示非规格化小数，真值为 $(-1)^s * 0.M * 2^{-126}$
* 如果阶码为 全1（真值是-128）
  * 尾数 全0，表示 ±∞（根据数符，常出现于上溢下溢时）
  * 尾数 不全0，表示 NaN （Not a Number，非数值，常出现于 0/0，∞ - ∞）

**float和double的精度范围**：

精度是尾数决定的，float类型尾数是23位，$$2^{23}$$转化成十进制是个七位数，其中前六位是确定准确的，所以float类型的精度是6-7位。同理double类型的精度的15-16位

例：下边不能用IEEE754标准表示的数是：A 1.2      B 1.25      C 2.5      D 2.0

~~~
1.2 化成二进制无法精确表示，只能近似表示，因为1.2乘2取整永远得不到余数为0。所以它无法用二进制精确表示，所以也无法用IEEE754浮点精确表示
~~~

### 浮点数加减运算

![image-20250307141455682](imgs\image-20250307141455682.png)

* 对阶 -> 尾数加减 -> 规格化 -> 舍入 -> 判溢出
* 对阶是 向高位对，因为 低位->高位 是右规，可能发生精度误差，高位 -> 低位是左规，可能发生严重误差
* 舍入的规则按要求定
* 规格化可能导致溢出（指阶码超范围）

![image-20250307142749075](imgs\image-20250307142749075.png)

* 十进制数 转 二进制机器数 的技巧
* 题要求补码浮点运算，就是说要把阶码，尾数都转化成补码，所以尾数加减也是补码的加减法运算
* 对阶时判断哪个是高阶的方式就是直接相减，判断结果>0 <0 =0（因为这里的阶码是补码，所以采用补码减法）
* 规格化时左规右规，对应补码的算术左移算术右移
* 阶码溢出判断，根据双符号位是否异号（01表示上溢，10表示下溢）

![image-20250307144322222](imgs\image-20250307144322222.png)

* 舍入方案：1. 0舍1入（可能又会导致右规） 2. 恒置1（不论舍了什么最后一位都置1）

* 规格化 和 舍入(又可能导致规格化) 有可能导致阶码改变

  从而可能发生阶码上溢下溢，阶码下溢通常默认为机器0，阶码上溢被认为是异常

### 强制类型转换

![image-20250307144913192](imgs\image-20250307144913192.png)

* 对于 int  和 float，虽然都是 32bit 

  但int = 1(符号位) + 31(数值位)； float = 1(数符) + 8(阶码) + 23(尾数)（但实际上还有一个0.1，所以float可表示的精度范围是$2^{-24}$）

  int 转 float , 31 > 24，可能会损失精度

  float 转 int，126 > 31，可能会发生溢出，也可能因为小数部分被截断而损失精度

* 同样，虽然 long 和 double 在64位机器中都是 64bit

  但 long = 1 + 63； double = 1 + 11 + 52（实际上可表示53位精度）

  所以 long 转 double 可能会损失精度（前提是 long 是64bit，在32位机器里 long 是 32bit，这时候就完全可以用double表示long）

### 浮点数运算总结

![image-20250307145734674](imgs\image-20250307145734674.png)

## 数据的存储排列

### 大小端模式

![image-20250307153448267](imgs\image-20250307153448267.png)

* 最高有效字节 MSB，最低有效字节 LSB
* 小端存储：高高低低原则，高位放在高地址，低位放在低地址
* 小端存储的优势是可以边读边计算

### 边界对齐

![image-20250307153902007](imgs\image-20250307153902007.png)

*  1 Byte = 8 bit，一个字占多少bit是根据计算机定义的

* 可以通过字节寻址，也可以通过半字、字寻址

  假设 字长是 32，即 1 Word = 32 bit = 4 Byte

  那么按字寻址，假设地址是 2，只需要逻辑左移两位（乘4）即 10(2) -> 1000(8) 然后按字节寻址

* 存储数据有 边界对齐 和 边界不对齐 两种方式

  边界对齐 相当于 空间换时间（可能造成空间浪费，但访问内存的次数减少）







