# 输入输出系统

## I/O设备

![image-20250322194421568](imgs\image-20250322194421568.png)

## I/O硬件

### I/O接口（I/O控制器）

![image-20250322194627142](imgs\image-20250322194627142.png)

* I/O接口，也叫I/O控制器，是CPU和外设的中转（作用类似与编程中的“接口”）

* I/O接口是一种芯片

![image-20250322212952817](imgs\image-20250322212952817.png)

* I/O接口的组成：
  * 数据寄存器 —— 双向，存CPU要输出的数据/通过设备输入的数据
  * 控制寄存器 —— 单向，存CPU的控制信号
  * 状态寄存器 —— 单向，存外设的反馈信号
* **每次输入/输出**一个字，都需要**CPU介入**作为数据中转站

* CPU查询外设是否输入/输出了的两种方式：
  * **程序查询方式** —— 每隔一段时间就查一下状态寄存器（缺：**CPU忙等**直到外设完成任务）
  * **程序中断方式** —— 发布好控制命令，**CPU就去处理其他命令**，直到外设完成任务，自己给CPU发送**中断**信号

### I/O控制方式

#### 程序查询方式

* CPU忙等

#### 程序中断方式

![image-20250322213825998](imgs\image-20250322213825998.png)

* 程序中断方式：

  * 优：CPU利用率提升（不需要忙等外设）

    缺：对于快速的I/O设备，**每次发送一个字，CPU需要处理中断程序一次，进程切换很占时间**

#### DMA控制方式

![image-20250322215223246](imgs\image-20250322215223246.png)

* **DMA接口 = DMA控制器，是一种特殊的I/O接口**，连接主存和高速外设(例如磁盘)

* CPU不能直接和磁盘交互，而是让磁盘和主存通过DMA总线进行数据传输，然后CPU和主存通过主存总线传递数据

  主存总线、DMA总线都访问主存，所以**在DMA传送数据期间CPU不能访问主存**

* DMA控制方式 —— CPU向DMA接口发出**读/写命令**，给出**主存地址、磁盘地址、读写数据量**

  DMA接口根据CPU的指示，**DMA与主存每次只传一个字，但完成一整块的数据读写，才向CPU发送一次中断请求**

#### 通道控制方式

![image-20250322220210193](imgs\image-20250322220210193.png)

* DMA控制方式的缺点：尽管I/O每次传递一整块数据才会发送一次中断信号

  ​					但如果计算机连接了多台I/O设备，每个I/O设备每次和CPU交互都要发送中断信号

  ​					为了减轻CPU的任务，引入“通道”的概念

  ​					通道完成了一个通道程序，才会向CPU发送一次中断信号

* **“通道”是一种特殊处理器**，功能没有CPU强大，主要用来协助CPU与外设进行数据交互
* 通道程序存放在主存

## I/O软件

* I/O系统 = I/O硬件 + I/O软件

* **I/O指令 —— 让CPU执行的，对I/O接口(或者通道)发出命令**

  I/O指令 = 操作码(区分是不是I/O指令) + 命令码(对I/O设备的具体操作) + 设备码(对哪个I/O设备进行操作)

* **通道指令 —— 让通道执行的，对I/O接口发出命令**（支持通道的系统才会有通道指令）

  通道程序是一系列通道指令组成的，提前编制好放在主存里

![image-20250322223201271](imgs\image-20250322223201271.png)

## 外部设备

输入设备：键盘、鼠标

输出设备：

### 显示存储器 VRAM

![image-20250328215853529](imgs\image-20250328215853529.png)

* 显示存储器 = 刷新存储器 = VRAM 
* VRAM需要存储的是一帧图像信息，**VRAM容量 = 分辨率 * 灰度级位数**
  * 分辨率 —— 像素点个数
  * 灰度级位数 —— 每个像素所占数据位大小

![image-20250328220156305](imgs\image-20250328220156305.png)

* **VRAM带宽 = 分辨率 * 灰度级位数 * 帧频**
  * 帧频 —— 显示器每秒需要刷新的次数

![image-20250328220436558](imgs\image-20250328220436558.png)

* 集成显卡 —— 有些计算机没有专门存放显存的芯片，而是从内存中划分一部份区域存储显存数据

### 阴极射线管显示器 CRT

![image-20250328220719391](imgs\image-20250328220719391.png)

* 字形码 —— 用点阵显示字符，点阵上点的明灭通过二进制字符01控制
* 上图是BP机，CRT显示字符的原理和它相同，也是点阵

![image-20250328223317977](imgs\image-20250328223317977.png)

* 显示存储器（RAM构成），存从键盘输入得到的字符ASCII码
* 字符发生器（ROM构成），存所有ASCII码对应的字符码，接受显存的ASCII码，把对应字符显示到显示器

![image-20250328223732212](imgs\image-20250328223732212.png)

* 图形显示器 —— 显示简单的几何图形（例如股票涨跌、心电图）
  * 光栅扫描显示器
  * 随即扫描显示器
* 图像显示器 —— 显示复杂图像

![image-20250328224413574](imgs\image-20250328224413574.png)

## I/O接口

### 作用

![image-20250328224719761](imgs\image-20250328224719761.png)

### 工作原理

![image-20250328230228826](imgs\image-20250328230228826.png)

* I/O接口 = 数据寄存器 + 控制寄存器 + 状态寄存器

  * 控制寄存器、状态寄存器可以**复用**同一个寄存器（使用时间是错开的）

* I/O接口通过 **系统总线** 和CPU连接，可能是并行/串行

  ​	     通过 **接口电缆** 和外设连接，可能是并行/串行

* I/O接口中的 **寄存器 也称为 I/O端口**，每个I/O端口对应一个地址

  * 数据总线 —— 双向，连数据缓冲寄存器、控制/状态寄存器

    ​			读写数据、状态字、控制字、中断类型号（判断中断是由于传输结束还是异常）

  * 地址总线 —— 单向，传输地址码，指明I/O端口

  * 控制总线 —— 双向，读/写信号、中断请求信号

* 一个I/O接口可能连接**多个**外设

  * 识别方法1：地址码传两次，一次指明I/O端口，一次指明I/O设备对应的外设
  * 识别方法2：虽然还是一个I/O接口，但给每个外设配一套对应的寄存器

### 统一编制 VS 独立编址

![image-20250328231213591](imgs\image-20250328231213591.png)

* 统一编制 = 存储器映射方式

![image-20250328231455635](imgs\image-20250328231455635.png)

### I/O接口总结

![image-20250328231555711](imgs\image-20250328231555711.png)

## 程序查询方式

![image-20250328232620735](imgs\image-20250328232620735.png)

* 默认是独占查询，CPU和外设串行工作

![image-20250328233517086](imgs\image-20250328233517086.png)

* 程序查询方式
  * 定时查询 —— 每隔一段时间查一次（这时CPU和外设就不是严格串行了）
  * 独占查询 —— CPU花费全部精力查询数据
* 对于磁盘这种高速I/O设备，逐字查询可能会查询速度跟不上传输速度的情况

## 程序中断方式

### 中断处理流程

![image-20250329114923594](imgs\image-20250329114923594.png)

* 不同外设可能会发出不同的中断请求信号

* 中断源 —— 发出中断请求信号的外设

* 中断判优 —— 同时接收多个中断信号，判断优先响应哪一个（相当于总线里的总线仲裁）

* 关中断 —— 不需要响应中断请求

  判断是否关中断 —— PSW的IF位，0=关中断，1=开中断

  原子操作就是通过关中断、开中断实现的

### 非屏蔽中断 VS 可屏蔽中断

![image-20250329115121549](imgs\image-20250329115121549.png)

* 即使关中断，非屏蔽中断也会被执行（如强制停机）
* I/O设备的中断一般都是可屏蔽中断

### 判断中断请求设备

![image-20250329115444579](imgs\image-20250329115444579.png)

* 中断请求标记寄存器 INTR
  * 每个I/O设备对应一个触发器，触发器为1时代表该外设发送了中断请求信号
* CPU每执行完一条机器指令，都要判断外中断

### 中断判优

![image-20250329120123541](imgs\image-20250329120123541.png)

* 包括 硬件实现 和 软件实现
  * 不管硬件还是软件，都有**严格的优先级策略**
  * 硬件排队器 比 查询程序 快

![image-20250329120519125](imgs\image-20250329120519125.png)

### 改变程序执行流

* 中断隐指令不是一条指令，而是CPU检测到中断信号后执行的一系列动作

![image-20250329121242526](imgs\image-20250329121242526.png)

* 中断隐指令

  * 任务：PC旧值压栈，指向新值

  * 流程：

    1. 关中断
    2. PC+“1”压入堆栈栈顶

    3. PC指向对应中断服务程序首地址

* 判断中断服务程序首地址：

  * （中断请求标记寄存器数据） -> 中断向量地址形成部件 -> （生成向量地址/中断类型号） -> 主存 -> （中断向量/中断服务程序首地址） 
  * 从中断请求标记寄存器，到中断服务程序首地址，经历了一次间址（中断服务程序大小、位置可能会发生改变，但**中断向量（中断程序首地址）一定存放在向量地址里**）

### 运行中断服务程序

![image-20250329122408670](imgs\image-20250329122408670.png)

* 中断处理程序：
  1. 保存现场（重要寄存器值压入堆栈）
  2. 中断服务
  3. 恢复现场（恢复寄存器）
  4. 开中断
  5. 中断返回（恢复PC）

#### 单重中断 VS 多重中断

![image-20250329123607446](imgs\image-20250329123607446.png)

* 在 **中断隐指令** 部分关中断

  在 **中断服务程序** 部分开中断

* 关中断 - 开中断 中间中系统不响应新的中断请求信号 —— **单重中断**

![image-20250329140528614](imgs\image-20250329140528614.png)

* 多重中断 —— 允许中断嵌套

  因此只在必要时进行关中断的动作：

  * 中断隐指令（PC旧值、新值转换）、保护现场（寄存器）和屏蔽字时必须关中断
  * 恢复现场和屏蔽字时必须关中断

  这样，执行中断程序的过程可以被打断，所以能实现多重中断

#### 多重中断的中断屏蔽字

![image-20250329140245406](imgs\image-20250329140245406.png)

* 描述中断优先级，即使允许多重中断，也不是任意中断都能打破任意中断的
  * 优先级更低的、中断源自身就用 1，意味着这些中断源不能中断它
  * 优先级更高的就用0，这些中断源可以中断它

![image-20250329141251672](imgs\image-20250329141251672.png)

### 程序中断方式实现

![image-20250329142315598](imgs\image-20250329142315598.png)

* CPU和外设并行工作

  例如printf()，CPU发布写命令，在外设打印的同时，CPU继续执行之后的指令

* 程序中断方式，每次**外设读/写一个字**，即使是要从外设写入到内存，也**都需要经过CPU**，因为中断处理程序是CPU执行的

![image-20250329142916400](imgs\image-20250329142916400.png)

## DMA方式

* DMA接口是一种特殊的I/O接口，也是一个芯片

![image-20250329212304950](imgs\image-20250329212304950.png)

* 每次DMA传输，CPU需要告诉DMA：读/写命令、主存地址、外设地址、数据大小，这个过程也称为预处理

* DMA传输过程中，计数、主存地址、外存地址的变化，都是DMA自己完成的

* DMA传输结束后，CPU还需要进行一些后处理（处理DMA中断请求）

  **CPU**在DMA传输时，不需要控制传输过程，而是**仅需要预处理和后处理**

### DMAC的组成

* 以通过DAM读数据的过程为例，学习DMAC的组成。C是controller

  这里假定了计算机内部使用了单总线结构

![image-20250329211955896](imgs\image-20250329211955896.png)

* 假如CPU要DMA协助执行读命令，把数据从外设读入到主存，需要用到的DMA芯片内部组成：
  * 主存地址寄存器（AR） —— 存主存地址，每读1个字都自增1
  * I/O设备地址（DAR） —— 存外设地址，每读1个字都自增1
  * 传送长度寄存器（WC） —— 存数据长度，每读1个字都自增1
  * 数据缓冲器（DR） —— 缓解外设和主存速度矛盾，外设的数据通过接口电缆，先传入到DR中
  * DMA请求触发器 —— 每传送1个字的数据到DR，外设发送一个DMA请求给DMA请求触发器
  * 控制/状态逻辑 —— 在DMA传输过程中发出控制信号。人称DMA小CU
    * 接收到DMA请求，控制/状态逻辑向CPU申请总线仲裁
    * 获得了总线使用权后，DMA通过数据总线、地址总线、控制总线，把DR里的数据写入内存
    * DMA访问内存要用到系统总线，在这同时CPU就不能和内存交互
  * 中断机构 —— WC 的数据溢出后，向中断机构发送溢出信号，相当于一次DMA传输完成

* DMA请求 —— 每次使用DMA传递一个字，外设 -> DMA请求触发器
* DMA中断请求 —— 每次DMA完成一整块的数据读/写，中断机构 -> CPU

### 三总线结构

![image-20250329214637595](imgs\image-20250329214637595.png)

* 对于单总线结构，DMA通过系统总线访问主存，需要CPU的总线仲裁

* 对于三总线结构，DMA访问主存使用专用的DMA总线，不需要经过CPU的仲裁

  然而内存不能同时被CPU和DMA访问，所以需要解决它们的访问冲突

### 三种DMA传送方式（解决冲突）

![image-20250329213704635](imgs\image-20250329213704635.png)

* 解决DMA和CPU访问主存的冲突问题：

  1. 只要DMA有请求，CPU就把总线让给它，直到DMA传输完一个字后归还总线

     影响了CPU使用主存，可能导致CPU工作停滞

  2. 分配固定的时间片给DMA和CPU

     虽然DMA不再需要反复申请总线使用权，但DMA也许不需要这么多的时间片

  3. 周期挪用

     * DMA访问时CPU正在访问：让CPU完成这个存取周期，然后DMA访问
     * DMA访问时CPU没有访问：给DMA访问
     * DMA和CPU同时访问：给DMA访问，因为如果不及时处理DMA，DR的内容可能会被外设送来的新数据覆盖

## 程序中断方式 VS DMA方式

![image-20250329215417846](imgs\image-20250329215417846.png)

* DMA方式的优先级比程序中断方式高，因为高速设备必须快速响应

![image-20250329215517794](imgs\image-20250329215517794.png)
