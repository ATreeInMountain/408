# 中央处理器CPU

## CPU的功能和基本结构

### CPU功能

![image-20250313180913749](imgs\image-20250313180913749.png)

* 指令控制 —— 控制指令顺序执行

* 操作控制 —— 发布控制信号，调配各个部件执行微操作

  每**一个微操作**都需要**一个微命令**，对应**≥1个控制信号**

* 时间控制 —— 各种微操作的执行需要遵循某种先后顺序

* 数据加工 —— 运算器要进行算术运算、逻辑运算、移位等操作

* 中断处理 —— 如果不支持中断，新程序只能等旧程序执行完才能被响应

### 运算器和控制器的基本功能

![image-20250313213346232](imgs\image-20250313213346232.png)

* 运算器的基本功能就是 数据加工

* 控制器的基本功能包括 指令控制，操作控制，时间控制，中断处理

  * 指令控制的基本功能 —— 取指令，分析指令，执行指令

    **获得操作数的有效地址** 是在 **分析指令** 阶段的工作

    每次**执行完一条指令**，都要判断**中断信号**是否产生，然后发出取下一条指令的命令

  * 每**一条机器指令**被划分成**若干条微操作**

  * 中断处理包括内中断(指令造成的中断)和外中断

### 运算器的构成

#### 七个构件

* 运算器的构成 = ALU + ACC + MQ + X

  实际上，运算器的构成可能更为复杂

![image-20250313215647692](imgs\image-20250313215647692.png)

* 运算器更详细的构成：

  * ALU —— 进行算数/逻辑运算

  * X —— 通用寄存器组，运算器内部有若干个通用寄存器，通常命名为 $R_0, R_1, R_2, R_3$ 等

    * 在X86系统中，**通用寄存器**被命名为 $AX, BX, CX, DX$，它们也可以划分高低位，例如 $AH, AL$
    * 除此以外，$SP$ 堆栈寄存器 也属于通用寄存器组，$SP$ 指向栈帧的栈顶
    * 任何**通用寄存器**的内容，都有可能作为**ALU的两个输入之一**

  * 暂存寄存器 —— 暂存来自主存的数据

    * 如果A来自主存，B来自寄存器，则不需要使用额外的寄存器存主存数据(RISC)

      直接把主存数据读入到暂存寄存器，然后A读暂存寄存器，B读寄存器

    * 存ALU运算结果，等到运算结果稳定了，才放开三态门允许输出结果

      这个暂存寄存器可以增加一些功能，比如移位、累加

      如果增加了这两个功能，就不再需要 ACC、移位器

    * 如果使用 CPU内部单总线方式，暂存寄存器还有其他功能

      * CPU内部单总线不能同时传递 A、B端口需要的数据

        所以先传一个放在暂存寄存器，然后再传一个，两个一起进ALU

  * PSW —— 程序状态字寄存器/标志寄存器，例如存了 OF、CF、ZF、SF等

    * CPU执行指令，**每次发布控制命令**，不仅要分析的**操作码**，还要看 **PSW** 里的各个状态字

  * ACC —— 累加寄存器

  * 移位器 —— 对运算结果进行移位操作

  * 计数器 —— 乘除法时需要记录总共 加法 + 移位 了多少次

### 专用数据通路方式 vs CPU内部单总线方式

专用数据通路方式：

<img src="imgs\image-20250313215831995.png" alt="image-20250313215831995" style="zoom:50%;" />

* **每个通用寄存器的内容，都有可能作为ALU的两个输入之一**

  所以，通用寄存器和A、B输入端都有数据线接入（通用寄存器有多少bit(机器字长)，和每个输入端连的数据线就有多少条）

  例如对于 16bit 的系统，每个通用寄存器都有有16根数据线分别和A输入端、B输入端相连

* 因为A、B输入端和每一个通用寄存器都相连，为了判断端口用的到底是哪个寄存器的数据，有两种判断方式

  1. 使用 **多路选择器**，每个端口用**一个控制信号**控制哪一个寄存器导通
  2. 使用 **三态门**，每组数据线都对应一个三态门，**每个三态门都需要一个控制信号**

* 优点是 性能高 + 基本不会产生数据冲突

  缺点是结构复杂，当通用寄存器数量多时，每一个通用寄存器都和A、B端分别连数据线是困难的

CPU内部单总线方式：

<img src="imgs\image-20250313223341717.png" alt="image-20250313223341717" style="zoom:50%;" />

* 在CPU内部设置一个总线，所有寄存器都直接连接到内部总线上

* 根据 $Ri_{in}、Ri_{out}$ 来判断 $Ri$ 寄存器的输入端、输出端是否导通

* 优点是结构简单

  缺点是性能低 + 容易产生数据冲突（只有一根总线）

### 控制器的构成

#### 七个构件

![image-20250313232150836](imgs\image-20250313232150836.png)

* PC —— 程序计数器，每次取指令后自增“1”

  控制信号：$PC_{in}、PC_{out}$

* IR —— 指令寄存器，IR = OP + Ad

  OP 是操作码，交给指令译码器进行指令分析

  Ad 是地址码，如果数据来源是主存，则根据它得出有效地址EA之后交给MAR（也有可能是立即数，寄存器）

  控制信号：$IR_{in}、OP_{out}、Ad_{out}$

* CU —— 控制单元

  * **指令译码器(ID)** —— 分析操作码，译码后输出到微操作信号发生器

  * 微操作信号发生器 —— 一条机器指令对应多条微操作

    微操作信号发生器结合**指令译码器、时序电路、标志**发出控制指令

  * 时序系统 —— 产生节拍，微操作信号发生器根据时序电路的节拍产生控制信号

* MAR —— 现代计算机一般把MAR、MDR放到CPU，而不是主存

  **MAR是单行道**，CPU控制器只能向它输入，主存只能从它读取

  控制信号：$MAR_{in}、MAR_{out}$

* MDR —— **MDR是双行道**，CPU、主存都能对它进行读取

  CPU读取MDR的控制信号：$MDR_{in}、MDR_{out}$

  主存读取MDR的控制信号：$MDR_{in}E、MDR_{out}E$

### 用户可见的寄存器

* 可见：用户**可以修改该寄存器的内容**

![image-20250313233920878](imgs\image-20250313233920878.png)

* PC：条件转移指令
* PSW：CMP、各种运算
* ACC：加法、乘法都会改变ACC的值
* $R_0、R_1、R_2、R_3$：通用寄存器

![image-20250313234406772](imgs\image-20250313234406772.png)

## 指令执行过程

### 指令周期、机器周期、时钟周期

![image-20250314105758258](imgs\image-20250314105758258.png)

![image-20250314105033179](imgs\image-20250314105033179.png)

* 一个**指令周期**：一条机器指令完成需要的时间
  * 指令周期 = 取指周期 [+ 间址周期] [+ 执行周期] [+ 中断周期]
* 一个**机器周期**（也称**CPU周期**）：一个机器指令子操作（**取指/间址/执行/中断**）需要的时间
  * **取值周期 = 取指 + 分析指令**，因为取指需要访存，分析指令可以快速完成
  * 间址周期：根据间接地址，通过一次访存获取到有效地址
  * 执行周期：长度不固定，例如一次乘法操作需要多次加法+移位，比一次加法操作的执行周期要长
  * **中断周期**，CPU每次执行完一个指令，都需要判断是否有中断信号
  * 一个指令周期可能的机器周期数是不定长的
    * 间址周期 = 0/若干（比如没有采用间接寻址，比如采用了多次间址寻址）
    * 执行周期 = 0/1 （比如空操作不需要执行周期）
    * 中断周期 = 0/1 （比如系统关中断）
* 一个**时钟周期**（也称**CPU时钟周期/节拍/T周期**）：CPU的一个节拍
  * 定长的机器周期 —— 任意机器周期包含的时钟周期数都相同
  * 不定长的时钟周期 —— 机器周期可能包含不同的时钟周期数
  * CPU**时钟周期**是**CPU操作的最基本单位**，时钟周期和CPU**主频**是倒数关系
* 存取周期：指存储器进行两次独立的存储器操作（连续两次读或写操作）所需的最小间隔时间。存取周期往往为固定值。
  * 存取周期 = 存取时间 + 恢复时间

![image-20250314111236169](imgs\image-20250314111236169.png)

* CPU 根据**触发器的四个二进制比特位**判断当前处于哪一种机器周期（**取指/间址/执行/中断**）
* 四种机器周期都有可能会**访存**（取指/获取有效地址/访问操作数/保存程序断点）

### 不同机器周期的数据流

#### 取值周期

![image-20250314112112473](imgs\image-20250314112112473.png)

* (PC) -> MAR
* 1 -> R									  CU发出读信号，通过控制总线，到主存
* M(MAR) -> MDR							(MAR)，通过地址总线，到主存；M(MAR)，通过数据总线，到MDR
* (MDR) -> IR								MDR里此时存的是指令，传给IR
* (PC) + "1" -> PC							 取值完成，PC自增“1”

#### 间址周期

* 间址是根据 形式地址A 获得 有效地址EA

![image-20250314112847015](imgs\image-20250314112847015.png)

* Ad(IR) -> MAR							（或Ad(MDR) -> MAR，因为刚刚经过取指，现在IR和MDR存的都是指令）
* 1 -> R									CU发出读命令
* M(MAR) -> MDR						      获得EA，送到MDR
* (MDR) -> Ad(IR)						       把IR里的A换成EA，（这一步骤也可能不需要，下次直接从MDR取EA）

#### 中断周期

* 只要没有关中断，每次程序执行完一条指令，都会判断有没有中断信号
* 如果有中断，需要进入指定的中断处理程序

![image-20250314114028328](imgs\image-20250314114028328.png)

* (SP)-1 -> SP, (SP) -> MAR					SP指向新栈顶（压栈操作的前半步），把新栈顶位置发给MAR
* 1 -> W								       CU发出写命令
* (PC) -> MDR							     保存断点（压栈操作的后半步），把要保存的PC值发给MDR
* 新地址 -> PC							     PC值更改为中断处理程序入口

### 指令执行方案

![image-20250314115222137](imgs\image-20250314115222137.png)

* 单指令周期 —— 串行执行。虽然指令周期长度不固定，但单指令周期按把所有指令周期延长到和最长指令周期长度一致

  ​			     优：执行简单	缺：浪费时间，降速	

* 多指令周期 —— 串行执行。允许指令周期的长度不同

  ​			     优：不浪费	    缺：需要用复杂的硬件设计判断指令是否执行完成

* 指令流水线 —— 并行执行。在指令执行的不同阶段，需要用到的资源是不一样的，指令流水线致力于让各部件利用率达到最高

  ​			     优：提高了部件利用率

![image-20250314115919088](imgs\image-20250314115919088.png)

## CPU数据通路

* 三种数据流动：

  * **寄存器 <-> ALU**
  * **寄存器 <-> 寄存器**
  * **寄存器 <-> 主存**

* 数据通路：

  * **CPU内部单总线方式**， 同一时刻仅允许一组部件之间进行数据传送

    **CPU内部多总线方式**，同一时刻允许多组部件之间进行数据传送

  * **专用数据通路方式**

* **控制信号**都是 **CU** 发出的（各类in、out信号）

  如果题中有说明控制信号，每次指明数据流动方向时，也需要指明CU发出了何种控制信号

* **内部总线**，CPU内部的各寄存器、运算部件之间的总线

  **系统总线**，CPU和主存、通道、I/O接口间连接的总线

### CPU内部单总线方式

以加法操作为例：

#### <-> 寄存器、 <-> 主存

![image-20250314141056369](imgs\image-20250314141056369.png)

* 取值周期的前半部分，PC的值放进MAR
  * $(PC) -> Bus$					$PC_{out}有效$
  * $Bus -> MAR$					$MAR_{in}有效$

也可以简写成一条 $(PC) -> Bus -> MAR$			$PC_{out}、MAR_{in}有效$

* 取指周期的后半部分，根据PC的值从主存获取下一条指令并放入IR寄存器
  * $1 -> R$								$CU发出读命令$
  * $M(MAR) -> 系统Bus -> MDR$	     $MAR_{out}、MDR_{in}E有效$
  * $(MDR) -> Bus -> IR$				$MDR_{out}、IR_{in}有效$

#### <-> ALU

![image-20250314141724252](imgs\image-20250314141724252.png)

* 执行周期，其中一个数据已经放在了ACC，另一个数据在主存

  * $Ad(IR) -> Bus -> MAR$		   	$IR_{out}、MAR_{in}有效$

  ​       或 $Ad(MDR) -> Bus -> MAR$		$MDR_{out}、MAR_{in}有效$

  * $1 -> R$								$CU发出读命令$
  * $M(MAR) -> 系统Bus -> MDR$ 	    $MAR_{out}、MDR_{in}E有效$
  * $(MDR) -> Bus -> Y$		 		$MDR_{out}、Y_{in}有效$
  * $(ACC) + (Y) -> Z$					$ACC_{out}、ALU_{in}有效，CU向ALU发送加法命令$
  * $(Z) -> ACC$		   				 $Z_{out}、ACC_{in}有效$

#### 例题

取值周期：

![image-20250314144031354](imgs\image-20250314144031354.png)

* Add $(R_0)$, $R_1$	意思是 $((R_0)) + (R_1) -> ((R_0))$

  源操作数使用寄存器寻址，目的操作数采用寄存器间接寻址，运算结果使用寄存器间接寻址

* $M(MAR) -> MDR$时，要令$MemR$有效

* 取值周期内，PC自增“1”（尽早实现PC指向新值）

间址周期：

![image-20250314144754979](imgs\image-20250314144754979.png)

执行周期：

![image-20250314144920658](imgs\image-20250314144920658.png)

* MAR刚刚就是取R0指向的内存地址，现在要写回到同样的地址，所以值不需要改变

### 专用数据通路方式

![image-20250314150810492](imgs\image-20250314150810492.png)

* 题问运算器 <-> 主存

  运算器 = ALU + 通用寄存器 + 暂存寄存器 + PSW + ACC + 移位器 + 计数器

  题中的运算器部分只有 ALU、ACC、PSW标识出来，其实是在问 ACC <-> 主存 的数据通路

![image-20250314151950063](imgs\image-20250314151950063.png)

* 提问指令数据通路，一般**默认指令已经完成了取指**，放在IR中了

![image-20250314152059680](imgs\image-20250314152059680.png)

* (MDR) -> ALU, (ACC) -> ALU

![image-20250314152147832](imgs\image-20250314152147832.png)

### 数据通路总结

![image-20250314152342866](imgs\image-20250314152342866.png)

## CU产生控制信号的原理

### 第一种：硬布线控制器

#### 影响因素

![image-20250314162518690](imgs\image-20250314162518690.png)

* 一个微命令对应一个微操作

* **一个时钟周期**/CPU时钟周期/T周期/节拍 可能执行**多个微操作**

  （如果两个微操作占用的资源不冲突，则它们可以在同一个节拍进行)

* 同一微操作可能出现在不同指令的不同阶段（比如 M(MAR) -> MDR）

* 定长机器周期 ——每个机器周期中包含的时钟周期数相等

  * 一般以取指、间址、执行、中断中最长的机器周期作为定长机器周期的长

  * **长度小于定长**的机器周期，微操作被安排在**末尾的时钟周期**进行

* 确定当前应该发出什么微命令的因素：
  * **操作码**
  * **标记**（来自 PSW、ACC符号位、I/O设备、主存等）
  * 所处在取指/间址/执行/中断中的**哪一个机器周期**
  * 所处在机器周期的**哪一个节拍**

#### CU结构

* CU使用硬布线的方式设计，这种控制器叫做硬布线控制器

![image-20250314163808483](imgs\image-20250314163808483.png)

* CU输出微命令，依靠

  * 操作码 —— 操作码译码器 输入Op(IR)，导通对应的操作码信号，比如 ADD、SUB 分别对应一个输出

  * 标记 —— 来自 PSW、ACC符号位、I/O设备、主存

  * 机器周期数 —— CU内部集成了 FE、IND、EX、INT，分别对应取指、间址、执行、中断

  * 节拍数 —— 节拍发生器，根据时序系统发出的节拍，导通对应的节拍数

    ​		     假设定长机器周期规定一个机器周期包括 n 个节拍，则节拍发生器就有 n 条输出线 $T_0 - T_{n-1}$

* CU 输入这四个因素，导通对应的微命令，每一条微命令对应一个微操作 $C_0 - C_k$

#### CU设计实现微命令

##### 分析微操作系列、设定CPU控制方式

![image-20250314170742656](imgs\image-20250314170742656.png)

![image-20250314170558609](imgs\image-20250314170558609.png)

* 分析指令系统中的每一条指令，在四个机器周期分别需要进行哪些微操作序列
* 设定CPU的控制方式 —— 假设是定长机器周期，长度是3节拍
* 安排微操作顺序 —— 需要把每个机器周期的微操作安排在3节拍之内

##### 安排微操作顺序

取指周期：

![image-20250314171852896](imgs\image-20250314171852896.png)

* 安排微操作节拍的原则：

  1. 微操作序列的**先后顺序**不能随意修改，例如 (PC) -> MAR，一定在 M(MAR) -> MDR 之前

  2. **占用资源不同**的微操作尽量**合并**节拍（比如 (PC) -> MAR 占用了PC、MAR寄存器； 1 -> R 占用了主存，所以可以合并）

  3. **占用时间较短**的微操作尽量**合并**节拍（认为**没有参与访存**的微操作，除了乘除法，基本都时间很短）

     参与访存的微操作尽量不和其他微操作合并，因为访存占用时间很长

间址周期：

![image-20250314172757503](imgs\image-20250314172757503.png)

执行周期：

![image-20250314192531978](imgs\image-20250314192531978.png)

##### 电路设计

![image-20250314193004748](imgs\image-20250314193004748.png)

###### 列出操作时间表

* 已知了指令系统里的所有指令，在每个机器周期的每一个节拍分别需要做什么

  把四个机器周期，每个**节拍要做的所有操作**进行一个**汇总**

  在操作时间表里，纵轴是节拍的所有微操作，横轴是所有的机器指令

  如果在机器**指令在对应的节拍进行了某个微操作，置1**

  最终获得取指、间址、执行、中断四个操作时间表

取值周期：

![image-20250314193048247](imgs\image-20250314193048247.png)

* I 控制 CU里的间址特征位
  * 非访存指令在取指后，一定没有间址，直接执行
  * **访存指令、转移指令**，例如 ADD，JMP 等，操作数使用十种数据寻址中的某一种，有**可能有间址周期**

间址周期：

![image-20250314193552131](imgs\image-20250314193552131.png)

* 非访存指令不会有间址周期，所以不参与间址时间表
* 最后一行，代表是否是多级间址，如果间址不止一级，下一个周期还是间址周期

执行周期：

![image-20250314194211127](imgs\image-20250314194211127.png)

###### 写最简表达式

![image-20250314194429174](imgs\image-20250314194429174.png)

###### 画逻辑图

![image-20250314194506200](imgs\image-20250314194506200.png)

#### 硬布线控制器的总结

![image-20250314194811077](imgs\image-20250314194811077.png)

* 硬布线控制器，每一种微命令都有自己的电路

  优点：执行速度**快**

  缺点：（1）指令越多，CU内部布线越多，因此一般适用于**RISC**

  ​	    （2）**扩充指令**要大改布线，**不方便**

### 第二种：微程序控制器

#### 微程序概念

![image-20250314200411732](imgs\image-20250314200411732.png)

* 微指令的定义：

  * 一个高级语言程序，经过编译，包含若干条机器指令

  * 一条机器指令的执行叫一个指令周期

    一个指令周期有四个机器周期，每个机器周期又有若干节拍，每个节拍要执行若干微操作

    把一个节拍要进行的若干微操作，封装成一个微指令

    于是**一条机器指令，是一个封装了若干微指令的微程序**

  * 一个**微命令**，对标**一个微操作**

    一条**微指令**，对标**一个节拍的若干微操作**

  * 1高级语言程序 -> 若干高级语言指令

    1高级语言指令 -> 若干汇编指令

    1汇编指令 -> 1机器指令

    1机器指令 -> 1微程序
    
    1微程序 -> 若干微指令
    
    1微指令 -> 若干微命令/微操作
    
    1微命令 -> 若干控制信号

* 微指令的组成：

  * 微程序使用“**存储程序**”思想，**所有微程序**都存在**控制存储器CM**里（有地址）

  * 微指令 = **操作控制**(注明该微指令包括哪些微操作) + **顺序控制**(注明下一条微指令的地址)

  * 所以，一个定长机器周期的CPU，它每个微程序具有相同个数的微指令

#### CU结构

![image-20250315171203723](imgs\image-20250315171203723.png)

* 微操作信号发生器的输入：操作码、时序信号、标志

* 微程序控制电路：(类似于一个小型的 CPU控制器 <-> 内存)

  * IR 的操作码进入CU，"指令译码器" **微地址形成部件**分析操作码，产生微程序序列**起始和后继微地址**

    微程序控制器的操作码信息不是来自于指令译码器ID，而是直接来自于Op(IR)

  * “微操作信号发生器” **顺序逻辑**，结合 *CMDR的下地址、微地址形成部件、时序信号CLK、标志* 产生**真正的微地址**

  * ”PC + MAR“ **CMAR(μPC)**，用来**存储**顺序逻辑产生的的**微地址**

  * ”译码器“ **地址译码**，CMAR传递来的地址码，选中CM里的微命令

  * “主存” **控制存储器CM**，用来**存储**所有机器指令对应的**微程序**。是**ROM**芯片(只读、非易失性、读写速度比RAM快) 

  * ”IR + MDR“ **CMDR(μIR)**，用来**存储**从CM中取出的**微指令**

* 微指令 = 操作控制(微操作内容) + 顺序控制(下地址)

  操作控制(微操作内容) —— 根据它产生控制信号

  顺序控制(下地址) —— 下地址的信息要送给顺序逻辑

![image-20250315171816842](imgs\image-20250315171816842.png)

* 标志包括操作数寻址标志(判断**间址**周期)，中断信号(判断**中断**周期)

* 每条机器指令可能是对应一个**微程序**，也可能是对应一个**微程序段**，这是因为取指、间址、中断微程序段可以公用

  如果每条机器指令可能是对应一个微程序，则有 n 条机器指令的指令系统，CM里至少有 **n 个微程序**

  如果每条机器指令可能是对应一个微程序段，则有 n 条机器指令的指令系统，CM里至少有 **n+1 个微程序段**（有些比较古老的CPU没有提供间址、中断周期）

![image-20250315172835273](imgs\image-20250315172835273.png)

* CM里，**取指**周期的微指令**固定从#0存放**
* **微周期** —— 执行一条微指令需要的时间

#### CU设计实现微指令

* 一条微指令对应多个微命令，一条微命令对应多个控制信号

##### 微指令的格式

![image-20250315194343957](imgs\image-20250315194343957.png)

* 水平型微指令 —— 一条微指令定义多个可并行的微命令，但微指令长
* 垂直型微指令 —— 一条微指令定义一个微命令，但微程序长
* 混合型微指令 —— 适当的给垂直型微指令添加内容，微指令和微程序都不太长

##### 微指令的编码方式

以水平型指令的编码方式为例：

###### 直接编码

![image-20250315194833914](imgs\image-20250315194833914.png)

* 直接编码方式

  * 微指令的控制码部分，**每一bit**对应一个**微操作**。微指令包含哪些微操作，就让对应的控制码比特位为1

    一个**微操作对应**的**控制信号**不止一个，例如 (PC) -> MAR，对应 $PC_{out} 和 MAR_{in}$ 两个控制信号

* 快、但微指令编码长，会导致CM过大

###### 字段直接编码

![image-20250315200857631](imgs\image-20250315200857631.png)

* 字段直接编码方式

  * 原则：把所有的微命令分类，**同一类**的微命令都是**互斥**的，**不同类**的微命令都是**相容**的。每个类的微命令从0开始编码

    ​	    把微指令的控制码部分分段，每个字段对应一个类

    ​	    在设计微指令时，每一个微指令对应的微操作，就**在对应段里填微操作对应的编码**

  * 每一个段都对应一个译码器，所以**段不能过长，否则增加译码时长**

  * 每一个段都要**留出一个位置**，用于表示 —— 微指令中没有用到该类微命令

* 微指令编码短，但慢（要译码）

###### 字段间接编码/隐式编码

![image-20250315201135520](imgs\image-20250315201135520.png)

* 多级译码
* 更短，但更慢（更多层译码）

##### 顺序逻辑产生微地址的方式

* 六种

![image-20250315201957283](imgs\image-20250315201957283.png) 

* 在高级语言程序中，两种指令寻址方式 —— 顺序寻址、跳跃寻址
* 类似”顺序寻址“ ——
  * 根据**机器指令操作码**形成（根据机器指令的操作码判断微程序起址）
  *  (CMAR) + "1" -> CMAR （**计数器法**）
* 类似”跳跃寻址“ ——
  * 微指令的 顺序控制部分 就是下一条微地址（**断定方式**）
  * **分支转移**，顺序控制部分 = 转移条件+转移地址（符合转移条件，才能转向对应微地址）
* “顺序逻辑 根据 微地址形成部件、CLK、标志、CMDR的顺序控制部分 分析下址” ——
  * **通过测试网络**
* “硬件” ——
  * 取指、中断这些公共的微程序段，又存放位置是固定，所以只要进入这个阶段，直接**硬件自动产生微程序段入口地址**

###### 断定方式例题

![image-20250315205958715](imgs\image-20250315205958715.png)

* 断定方式，意思是通过 微指令的顺序控制部分 指定下址

  也即 顺序控制部分 需要存放所有的 微指令地址

​	题中，取指周期有2条微指令(公有)；一共有32条机器指令，它们的执行周期都有4条微指令

​	所以，一共有 32 * 4 + 2 = 130 条微指令，至少要用 8bit 存储微地址

![image-20250315210658990](imgs\image-20250315210658990.png)

#### CU设计实现微命令

* 硬布线控制器设计CU，是
  * 分析微操作序列（执行序列）
  * 设定CPU控制方式（合并的规格）
  * 安排微操作序列（合并执行序列）
  * 电路设计（逻辑表达式、电路）
* 微程序控制方式设计CU：
  * 安排节拍
  * 确定微指令格式
  * 编写微指令码点

##### 安排节拍

![image-20250315211928099](imgs\image-20250315211928099.png)

* 硬布线 和 微程序，**两者在取指周期要执行的微命令有区别**

  硬布线控制器：最后把操作码给 指令译码器ID

  微程序控制器：最后把操作码给 微地址形成部件

![image-20250317140909801](imgs\image-20250317140909801.png)

* 节拍0 —— 取指首地址在 #0，由硬件自动给出

  增加节拍1 —— **Ad(CMDR) -> CMAR**	(节拍2的微地址，由节拍1的微指令下址给出)

  节拍2

  增加节拍3 —— **Ad(CMDR) -> CMAR**	(节拍4的微地址，由节拍2的微指令下址给出))

  节拍4，是取指的最后一个节拍，转到哪一个执行微程序段，就不能依靠下址实现

  增加节拍5 —— **微地址形成部件 -> CMAR** (转到哪一个执行微程序段，和机器指令操作码有关)

* **硬布线的速度比微程序快**

  硬布线的取指周期，只有3个节拍

  微程序的取指周期，为了找下址，每个节拍后需要增加1个节拍（其他周期也是）
  

![image-20250317142037619](imgs\image-20250317142037619.png)

#### 微程序设计分类

![image-20250317142411350](imgs\image-20250317142411350.png)

* 静态微程序 —— 所有的微程序写入到CM中，**不再修改**

  动态微程序 —— 写入的微程序可能发生修改（增加或者优化），则CM要使用**可擦除的ROM**，例如RPROM

* 豪微程序 —— 一条微指令 = 一个豪微程序

#### 微程序控制器的总结

![image-20250317142901508](imgs\image-20250317142901508.png)

### 硬布线和微程序比较

![image-20250317142709423](imgs\image-20250317142709423.png)

## 指令流水线

![image-20250315214759548](imgs\image-20250315214759548.png)

* 在指令执行的每个阶段，占用的资源各不相同（但也互有重叠）
* 使用串行执行方式，资源利用率不高

![image-20250315215039715](imgs\image-20250315215039715.png)

* 流水线方式可以使用 **n次重叠执行方式** 执行指令

  但由于每个阶段占用的资源还是有重叠的,为了实现流水线，重叠的硬件资源需要多添加硬件

  所以虽然**提速**，**硬件开销增加**

* 假设指令的执行被分成 **m 个阶段**

  最多可以执行 **m-1 次重叠执行方式**，最多有 **m 条指令同时运行**

### 两种流水线视图

![image-20250315215853179](imgs\image-20250315215853179.png)

* 指令执行过程图 —— 每行都表示一个指令
* 时空图 —— 每行都表示一个指令执行阶段（上图就是把一条指令的执行划分成了四个阶段）

### 流水线性能指标

![image-20250317143201211](imgs\image-20250317143201211.png)

* 吞吐率TP —— 单位时间内执行的机器指令条数

  $吞吐率 = \frac{运行的机器指令条数}{运行这些机器指令使用的时间} = \frac{n}{kt + (n-1)t}$

  **当 n -> ∞ 时，运行一条机器指令的时间 -> t，吞吐率 -> 1/t**

* 装入时间 —— 每个机器周期的硬件逐渐投入工作

  排空时间 —— 每个机器周期的硬件逐渐退出工作

![image-20250317143731233](imgs\image-20250317143731233.png)

* 加速比S —— 使用流水线后，加速了多少倍

* 无流水线 $T_0 = nkt$

  有流水线 $T_k = kt + (n-1)t$

  加速比 $S = \frac{T_0}{T_k}$

* n -> ∞，S -> k

![image-20250317144312599](imgs\image-20250317144312599.png)

* 效率E —— 设备利用率

* $效率 = \frac{流水线面积}{矩形面积} = \frac{T_0}{kT_k} = S/k$ (可以用加速比计算效率)

  效率越大越好，不会超过1

  n -> ∞ 时，效率 -> 1

### 机器指令执行的五个阶段

![image-20250317145900021](imgs\image-20250317145900021.png)

* 理想情况：各阶段花费时间相同，每个阶段结束后能立即进入下一阶段

* 机器指令的执行一般分为五段：取指$IF$、译码$ID$、执行$EX$、访存$M$、写回$WB$

* 有些机器指令可能不需要五个段都有，并且各部件实际耗时可能不同

  为方便流水线的设计，规定**每个机器指令必须有这五个阶段，每个阶段的耗时都一致**（以最长耗时为准）

* 流水线**每个阶段都要有缓冲寄存器**，或称为**锁存器**

  其作用是保存本流水段的执行结果，等待下一阶段开始时提供给下一段使用

* 流水线图：
  * Instruction Cache，指令Cache
  
    Data Cache，数据Cache
  
    一般指令、数据都**先从cache找**，根据局部性原理都能找到。所以虽然叫做“取指”、“访存”，其实大概率还是访问Cache
  
  * 指令、数据被保存在不同的Cache中，这意味着IF和M阶段访问不同的Cache，没有资源冲突
  
  * Imm，立即数。数据来自于主存、寄存器、立即数。（来自主存的数据都会在寄存器中转，所以只考虑寄存器、立即数的数据）
  * Store，假如要向主存写数据，要写的数据就存在Store里

### 指令流水线的三个影响因素

#### 1. 结构相关（资源冲突）互斥

![image-20250317151205932](imgs\image-20250317151205932.png)

* 资源重复配置，例如MEM分成指令部分和数据部分（增加硬件）

#### 2. 数据相关（数据冲突） 同步

![image-20250317151851968](imgs\image-20250317151851968.png)

* 产生原因：指令执行有顺序要求
* 解决方式：
  1. 暂缓执行（有硬件、软件两种方式，都相当于插入几个空操作）
  2. 数据旁路（不需要等那么久，r1计算出来就直接传给ALU作为下一条指令的输入）
  3. 编译优化（人为优化编码）

#### 3. 控制相关（控制冲突）

![image-20250317152511561](imgs\image-20250317152511561.png)

* 产生原因：指令使用跳跃寻址，或者发生中断，使用指令流水线可能会执行一些不必要执行的指令

* 解决方式：
  1. 预测是否转移（简单预测：永远预测要转移，或永远预测不转移；动态预测：根据历史情况调整预测）
  2. 转移和不转移两手准备（需要两个指令执行系统）
  3. 提前形成转移条件码（类似并行进位的串行加法器，提前生成进位）
  4. 提高转移预测的猜准率（方法1的进化）

![image-20250317153126799](imgs\image-20250317153126799.png)

### 流水线分类

![image-20250317175215141](imgs\image-20250317175215141.png)

![image-20250317175328756](imgs\image-20250317175328756.png)

1. 根据流水级别
   * 处理机级流水 —— 把一条指令的执行过程分成五个阶段：取指、译码、执行、访存、写回，在这五个阶段实现流水线
   * 部件功能级 —— 把每个阶段再细分成不同阶段，例如浮点数运算，把执行阶段再分成四个小阶段，在小阶段再实现流水线
   * 处理机间流水 —— 每个处理机完成一个阶段的任务，把处理机当作处理机级流水中每个阶段的硬件实现流水
2. 单功能流水线、多功能流水线
   * 单功能流水线 —— 每个流水线阶段的功能单一
   * 多功能流水线 —— 一个流水线阶段能实现多种功能
3. 动态流水线、静态流水线
   * 静态流水线 —— 每个阶段在同一时间只有一种功能
   * 动态流水线 —— 一个阶段在同一时间可能会执行多个功能

4. 线性流水线、非线性流水线
   * 线性流水线 —— 各个阶段是线性执行，不需要反馈回路
   * 非线性流水线 —— 存在反馈回路，某些阶段可能会数次通过流水线。例如数据旁路技术就要ALU输出接到ALU输入

### 流水线的多发技术

![image-20250317180219998](imgs\image-20250317180219998.png)

* 超标量技术：
  * 一次并发多条指令（可能需要配置多套部件）
  * 合并并发指令时，定好的指令顺序不能改变
  * 合并并发指令时，哪些指令允许并发执行是需要经过编译优化的

![image-20250317180652659](imgs\image-20250317180652659.png)

* 超流水技术：
  * 对每个机器周期**再进行细划分**，然后再在这些细化分上进行流水线
  * 进一步加快了指令执行
  * 不能改顺序，要编译优化

![image-20250317181035190](imgs\image-20250317181035190.png)

* 超长指令字：
  * 合并机器指令，把多个不冲突的指令合并成一条
  * 可能会需要增加硬件

![image-20250317182029271](imgs\image-20250317182029271.png)

### 五段式指令流水线

* 五段 —— 取指$IF$、译码$ID$、执行$EX$、访存$M$、写回$WB$
* 考试常见的指令：
  * 运算、LOAD、STORE、条件转移、无条件转移

![image-20250318233007088](imgs\image-20250318233007088.png)

* 运算类指令

  M访存 阶段是空段（RISC，精简指令集，除了LOAD、STORE指令，其他指令不允许访存）

![image-20250318233501331](imgs\image-20250318233501331.png)

* Load 指令

  五个阶段都需要用到，因为如果是偏移寻址，需要用 ID译码、EX执行阶段获得要访问的主存地址

![image-20250318234210225](imgs\image-20250318234210225.png)

* Store 指令

  * 通过 A存基址、Imm存偏移量 来计算要访问的主存地址

  * 通过 B存放要写入主存的数据
  * 之所以用 A、Imm 找地址，是因为根据图中的线路，只有B能直接把数据传给 Store

  WB写回 段是空段，因为目的是把数据写入内存，不需要写回操作

![image-20250318234726940](imgs\image-20250318234726940.png)

* 条件转移指令

  * 不管是条件转移，还是无条件转移，通常都采用相对寻址（EA = (PC) + A，即基址是PC）

  * beq —— branch if equal，当 (Rs) == (Rt) 时使用相对寻址，否则还是正常的顺序寻址

    * 如果采用相对寻址，$(PC) + 指令字长 + (偏移量 * 指令字长) -> PC$

      (PC) + 指令字长，意为PC指向顺序寻址时下一条指令的地址

    * 如果不满足条件，要顺序寻址，$(PC) + 指令字长 -> PC$

  * ID译码 阶段，把要比较的 Rs、Rt，放在 A、B上交给ALU；把相对寻址的偏移量交给 Imm

  * EX执行 阶段，判断下PC的值应该使用顺序寻址，还是相对寻址

  * WrPC写回PC 阶段，计算新PC值，并修改PC

    **WrPC阶段**很短，**一般并入给M访存 阶段**（不并入WB写回 阶段，是因为WB一般是写回给通用寄存器）

​	WB写回 段是空段

![image-20250319161736103](imgs\image-20250319161736103.png)

* 无条件转移指令

  * 条件转移：IF取指令、ID交付数据和偏移量、EX判断PC下址寻址方式、M写回，WB空

    无条件转移：IF取指、ID交付地址、EX写回，M空，WB空

  * 无条件转移下址寻址方式确定，不需要EX阶段判断

  * 正常来说，写回寄存器的值应该统一在WB写回 段

    但**指令流水线越早发现地址跳转，就越能避免执行非必要指令**

    所以不管是条件转移指令，还是非条件转移指令，一旦确认了PC新值，要立马执行WrPC段修改PC

    **WrPC段很短，可以并入到 五个段其中某一个**

​	M访存、WB写回 段是空段

#### 例题

![image-20250319162812870](imgs\image-20250319162812870.png)

* I3 的 ID 段被阻塞：

  加法指令需要 [a]、[b] 放在 R1、R2 的数据

  I1、I2 取数指令的写回操作在WB阶段完成

  所以要等取数完成再执行加法

* I4 的 IF 段被阻塞：

  五段式流水线，每一个阶段都有自己的寄存器

  I3 的 ID 段被阻塞，I3 的指令还存放在 IF 段的寄存器里

  如果执行 I4 的 IF 段，就会覆盖 I3 指令

## 多处理器

### 基本概念

### SISD

![image-20250319195148547](imgs\image-20250319195148547.png)

* SISD —— 单指令流单数据流（指令并发处理，数据并发处理）

* 单指令流 —— CPU同一时间段内只能处理一个指令序列

  提升CPU效率：指令流水线

* 单数据流 —— 每条指令只能处理 1~2 个数据

  加快数据传输：多模块交叉存储器（低位交叉编址）

* 1个CPU + 1个主存

### SIMD

![image-20250319195737067](imgs\image-20250319195737067.png)

* SIMD —— 单指令流多数据流（指令并发处理，数据并行处理）

* 例如对数组的所有元素，都要进行同一种操作，就可以用单指令流多数据流。

  虽然是**执行同一条指令**，但是这条指令可以**修改多个数据**

* 1个CU + **多个ALU + 多个局部寄存器组(局部寄存器 + 数据寄存器 + 地址寄存器)** + 1个主存

### MISD

* MISD —— 多指令流单数据流（指令并行处理，数据并发处理）
* 理论存在，现实不需要

### MIMD

* MIMD —— 多指令流多数据流（指令并行处理，数据并行处理）

* 多个核 + ≥1个主存

  每个核都是单指令流单数据流，多个核就能实现多指令流多数据流

#### SMP 多处理器系统

![image-20250319201435950](imgs\image-20250319201435950.png)

* **多处理器系统 = 共享内存多处理器系统 = 多核处理器系统**

  共享 —— **共享同一个主存，共享同一个最低级Cache**（Cache根据速度不同，也有细分L1、L2、L3）

* 各处理器之间，可以通过LOAD/STORE命令访问主存，传送数据

* 多个处理器 + 1个主存

> * 共享内存多处理器 —— 强调多个处理器共享一个主存
>
>   各处理器共享单一地址空间，可以通过LOAD/STORE命令访问主存，传送数据
>
> * 多核处理器 —— 强调一个CPU芯片上集成了多个处理器
>
>   * 多核处理器 = 片内多处理器 = CMP (Chip-Level MultiProcessing)
>   * 各处理器共享主存，共享LLC（最低级Cache）

#### 多计算机系统

![image-20250319202045940](imgs\image-20250319202045940.png)

* 多计算机系统 = 分布式计算系统 = 消息传递系统

  把一个大任务分成多个小任务，交给多个计算机实现

* 各处理器(分布在不同的计算机上)之间，只能通过“消息传递”传送数据

  由于不共享主存，不能像多处理器系统一样，通过LOAD/STORE命令访问主存，传送数据

* 多个计算机 = 多个CPU + 多个主存

![image-20250319202345606](imgs\image-20250319202345606.png)

### 向量处理器

![image-20250319203727648](imgs\image-20250319203727648.png)

* SIMD 的进阶

* 顾名思义，是专门为了处理**向量计算**的

  向量处理器的 **操作对象以向量为单位** （而不是标量）

* SIMD —— 1个CU + 多个ALU + 多个局部寄存器组(局部寄存器 + 数据寄存器 + 地址寄存器) + 1个主存

  向量处理器 —— 几乎相同，只是数据寄存器变成**向量寄存器**（操作对象以向量为单位）

* 如果是MIMD中的向量处理器：

  每次以向量为单位进行存取，数据读写量大

  因此主存需要**大容量**，而且通常支持**多端口并行读取**，例如双端口（但读-写、写-读、写-写不能同时进行）

![image-20250319204755945](imgs\image-20250319204755945.png)

## 硬件多线程

![image-20250319170257195](imgs\image-20250319170257195.png)

* 不支持硬件多线程的处理器：

  **只有一组** IR、通用寄存器组、PC

  如果每次线程切换都要**压栈访存**，时间开销很大

* 支持硬件多线程的处理器：（并行实现多线程）

  **有多组** IR、通用寄存器组、PC

  运行多个线程，可以把不同的线程信息存入不同的硬件组

  这样当 CPU 执行到该线程时，不需要等待 IR、通用寄存器组、PC 的旧值从内存弹出

### 三种硬件多线程

![image-20250319171239556](imgs\image-20250319171239556.png)

![image-20250319171214645](imgs\image-20250319171214645.png)

* 以上三个支持硬件多线程，也就是说有**多套硬件**存储指令执行现场
* 细粒度多线程 —— 每个时钟周期执行同一线程的不同指令，**切时钟周期就切线程**（指令级并行，线程级不并行）
* 粗粒度多线程 —— **一直执行同一线程**的指令，**直到流水线阻塞**（指令级并行，线程级不并行）
* 同时多线程(SMT) —— **每个时钟周期执行不同线程的指令**（指令级并行，线程级并行）







