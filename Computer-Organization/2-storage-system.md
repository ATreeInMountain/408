# 存储系统

## 基本概念

### 存储器的层次化结构

![image-20250307164156043](imgs\image-20250307164156043.png)

* CPU 和 cache、主存都能直接交互，**CPU不能和辅存直接交互**

* 有时 辅存 和 外存 被认为是两个概念，有时被认为是一个

* cache-主存是硬件完成的，主存-辅存是硬件+操作系统完成的

* cache 解决了 CPU-主存 的速度问题

  辅存 解决了 CPU-主存 的容量问题

### 存储器分类

![image-20250307164741426](imgs\image-20250307164741426.png)

![image-20250307164825614](imgs\image-20250307164825614.png)

![image-20250307165105899](imgs\image-20250307165105899.png)

* **随机存取存储器 RAM** —— 根据地址存取，地址和存取时间无关（类似数组）
* **顺序存取存储器 SAM** —— 根据地址存取，地址和存取时间高度相关（例如听磁带）
* **直接存取存储器 DAM** —— 根据地址存取，RAM 和 SAM 的结合，速度大于SAM，小于RAM（例如硬盘）
  * SAM 和 DAM 统称为 **串行访问存储器**（地址和存取时间相关）
* **相联存储器 CAM** —— 根据内容读取（类似散列存储，例如快表）

![image-20250307165632297](imgs\image-20250307165632297.png)

* 只读存储器 ROM
* ROM的意思是只能读不能写，RAM的意思是随机存取存储器，两个概念不是相对的

![image-20250307165848641](imgs\image-20250307165848641.png)

* 主存、cache 都是**易失性存储器**，断电即失；

  磁盘光盘是**非易失性存储器**

* DRAM **破坏性读出**

  SRAM **非破坏性读出**

### 存储器性能指标

![image-20250307170249503](imgs\image-20250307170249503.png)

* 存储容量 （回顾主存=存储体 + MAR + MDR，存储体的存储容量就是MAR、MDR的位数决定的）
* 主存**存储速度** = 主存**数据传输率** = **主存带宽** = **数据宽度/存储周期**（意为一个存储周期内可以存取的比特数）
* **存取周期** = **存取时间** + 恢复时间

### 基本概念总结

![image-20250307170634204](imgs\image-20250307170634204.png)

## 主存储器的基本组成

### 存储元的构成、存取原理

![image-20250307171136968](imgs\image-20250307171136968.png)

* 主存 = 存储体 + MAR + MDR，**主存是半导体存储器**
* 存储体、存储单元、存储元、存储字、存储字长（**存储字长是word**，由计算机硬件厂商决定）
* 存储元 = MOS管 + 电容
  * MOS管：半导体，接高电压可通电，不接不通电，MOS管不通电，电荷就存在电容里不能导出，实现了电荷的存储
  * 电容：接高电压产生电荷(1)，不接不产生(0)
  * 读数据：MOS接高电压，看电容里有没有电荷流出
  * 存数据：MOS接高电压，电容接/不接高电压，然后MOS断电，电荷就存在了电容里
* 主存存取数据**只能按照存储字进行存取**的原因

### 按地址访问数据的原理

![image-20250307172337989](imgs\image-20250307172337989.png)

* 实现 **根据地址进行读写** 的两个重要器件：**译码器 + 控制电路**
* 译码器：根据MAR的地址选择存储单元
  * **数据总线**：联通每一个存储单元，**宽度 = 存储字长**
* 控制电路：负责控制在电流稳定时读写
  * **片选信号**：$\bar{CS}$ 或 $\bar{CE}$，当 $\bar{CS} / \bar{CE}$ 有效时才代表芯片被选中（带  $\bar{}$  意味着低电平有效）
  * 读写信号线可能有一根，也可能有两根

![image-20250307173400984](imgs\image-20250307173400984.png)

* 片选信号是因为 一个内存条可能有不止一个 存储芯片
* 一个存储芯片内部大致分为三个部分：译码驱动（驱动器的作用是加强电信号） + 存储矩阵 + 读写电路
* 内部封装后，存储芯片的
  * 输入引脚 = 片选 + 读写 + 地址线
  * 输出引脚 = 数据线
* 芯片的存储描述：8K(存储单元的个数) * 8(存储字长)
  * 由此，存储空间 = $2^{13} * 8 bit$
  * 地址线有13位，数据线有8位，所以芯片至少有 13+1+1+8=23 个引脚（假设读写信号线有1个）

![image-20250307175201115](imgs\image-20250307175201115.png)

## DRAM 和 SRAM

### 区别

![image-20250307175655896](imgs\image-20250307175655896.png)

* DRAM 和 SRAM 的主要区别在于 存储元不一样（栅极电容/双稳态触发器）

![image-20250307180359352](imgs\image-20250307180359352.png)

* DRAM的存储元有 1个MOS管，SRAM有6个MOS管（集成度低，成本高，功耗大）
* DRAM的存储元 有1个数据线，SRAM有2个数据线
  * 读出时，A无B低=1，A低B无=0
  * 写入时，A高B低=1，A低B高=0

* 动态RAM(**DRAM**) —— **主存** —— **栅极电容** —— **破坏性读出**（需要恢复，所以慢）——集成度高 —— 成本更低 ——功耗更低
* 静态RAM(**SRAM**) —— **cache** —— **双稳态触发器** —— **非破坏性读出**（快）—— 集成度低 —— 成本更高 —— 功耗更高

![image-20250307181038231](imgs\image-20250307181038231.png)

* 破坏性读出存储器：读出数据会破坏原本存储的内容
* 易失性存储器：断电即失
* DRAM(主存)，SRAM(cache)都是 易失性存储器，但DRAM是破坏性读出存储器，SRAM是非破坏性读出存储器

### DRAM刷新

* 电容里的电荷只能维持 2ms，所以要在电荷消失之前刷新电荷

![image-20250307181817364](imgs\image-20250307181817364.png)

* 使用行列地址可以大幅减少地址选通线的数量
  * 假设有 n 个地址线，1个译码器，则译码器的输入有 n 个，输出有 $2^n$ 个
  * 如果使用行列存储，2个译码器（行列存储），则每个译码器的输入有 n/2 个，输出有 $2^{n/2}$ 个
  * 地址选通线的个数 从 $2^n$ 个 到 $2 * 2^{n/2} = 2^{n/2 + 1}$ 个

* 按照行列地址存储的存储单元，只有当行列地址都被选通时，才认为存储单元被选中

![image-20250307182846365](imgs\image-20250307182846365.png)

* 默认栅极电容失效时间是 **2ms**，也就是说DRAM必须每2ms完成一次刷新
* DRAM 的刷新是以 **行** 为单位的（例如 128*128的行列存储，就有128个行需要被刷新）
* 每次刷新的时间大致等于 **1个存取周期/读写周期** （例如128个行的，就必须在2ms内花128个存取周期进行刷新）
  * 假设一个存取周期有 5us，则2ms内有 2ms / 5us = 4000 个存取周期，要选出其中的128个存取周期进行刷新
* 选择刷新时间的三种方式
  1. **分散刷新**，每经过一个存取周期就刷新一次，刷新时无法存取，即4000个存取周期里的一半用来刷新DRAM
  2. **集中刷新**，找一个集中的128个存取周期进行刷新，在这期间无法访问DRAM，叫做**死时间/死区**
  3. **异步刷新**，一共有4000个周期，要找128个周期进行刷新，平均每4000/128个周期要刷新一次（可以灵活选择刷新时间，比如在CPU译码期间刷新）

* DRAM使用栅极电容，所以需要刷新，**SRAM**使用双稳态触发器**不需要刷新**（所以**快**）

* **DRAM刷新**操作是自主完成的，**不需要CPU参与**

### DRAM的地址线复用技术

![image-20250307184122199](imgs\image-20250307184122199.png)

* SRAM不需要地址复用，DRAM需要地址复用
  * 因为SRAM集成度低，存储容量小，地址线数目小
  * DRAM集成度高，存储容量大，地址线数目大
* DRAM的地址复用指的是，在给芯片传递地址线时，只需要n/2个地址线，分时间传送行地址和列地址
  * 所以 **DRAM 的引脚数量 = 地址线/2 + 片选 + 读写 + 数据线**
* 在计算芯片的引脚数量时，需要关注是不是DRMA芯片

* 现在主存更多用 **SDRAM** 而不是 DRAM

## ROM

* RAM：**随机存取存储器**，存取时间和地址无关

* ROM：**只读存储器**，只能读不能写

**RAM** 分为 SRAM(cache) 和 DRAM(主存)，都是**易失性存储器**

**ROM** 一般都是 **非易失性存储器**

### ROM分类

![image-20250307185649947](imgs\image-20250307185649947.png)

* 尽管 ROM 的定义是只读存储器，但**有些ROM的品类也可以进行擦除重写**
* **MROM**：只读，只能厂家写
* **PROM**：只读，可以用户个人写
* **EPROM**：可擦除读写，易失
  * **UVEPROM**：只能全部擦除
  * **EEPROM**：可擦除特定字
* **Flash Memory(闪存)** ：可擦除重写，非易失（例如**U盘**）
  * 闪存的每个存储元只需要单个MOS管，**集成度比DRAM还高**
  * 闪存每次写操作都要先擦除，所以 **写速度 < 读速度**
* **SSD(固态硬盘)**：控制单元 + Flash芯片
  * SSD 和 Flash Memory 的区别就在于 **控制单元不一样**
  * 固态硬盘的速度快于**机械硬盘**

### BIOS

![image-20250307190441478](imgs\image-20250307190441478.png)

* **BIOS芯片是ROM芯片**，存储了计算机开机时需要使用的**自举装入程序**
* 通常把BIOS芯片集成到主存里，所以**主存里有RAM+ROM**
* 主存里的ROM和RAM使用统一编址

![image-20250307190716282](imgs\image-20250307190716282.png)

## 主存提速

### 主存速度需要提升

![image-20250307203148104](imgs\image-20250307203148104.png)

* 存取周期 = 存取时间 + 恢复时间
* DRAM的恢复时间可能是存取时间的几倍，这意味着存取之后的恢复时间里，CPU无法访问内存（尤其是多核，更浪费时间）

### 双端口存储器

![image-20250307203734105](imgs\image-20250307203734105.png)

* 解决多核CPU访问同一内存条的情况
* 读写冲突时，置忙信号，暂时关闭其中一个端口，等另一个端口完成操作后再放开

### 多体并行存储器

![image-20250307204416789](imgs\image-20250307204416789.png)

* 访问地址时总是访问连续地址（如访问数组、编程指令一般都是连续存放的）

* **高位交叉编址的多体存储器**（**用 地址线的高位 选择存储体**，这时连续的地址放在同一个存储体里）
  * 访问连续的地址，每次访问完基本都要等待恢复
  * 高位交叉编址 只相当于 **扩容**
  
* **低位交叉编址的多体存储器**（**用 地址线的低位 选择存储体**，这时连续的地址放在不同的存储体里）

  * 访问连续的地址，访问完可以直接访问下一个地址（因为在不同的存储器里，访问第二个存储器不需要等第一个存储器恢复）
  * 相当于 **扩容 + 提速**

* **低位交叉编址更快**

  * 假设访问地址 存取时间 = r，存取周期 T = 4r（也就是说恢复时间 = 3r）

    * 如果使用高位交叉编址，访问 n 个连续地址的时间是 nT

    * 则访问 n 个连续地址的时间是 (n-1)r + T（这里包括了完整的访问时间，即包括了所有内存恢复的时间）。在 n 很大的情况下，读写一个存储字长的时间接近 r

#### 低位交叉编址 存储体数量选择

![image-20250307205612461](imgs\image-20250307205612461.png)

* 存取时间 = r，存取周期 = T，则应满足 **存储体的数量 m ≥ T/r**
  * 为了使流水线不间断，最好是 m = $\lceil T/r \rceil$
  * 如果 m < T/r，等到访问完一轮后，还要再等一段时间才能访问新一轮，因为第一个存储体恢复时间还没到
  * 如果 m > T/r，第一个存储体的恢复时间结束了，但CPU还没访问完一轮，导致存储体闲置

* 存取时间 ≠ **总线传输周期**，但都意味着CPU访问一次内存数据至少需要的时间，所以都可以用来计算存储体个数
* 使用低位交叉编址，给定**地址d**，需**判断属于哪一个存储体**，用 **d % m** 即可（低位交叉编址的定义是地址低位选择存储体）
* 低位交叉编址，最好使用**相同主频相同容量**的存储体
  * 不同主频：高频的存储体会降频
  * 不同容量：容量高的存储体，不超过的部分用低位交叉编址，超过的部分用单通道，导致性能不稳定

### 单体多字存储器

![image-20250308163510147](imgs\image-20250308163510147.png)

* 多体并行存储器，无论是高位交叉编址还是低位交叉编址，都是每次只能读一个存储单元的信息

  只是说**低位交叉编址读连续单元**时，**速度几近于 r**

* **单体多字存储器**，只有一个存储体，但每次读出的是**一行的存储单元**

  所以单体多字存储器在一个存取周期 T 里读取一次，能读出的是一行存储单元，所以**读写速度也是 r**

* 但多体并行存储器更灵活（单体多字存储器每次只能读出一行）

![image-20250307210704278](imgs\image-20250307210704278.png)

## 主存与CPU的连接

### 主存有单块存储器

![image-20250307213133235](imgs\image-20250307213133235.png)

* 芯片的引脚 = 片选线 + 读写线 + 地址线 + 数据线
  * 片选线，读写线 —— CPU通过**控制总线**发出
  * 地址线 —— CPU通过**地址总线**发出
  * 数据线 —— 通过**数据总线**传到CPU

* 存储芯片的大小 8k(存储空间) * 8(存储字长)
  * 扩大存储空间 —— 字扩展
  * 扩大存储字长 —— 位扩展，通过扩大存储字长的方式可以使字长小的存储体也不浪费数据总线宽度

<img src="imgs\image-20250307213757279.png" alt="image-20250307213757279" style="zoom:50%;" />

* 现在的计算机通常不把 MAR、MDR 放在主存，而是放在 cache 里

### 主存有多块存储器

#### 存储芯片的引脚表示

![image-20250307214112999](imgs\image-20250307214112999.png)

#### 位扩展

![image-20250307214405815](imgs\image-20250307214405815.png)

* 每个存储体都接受同样的地址线
* 每个存储体连接不同的数据线
* 实现位扩展（$8K*1 -> 8K*8$)

* 能够实现位扩展，是因为数据总线没有被完全利用

#### 字扩展

![image-20250307215309723](imgs\image-20250307215309723.png)

* 每个存储体连接同样的数据线、低位地址线
* 高位地址线通过译码器产生的片选信号，选择了不同的存储器
* 实现字扩展($8K*8 -> 32K*8$)
* 能够实现字扩展，是因为地址总线没有被完全利用
* 字扩展可能也不使用所有的地址线，考题中可能出现随机选择剩余的地址线产出片选信号 (如选择 13、15号地址线作为译码器输入)

<img src="imgs\image-20250307215719190.png" alt="image-20250307215719190" style="zoom:50%;" />

* 字扩展除了译码片选法，也有线选法（产生的选通信号数量少，而且地址不连续，所以不常用）

#### 字位扩展

![image-20250307220017434](imgs\image-20250307220017434.png)

* $16*4 -> 64*8$

#### 主存与CPU连接的总结

![image-20250307220223854](imgs\image-20250307220223854.png)

#### 译码器，时序图

![image-20250307220419304](imgs\image-20250307220419304.png)

* **译码器**和存储体配套使用（译码器的输出端是否连非门，取决于存储体的**CS信号是低电平有效还是高电平有效**）
* **译码器**可能有**使能信号**，类似于存储体的片选信号，只有使能信号满足要求译码器才有效
* 译码器的使能信号**可能不止一个**（以上示例是 74LS138译码器）
* 使能信号的作用是**控制片选信号的生效时间**（等待电流稳定）

![image-20250307221506775](imgs\image-20250307221506775.png)

* MREQ 是CPU发出的控制信号，是访问主存有效信号

  可以作为译码器的使能信号之一

  CPU先发出地址信号，等到地址信号稳定了之后，令MREQ有效，译码器才开始工作

  这样保证一定访问到了正确的地址

* 在时序图中，CPU首先发出地址信号

  一段时间后，地址信号稳定，激发使能信号，令片选信号有效

  一段时间后，数据总线开始输出数据

  一段时间后，由于数据已经开始输出，片选信号可以失效了

  一段时间后，CPU接收到了数据信号，就撤销地址信号

## 外存储器（机械硬盘）

### 磁表面存储器读写原理

![image-20250308160108535](imgs\image-20250308160108535.png)

* 每次只能读写 $1bit$ （写数据需要有一个并行转串行的电路，读数据需要一个串行转并行的电路）
* 读和写不能同时进行
* 优点：
  * 属于机械硬盘，便宜
  * 可重复读写
  * 非易失性
  * 非破坏性读出
* 缺点：
  * 慢（一次只能读写1bit，读写要分别串行转并行，并行转串行）
  * 工作环境要求高（磁性存储要求远离强磁场）

### 磁盘的组成

![image-20250308160630188](imgs\image-20250308160630188.png)

* **机械硬盘 = 磁盘驱动器（机械部分） + 磁盘控制器（电子部分）**

* **柱面数 = 磁道数**

* 硬盘以**扇面**作为读写的基本单位

* 一个磁盘有两个面可以存储数据，最上方和最下方的面不存数据

  假设有 n 个磁盘，则总共有 **2(n-1) 个磁头**

### 磁盘性能指标

![image-20250308161131796](imgs\image-20250308161131796.png)

* 非格式化容量 —— 物理意义上可以存储的容量

  格式化容量 —— 减去备份容量后实际上可以存储的容量

* 道密度 —— 磁道数/cm（给出磁盘直径和道密度，就可以求出有多少个道）

  位密度 —— bit/cm      （给出位密度和磁道周长，可以求出一个磁道可以存储的数据量。

  ​					每一个扇区存储的数据量都相同，所以每一个磁道的位密度都不同，越内侧的磁道位密度越大）

  面密度 —— 道密度 * 位密度

![image-20250308161712927](imgs\image-20250308161712927.png)

* **平均存取时间 = 寻道时间（磁头找磁道） + 旋转时间（扇区旋转到磁头上） + 传输时间（旋转到扇区结束）**

  旋转时间默认使用 旋转半周的时间（给出旋转的 角速度 就能求出）

  传输时间是读取完扇区的时间 （给出旋转的 角速度 + 扇区长度 可以求出）

  有时还需要计入 磁盘控制器接收到命令后的**处理延迟**

![image-20250308162146113](imgs\image-20250308162146113.png)

* 数据传输率 —— 单位时间内磁盘读写的数据量

### 磁盘寻址方式

* 给各个扇区编号

![image-20250308162458012](imgs\image-20250308162458012.png)

* 磁盘地址 = 驱动器号 + 柱面号 + 盘面号 + 扇区号

### 磁盘阵列 - 提高磁盘性能和可靠性

使用多个磁盘的方案：

![image-20250308162908805](imgs\image-20250308162908805.png)

* RAID0：相当于**位扩展**，访问速度更快（但没有备份数据，所以**无冗余也无校验**）
* RAID1：每份数据都存个**备份**，有冗余有校验，**存储空间减半**
* RAID2：**海明校验**，可以纠正1位错，发现2位错。需要的**备份磁盘比RAID1少一个**

* 之后的磁盘阵列的优化方向就是尽量 **提高稳定性**，同时**减少冗余**

![image-20250308164446931](imgs\image-20250308164446931.png)

## 固态硬盘SSD

![image-20250308164639482](imgs\image-20250308164639482.png)

* 机械硬盘 使用 **磁表面存储器** 存数据

  固态硬盘 使用 Flash Memory闪存**芯片** 存数据

![image-20250308165437286](imgs\image-20250308165437286.png)

* 固态硬盘以 **页** 为单位进行**读写**

  以 **块** 为单位进行**擦除**

* 使用固态硬盘存做外存，一个**逻辑地址对应的物理地址可能会发生改变**

  (如果只想修改块中的某一页，就复制其他页到另一个块，然后重新写入需要修改的页，然后擦除原来的块）

  固态硬盘**擦除**次数过多可能会**损坏**，因此引入**磨损均衡技术**

* 磨损均衡技术 —— 将“擦除”平均分布在每个块上

  * **动态磨损均衡** —— 每次写入时，总是**优先写入**到磨损少的块里（把**频繁更新的数据（热数据）**写进年轻块）
  * **静态磨损均衡** —— 定期检查磨损，把 读多写少的数据**移动**磨损较多的块 里（把**长期不变的数据（冷数据）**搬运到高磨损块）

![image-20250308172857851](imgs\image-20250308172857851.png)

* 机械硬盘 = **磁盘驱动器 + 磁盘控制器**

  固态硬盘 = **闪存翻译层 + 存储介质**（Flash Memory芯片）

* 机械硬盘以 **扇面** 为单位读写

  固态硬盘以 **页** 为单位读写（存储介质 = m 个芯片，芯片 = n 个块，块 = k 个页）

* 机械硬盘 不支持随机访问（通过**移动磁臂旋转磁盘**控制访问位置，平均访问时间 = [延迟 + ] 寻道时间 + 旋转时间 + 传输时间）

  固态硬盘 支持**随机访问**，通过**电路**定位物理地址

* 机械硬盘 不会因为读写次数过多失效

  固态硬盘 擦除次数过多时会**失效**

## Cache

### cache能有效工作的理论依据

![image-20250308173553326](imgs\image-20250308173553326.png)

* 局部性原理
  * 空间局部性 —— 指令和数据是顺序存储的
  * 时间局部性 —— 循环指令

* 二维数据按行存储，所以**按行读写**的空间局部性比**按列**更好，所以可能更快

### 使用 cache 之后的平均访问时间

![image-20250308173829202](imgs\image-20250308173829202.png)

* 使用 cache 之前 —— CPU直接访问内存，$t = t_m$
* 使用 cache 之后
  * CPU先访问 cache，再访问内存，$t = Ht_c + (1-H)(t_c + t_m)$
  * CPU同时访问 cache 和 内存，$t = Ht_c + (1-H)t_m$

![image-20250308174344724](imgs\image-20250308174344724.png)

### 问题1：怎么划分“局部性”里的”局部“（块）

![image-20250308174554090](imgs\image-20250308174554090.png)

* cache - 主存 之间以**块**为单位交换数据（实现局部性原理）

* **cache行 = cache块** 

  **主存块 = 主存页**

* **主存的数据地址 = 块号 + 块内地址**

  cache数据地址 = 块号 + 块内地址

  两者的块内地址长度相等（cache块、主存块的大小相等），主存的块号长度比cache长（主存块数量比cache块多）

* 如果访问在cache**未命中**，一定会在访问完主存后把对应块**调入cache**

![image-20250308175359448](imgs\image-20250308175359448.png)

### 问题2：cache的块号 和 主存的块号是怎么对应的（三种映射关系）

![image-20250308175759413](imgs\image-20250308175759413.png)

* cache 根据 **标记（主存块号） + 有效位（块号是否有效）** 记录主存块在主存的位置

* 三种cache-主存的映射方式 —— 全相联映射、直接映射、组相联映射


#### 1. 全相联映射

![image-20250308180411513](imgs\image-20250308180411513.png)

* 全相联映射 —— 主存的某个块都可以放到cache的**任意**一个块中
  * cache的每个块都需要记录  **有效位 + 标记 + 块本身** 
    * 有效位的长度 = 1bit
    * **标记的长度 = 主存块号长度**
    * 块的长度 = 块内地址长度

  * 查询映射时，逐个检查每一行cache的**有效位和标记**，命中后查该行对应的块


#### 2. 直接映射

![image-20250308181003776](imgs\image-20250308181003776.png)

* 直接映射 —— **每个主存块** 只能放在 **行号 = 主存块号 % cache总块号** 的 cache行上

  * 例如cache有8个行，则主存块号为8n的只能放在第0行，块号为8n+1的只能放在第1行，块号为8n+2的只能放在第2行......

  * cache的每个块都需要记录  **有效位 + 标记 + 块本身** 
    * 有效位的长度 = 1bit
    * **标记的长度 = 主存块号长度 - cache块号长度**
    * 块的长度 = 块内地址长度
  * 查询映射：根据映射规则**找到cache行号**，然后查该行的**有效位和标记**，命中后查该行对应的块

#### 3. 组相联映射

![image-20250308211522070](imgs\image-20250308211522070.png)

* **n 路组相联映射** —— 一组里有 n 个 cache 行，**每个主存块** 只能放在 **组号 = 主存块号 % 总组数** 的组里

  * 例如cache有2个组，则主存块号为2n的只能放在第0组，块号为2n+1的只能放在第1组

    组相联映射只固定组，放在组内哪个位置不做要求

  * cache的每个块都需要记录  **有效位 + 标记 + 块本身** 

  * * 有效位的长度 = 1bit
    * **标记的长度 = 主存块号长度 - 组号长度**
    * 块的长度 = 块内地址长度
  * 查询映射：根据映射规则**找到cache组号**，逐个检查该组中每一行cache的**有效位和标记**，命中后查该行对应的块

![image-20250308211923297](imgs\image-20250308211923297.png)

### 问题3：cache满（四种替换算法）

![image-20250308212040171](imgs\image-20250308212040171.png)

* 一个主存块需要被存入cache时，如果该主存块可存入的位置满了，就从该块的可存入位置中挑选出一个进行替换
  * 对于全相联映射，一个块可存入cache的所有行；
  * 对于直接映射，一个块仅可存入某个确定的cache行；（没得选，只能直接替换该行）
  * 对于组相联映射，一个块可存入某个确定的组内的所有cache行


#### 1. 随机算法（RAND）

![image-20250308212302098](imgs\image-20250308212302098.png)

* cache满之后，每次随机选取一个行进行替换
* 完全没有考虑局部性原理，效果不稳定

#### 2. 先进先出算法（FIFO）

![image-20250308212638004](imgs\image-20250308212638004.png)

* 依然没有考虑局部性原理
* 可能会导致**抖动**（一些块被频繁换入换出）

#### 3. 近期最少使用算法（LRU）

![image-20250308213616844](imgs\image-20250308213616844.png)

* 手算：从当前位置**向前看 $2^n-1$**(n是cache行位数) 位，就能发现当前的**最旧行**

* 机算：一行cache = 有效位(1) + 标记 + 块 + **计数器**

  * 命中：**当前行**计数器的值**清零**，计数器的值比当前行**更小**的非空闲行计数器值**+1**
  * 未命中，有空闲行：加入到空闲行，当前的非空闲行计数器**+1**
  * 未命中，无空闲行：**替换计数器值最大**的cache行，改行计数器值**清零**，其余非空闲行**+1**

  机算使用复杂的计数方式，优势是所有的计数值里最大的也是 $2^n - 1$，即**计数器的位数可以固定为 n**

![image-20250308214349367](imgs\image-20250308214349367.png)

* 每次淘汰最旧行，**遵循**了时间局部性原理（Cache**命中率最高**）
* 如果频繁访问的主存块数 > cache总行数，依然会发生**抖动**

#### 4. 最不经常使用算法（LFU）

![image-20250308214653614](imgs\image-20250308214653614.png)

* 一行cache = 有效位(1) + 标记 + 块 + **计数器**

  * **第一次**访问时调入**不计入**计数

  * 之后每次访问命中，计数器+1

  * 如果访问没有命中，**替换计数器值最小**的，计数器值清零

    计数器值最小的可能有多个，这时的替换方案可以是 行号递增，也可以是FIFO

* **不一定有效**，根据时间局部性原理，因为以前的访问次数多，不代表以后就一定频繁访问

![image-20250308215155532](imgs\image-20250308215155532.png)

### 问题4：cache-主存数据一致性（cache写策略）

<img src="imgs\image-20250308215947952.png" alt="image-20250308215947952" style="zoom:50%;" />

![image-20250308221706199](imgs\image-20250308221706199.png)

* 写命中 —— 写入的块正好在 cache 里

  * **写回法** —— cache行增加一个**脏位**，cache块被替换时，如果脏位=1（说明被修改过）**需要写回**主存，否则不需要写回

    ​		减少访存次数，但有数据不一致的隐患

  * **全写法（写直通法）** —— **每次**修改cache块，也修改对应的主存块

    ​		访存次数增加，速度变慢，但更能保证数据一致性

    ​		改进 —— **写缓存**

![image-20250308221950032](imgs\image-20250308221950032.png)

* 写不命中 —— 写入的块不在 cache
  * **写分配法** —— 主存块**调入**cache + 写回法
  * **非写分配法** —— **直接写到主存**，不需要调入cache（意味着**只有读不命中时才调入内存块**）

![image-20250308222352108](imgs\image-20250308222352108.png)

## 虚拟存储系统

### 页式存储器

* cache —— 主存块<->cache块

  虚拟存储 —— 主存块<->逻辑块

* 大型程序被分页，**1页 = 1内存块**（是逻辑概念，1内存块 = 1cache块是物理概念）

* 程序中指明的数据地址是逻辑地址， 逻辑地址 = 逻辑页号 + 页内地址

* **逻辑页号和物理页号的映射关系**在页表里，**页表在主存**里

* 为了加快逻辑地址的映射，根据局部性原理，把 **页表(慢表)** 部分内容调入 **快表(TLB)**

  快表使用SRAM存储，是相联存储器(根据内容确定存储位置)，查询速度更快，但更小

* TLB和cache不同

  * **TLB**的作用是更快的把**逻辑地址映射到物理地址**
  * **cache**的作用是已知物理地址更快速的**查询块内容**

![image-20250308224503485](imgs\image-20250308224503485.png)

| 序号 | TLB  | Page | Cache | 访存次数 | 访磁次数 |                 说明                 |
| :--: | :--: | :--: | :---: | :------: | :------: | :----------------------------------: |
|  1   | 命中 | 命中 | 命中  |    0     |    0     |   TLB命中则Page一定命中，Cache未知   |
|  2   | 命中 | 命中 | 缺失  |    1     |    0     |   TLB命中则Page一定命中，Cache未知   |
|  3   | 缺失 | 命中 | 命中  |    1     |    0     |   TLB缺失而Page可能命中，Cache未知   |
|  4   | 缺失 | 命中 | 缺失  |    2     |    0     |   TLB缺失而Page可能命中，Cache未知   |
|  5   | 缺失 | 缺失 | 缺失  |    2+    |    1+    | TLB缺失而Page也缺失，则Cache一定缺失 |

### 虚拟存储器

![image-20250308225641017](imgs\image-20250308225641017.png)

* cache实现主存提速，辅存实现主存虚拟扩容

![image-20250308230827244](imgs\image-20250308230827244.png)

* 辅存 - 主存同样需要解决的四个问题：
  * 如何实现局部性 —— 辅存分页，**1辅存页 = 1主存块**
  * 映射关系 —— 页表，需要有 **有效位，逻辑页号，辅存页号，主存块号**（页表记录映射关系而不是内容，所以不用记块内地址）
  * 替换算法 —— **访问位**（计数器）
  * 写策略 —— **脏位**

![image-20250308231000690](imgs\image-20250308231000690.png)

* 计组关注 cache - 主存
* OS 关注 主存 - 辅存
