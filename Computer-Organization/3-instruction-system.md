# 指令系统

* 主机 = CPU（运算器 + 控制器） + 存储器
* **控制器的作用：1. 分析指令 2. 发布控制命令**
* 指令系统 —— 解析控制器**分析指令**的原理

![image-20250310180038550](imgs\image-20250310180038550.png)

* 一台计算机上支持的**所有机器指令** = **指令集** = **指令系统**（不同计算机的指令系统可能不同）

## 指令分类

### 1. 按地址码数目

![image-20250310180228389](imgs\image-20250310180228389.png)

* (机器)指令 = 操作码(动作) + 地址码(动作对象)
* 不同指令具有 **地址码 的数量**可能**不同**

#### 零地址指令

![image-20250310180508374](imgs\image-20250310180508374.png)

* 零地址指令的两种情况
  * 真的没有地址码（空操作，停机，关中断）
  * 地址码隐含（后缀表达式，两个操作数隐含在栈顶和次栈顶）

#### 一地址指令

![image-20250310180813905](imgs\image-20250310180813905.png)

* 一地址指令的两种情况
  * 对自身进行操作（访存次数 = 取指 + 取操作数 + 写回 = 3次）
  * 双操作数，另一个操作数的位置隐含（访存次数 = 取指 + 取操作数 = 2次）

#### 二、三地址指令

![image-20250310181129604](imgs\image-20250310181129604.png)

* 二地址指令 —— 访存次数 = 取指 + 取操作数1 + 取操作数2 + 写操作数1 = 4次
* 三地址指令 —— 访存次数 = 取指 + 取操作数1 + 取操作数2 + 写操作数3 = 4次

* 两者的区别仅在于**写入的位置不同**

#### 四地址指令

![image-20250310181435464](imgs\image-20250310181435464.png)

* 访存次数 = 取指 + 读操作数1 + 读操作数2 + 写操作数3 = 4次
* **第四个操作数** 是下一条将要执行**指令的地址**（跳跃执行指令）
* 指令 = 操作码 + 地址码 
  * 指令总长度固定，地址码的个数越多，每个地址码可以表示的地址空间越小（位数小）

### 2.  定长、变长指令字结构（指令长度）

* 根据指令系统中 指令长度是否固定，分为 定长指令字结构、变长指令字结构 两类

![image-20250310181905737](imgs\image-20250310181905737.png)

* 按照指令长度，分为 **半字长指令，单字长指令，双字长指令**

* **机器字长** —— ALU能支持的运算数的比特长度，叫做机器字长

* **存储字长** —— 存储器中一个存储单元包含的存储元的数量，和MDR相关

* **指令字长** —— 一条机器指令的长度

  ​			机器字长、存储字长都是唯一的，指令字长可能是不唯一的（**变长指令字结构**）

### 3.  定长、可变长操作码（操作码长度）

* 按照指令系统中所有指令 操作码长度是否固定，分为 定长操作码、可变长操作码 两类

![image-20250310182418525](imgs\image-20250310182418525.png)

* 定长指令字结构、变长指令字结构 —— **指令字长**是否是唯一的
* 定长操作码、可变长操作码 —— **操作码的位数**是否是唯一的

### 4. 按操作类型分类

![image-20250310182703402](imgs\image-20250310182703402.png)

* 数据传送
* 算术逻辑运算、移位
* 程序控制
* IO

![image-20250310183652048](imgs\image-20250310183652048.png)

## 扩展操作码指令

![image-20250310183755097](imgs\image-20250310183755097.png)

* **扩展操作码指令 = 定长指令字结构 + 可变长操作码**
* 指令字长固定，操作码长度不固定

![image-20250310184240214](imgs\image-20250310184240214.png)

* 操作码不能重复（不能有指令的操作码是其他指令操作码的**前缀**（类似哈夫曼编码）
* 对于**使用频率更高**的指令，尽量分配使**操作码更短**（分析指令会更快）

![image-20250310185402629](imgs\image-20250310185402629.png)

* 假设 指令字长 16 bit，每个地址码长度占 4 bit

* 对于 三地址指令，操作码留有 4 bit，可以用来表示 $2^4 = 16$ 种三地址指令

* 但是这 16 个**操作码位置不能全部使用**，否则占尽了 二、一、零地址指令的操作码

  * 题设需要 15种三地址指令，12种二地址指令，62种一地址指令，32种零地址指令

  * 则 三地址指令 的指令表示范围是 —— 0000 (00..00) - 1110 (11..11)

    下层的地址一定是固定的 1111 前缀，即给二地址指令留了 $2 ^ 4 - 1$ 个空余位置

  * 二地址指令 的指令表示范围是 —— 1111 0000 (00..00) - 1111 1011 (11..11)

    下层的地址一定 1111 11 前缀，即给一地址指令留了 $2^6 - 1$ 个空余位置

  * 一地址指令 的指令表示范围是 —— 1111 1100 0000 (0000) - 1111 1111 1101 (1111)

    下层的地址一定 1111 1111 111 前缀，即给零地址指令留了 $2^5$ 个空余位置

    （**零地址不用考虑再给其它指令留前缀**，所以不用-1个空余位置）

![image-20250310191427262](imgs\image-20250310191427262.png)

* 扩展操作码（定长指令字结构，可变长操作码）可以增加指令数量，但实现复杂
* 定长操作码 实现简单，但指令数量少

## 指令寻址

### 顺序寻址

![image-20250311134731241](imgs\image-20250311134731241.png)

* **定长指令字结构，以字编址（(PC)+1 -> PC）**

![image-20250311135127936](imgs\image-20250311135127936.png)

* **定长指令字结构，以字节编址，并且1word = 2B（(PC)+2 -> PC）**

![image-20250311135359417](imgs\image-20250311135359417.png)

* 变长指令字结构，以字节编址

  先读入一个字，分析操作码，然后根据操作码确定该指令有多少个字，从而读入整条指令

* **取指操作可能访存不止一次**

### 跳跃寻址

![image-20250311135838886](imgs\image-20250311135838886.png)

* 顺序寻址 —— (PC) + "1" -> PC，这里的1指的是指令字长，不是客观1
* 跳跃寻址 —— 每次取指后，(PC) + "1" -> PC，然后分析指令发现是跳跃指令，在继续改变PC的值

![image-20250311140216723](imgs\image-20250311140216723.png)

## 数据寻址

![image-20250311140724301](imgs\image-20250311140724301.png)

* 指令寻址 是 指定**下一条指令**的位置

* 数据寻址 是 根据**地址码** 给出的 **形式地址(A)** 的值获取 **有效地址(EA)**

  地址码的解读方式有很多种 ，如 JMP 7 

  * 可能是表示跳到 物理地址为7的存储单元

  * 可能是表示跳到 相对于程序起始行的偏移地址为7的存储单元

  * 可能是表示跳到 相对于PC的偏移地址为7的存储单元

###  A -> EA

<img src="imgs\image-20250311141537543.png" alt="image-20250311141537543" style="zoom:50%;" />

* 一共十种寻址方式
* 把所有寻址方式编号，**寻址方式编号 + 形式地址(A) = 地址码**，由此得到有效地址(EA)

### 直接寻址 (EA = A 访存=2)

![image-20250311141927352](imgs\image-20250311141927352.png)

* EA = A，即形式地址就是有效地址
* 访存 = 取指 + 访问EA = 2次
* 缺：1. 地址码位数限制了直接寻址可表示的地址范围 2. 写死的地址不易修改

### 间接寻址 (EA = (A) 访存≥3)

![image-20250311142329144](imgs\image-20250311142329144.png)

* EA = (A)，即形式地址指向的地址里存放的内容是有效地址
* 扩大了寻址范围
* 增加了访存次数（访存 = 取指 + 取形式地址的内容(获得EA) + 取有效地址的内容(获得真正的操作数) = 3次）
* 间接寻址可能不止间接一层（这种方式对于层层调用函数很方便）

### 寄存器寻址 (EA = $R_i$ 访存=1)

![image-20250311142921685](imgs\image-20250311142921685.png)

* EA = A表示的寄存器中的内容 = $R_i$，形式地址是某个寄存器的编号
* 优点：
  * 访存 = 取指 = 1次，分析指令发现所需数据就在编号所指的寄存器里，直接在寄存器取数据，不需要再访存
  * 快，寄存器数量很少，所以编号短，地址码占位小，分析指令快
* 缺点：
  * 寄存器少，所以存储空间有限

### 寄存器间接寻址 (EA = ($R_i$) 访存=2)

![image-20250311143510149](imgs\image-20250311143510149.png)

* EA = $(R_i)$ 
* 一般的间接寻址，间接地址在主存，寄存器间接寻址，间接地址在寄存器，所以减少了访存次数
  * 访存 = 取指 + 取寄存器指向的地址 = 2次

### 隐含寻址(EA隐含)

![image-20250311143712488](imgs\image-20250311143712488.png)

* EA默认在某个寄存器里（例如乘法指令，被乘数默认已经放在ACC里了）

### 立即寻址 (没有EA 访存=1)

![image-20250311144027287](imgs\image-20250311144027287.png)

* 没有EA，**形式地址的位置直接就放 操作数**（补码表示）
* 一般**立即寻址的寻址编号是#**
* 访存 = 取指 = 1次，操作数本身就在指令中，不需要再访问主存或寄存器
* 有效地址A 的**位数限制**了 立即寻址能表示的操作数**范围**

![image-20250311144358022](imgs\image-20250311144358022.png)

### 偏移寻址 (基址、变址、相对)

<img src="imgs\image-20250311150008869.png" alt="image-20250311150008869" style="zoom:50%;" />

* 基址寻址、变址寻址、相对寻址 都是**偏移寻址**
* 它们的**形式地址**都表示**偏移量**，它们的不同之处就在于 **偏移起点不同**

#### 基址寻址 (EA = (BR) + A 访存=2)

![image-20250311145919965](imgs\image-20250311145919965.png)

* EA = (BR) + A，**基址寄存器 BR 存偏移起址**，形式地址 A 存偏移量

* 访存 = 取指 + 访问EA = 2次

* 默认基址在 BR 里

  地址码 = **寻址编号 + 形式地址**

* 如果计算机没有 BR 这个寄存器，就人为指定哪个寄存器里存放了基址

  地址码 = **寻址编号 + 指定寄存器编号 +  形式地址**

![image-20250311151010950](imgs\image-20250311151010950.png)

* **基址寻址**令 BR 指向当前**程序起始行**的位置，有助于实现**多道程序并发**

* 程序的并发是操作系统完成的，**BR是面向OS的一个寄存器，无法修改**

  如果没有BR，需要指定基址寄存器，程序员的工作也**只是指定**哪一个寄存器当基址寄存器，它内部还是**不能修改**

#### 变址寻址 (EA = (IX) + A 访存=2)

![image-20250311151601158](imgs\image-20250311151601158.png)

* EA = (IX) + A，**变址寄存器 IX 存偏移量**，形式地址 A 存偏移起址
* 访存 = 取指 + 访问EA = 2次
* 变址寻址 和 基址寻址的不同：
  * BR 存偏移起址，IX 存偏移量
  * BR是面向OS，程序员不能修改；**IX是面向用户，可以修改**
* 同样，如果没有变址寄存器 IX，可以**人为指定**一个通用寄存器**充当**变址寄存器

![image-20250311152531940](imgs\image-20250311152531940.png)

* 变址寻址可以用来实现**对连续地址的元素访问**（比如数组）

##### 基址变址寻址 (EA = (IX) + ((BR) + A) 访存=2)

* 基址寻址的作用：允许多段程序并发
* 变址寻址的作用：访问连续的数组元素
* 基址变址寻址的作用；在多段程序并发的情况下，访问连续的数组元素

#### 相对寻址 (EA = (PC)  + A 访存=2)

![image-20250311190934288](imgs\image-20250311190934288.png)

* EA = (PC) + A，程序计数器 PC （存**下一条要执行的指令地址**的寄存器）存偏移起址，形式地址 A 存偏移量
* 访存 = 取指 + 访问EA所在主存
* 形式地址 A 用**补码**表示，可正可负
* 使用相对寻址，可以**方便一段代码在程序内浮动**

![image-20250311191153330](imgs\image-20250311191153330.png)

### 硬件实现比较

![image-20250311201511672](imgs\image-20250311201511672.png)

* 每次ALU运算后会把产生的状态字存放到状态字寄存器/标志寄存器PSW中
* 如果是比较大小，就查看 SF、ZF 的状态，比较结果有 JR、JE、JMP 等

### 堆栈寻址(EA = (SP) 访存=1/2)

![image-20250311202021118](imgs\image-20250311202021118.png)

* 栈顶指针 SP ，总是指向栈顶元素

* POP，PUSH 操作，都是对 SP 指向的栈顶元素进行的

* 可能会遇到 栈底在高地址(POP: 取值, SP+1；PUSH: SP-1, 写值)

  ​		     栈底在低地址(POP: 取值, SP-1；PUSH: SP+1, 写值)

![image-20250311210050635](imgs\image-20250311210050635.png)

* 堆可能使用**寄存器**存储（**硬堆栈**），访存 = 取指 = 1

  也可能使用**主存划分的某片区域**存储（**软堆栈**），访存 = 取指 + 访问软堆栈 = 2

* 堆栈用于**函数调用**时，保存当前函数的相关信息

## X86汇编语言

指英特尔公司以86作为结尾的芯片，它们都支持8086的指令系统

指令系统 是一个计算机支持的所有机器指令，一条机器指令对应一条汇编指令

### 三种数据来源

![image-20250311215200899](imgs\image-20250311215200899.png)

* **指令 = 操作码 + 地址码**

* 操作码指明了需要进行**什么操作**，地址码指明了**操作数据**

* 指令寻址

  * 顺序寻址 —— (PC) + "1" -> PC

  * 跳跃寻址 —— JMP等指令直接修改PC的值

* 数据寻址

  * 隐含寻址、立即寻址、直接寻址、间接寻址、寄存器寻址、寄存器间接寻址
  * (偏移寻址) 基址寻址(BR)、变址寻址(IX)、相对寻址(PC)
  * 堆栈寻址

* 十种数据寻址方式，三种**数据来源**：**寄存器、主存、指令本身**

* 问题1：8086有哪些寄存器

* 问题2：访问主存数据 —— 需要**1. 数据起始地址 2. 数据长度**

* 问题3：数据在指令本身 —— 立即寻址

#### 数据来源的表现形式

![image-20250311220321987](imgs\image-20250311220321987.png)

* s 表示源操作数，d 表示目的操作数

* 寄存器 —— 直接写寄存器名字，例如 mov eax, ebx

* 主存 —— 例如 mov eax, dword ptr [af996h] 

  * 前缀写明数据长度，有三种数据长度 

    dword ptr	双字，在X86系统中，双字是 32bit

    word ptr	   单字，**在X86系统中，字是 16bit**

    byte ptr	    字节，字节是 8bit

  * **地址用 16进制表示**(所以后缀是 h)，用中括号扩起 

* 立即数 —— 直接写数，例如 mov eax, 5

### 8086的寄存器

![image-20250311230154750](imgs\image-20250311230154750.png)

* 通用寄存器：EAX、EBX、ECX、EDX
* 变址寄存器：ESI、EDI
* 堆栈寄存器：EBP、ESP， ebp 和 esp 里的内容是**可以修改**的
* 8086的这些寄存器长度都是 32bit

![image-20250311230308184](imgs\image-20250311230308184.png)

![image-20250311230352141](imgs\image-20250311230352141.png)

* 其中，四个通用寄存器可以进行划分，把 **后16bit** 拆出来叫 **AX、BX、CX、DX** 然后使用
* 甚至 **后16bit** 再划分成 **两个8bit**，叫 **AH、AL、BH、BL、CH、CL、DH、DL** 然后使用

![image-20250311230600704](imgs\image-20250311230600704.png)

* dword ptr [ebx] 	寄存器间接寻址
* mov d, s            	  s是源地址，d是目的地址
* mov  eax, byte ptr [ebx] 指定数据长度
* mov eax, [ebx] 	 如果没有指定长度，目的地址、源地址其中之一是寄存器，默认数据长度就是寄存器长度
* mov eax, [ebx+8]      访问主存地址时可以对地址进行加减法

![image-20250311231436392](imgs\image-20250311231436392.png)

### 8086指令集的常用操作

![image-20250311231715014](imgs\image-20250311231715014.png)

* 常用算术运算指令、逻辑运算指令

#### 算术运算指令

![image-20250311232059154](imgs\image-20250311232059154.png)

* s 指源操作数，d 指目的操作数

  操作数的三种来源：寄存器、主存、立即数(h)

  假设 add d, s，是 d + s -> d，也就是说 运算结果 存在 原目的操作数 所在位置

  所以，**目的操作数不允许是 立即数**

* X86 也 **不允许两个操作数都来自主存**（防止一条指令访问太多次主存）

* imul，idiv，这里的 **i** 指的是 integer（有符号整数），这时**有符号整数的乘除法**

  mul，div，是无符号整数的乘除法

* **div、idiv，只有一个操作数**

  这个操作数是除数

  **被除数默认已经放在了 edx:eax** 里（假设除数是32bit，被除数需要是64bit）

  除法的**余数**放在 edx 里，**商**放在 eax 里

#### 逻辑运算指令

![image-20250311233230081](imgs\image-20250311233230081.png)

* d 同样不允许是立即数
* shl/shr 里的 s 指的是**逻辑左移/右移**的位数，通常是常数

#### 其他指令

![image-20250311233433386](imgs\image-20250311233433386.png)

* 在X86系统中，push 和 pop 操作默认都是 4字节

### AT&T格式 VS Intel格式

![image-20250311234903764](imgs\image-20250311234903764.png)

* **AT&T**格式 **目的操作数在右边**

* AT&T格式 寄存器寻址，**寄存器名字前有 %**

* AT&T格式 立即寻址，**立即数前有$**

* AT&T格式 数据在主存，**主存地址用()**而不是[]

* AT&T格式 数据的**读写长度**，**在操作码里体现**而不是前缀dword ptr之类的

  例如 mov ebx, dword ptr [eax] -> movl %ebx, (%eax)

  * **dword** ptr -> mov**l**
  * **word** ptr -> mov**w**
  * **byte** ptr -> mov**b**

* AT&T格式 主存地址偏移量，**偏移量前缀表示**

  例如 [ebx-8] -> -8(%ebx)

  如果是 基址 + 变址* 比例因子 + 偏移量，**偏移量(基址, 变址, 比例因子)**

  例如 [ebx + ecx*32 + 4] -> 4(%ebx, $ecx, 32)

![image-20250311235249988](imgs\image-20250311235249988.png)

* **基址 + 变址* 比例因子 + 偏移量**，获取**结构数组**中**某个结构体的某个参数**

### 选择语句机器级表示

![image-20250312113700531](imgs\image-20250312113700531.png)

* 在X86系统中，**程序计数器** PC 也叫做 **IP**寄存器
* **IP寄存器**默认根据顺序执行的方式，指向**下一条即将执行的代码**
* 无条件转移指令 **jmp**，接受四种操作数来源 —— **常数、寄存器、主存、标号**

![image-20250312114019425](imgs\image-20250312114019425.png)

#### 条件转移指令

![image-20250312114348717](imgs\image-20250312114348717.png)

应用：

![image-20250312114753323](imgs\image-20250312114753323.png)

* 条件转移指令经常搭配 cmp 使用
* 如果想先 if 后 else，就使用 jle (jg的否命题)

![image-20250312115313938](imgs\image-20250312115313938.png)

* 汇编语言经常用函数名做标记

### 循环语句机器级表示

#### 用条件转移指令实现循环

![image-20250312173153273](imgs\image-20250312173153273.png)

#### 用loop指令实现循环

![image-20250312173617914](imgs\image-20250312173617914.png)

* 能用 loop 指令实现的，一定也能用 cmp + 条件转移指令 实现

* **loop** 指令默认的**循环计数器**是 **ecx寄存器**

* 循环每次默认 ecx的值-1，循环结束的条件是 (ecx) = 0

* loopx 指令，指的是还有其他的循环结束条件

  例如 loopnz ，意思是当 (ecx != 0) && (运算结果 != 0) 时循环继续进行

  这些 loopx 指令的作用可以现场做题根据上下文倒推

### 函数调用的机器级表示

![image-20250312174217414](imgs\image-20250312174217414.png)

* 每次**函数被调用**，此函数的**栈帧**信息就会**存入内存里的函数调用栈**
* **栈帧** = 上一层函数基址 [+ 局部变量] [+ 空余] [+ 重要寄存器值] [+ 传递给下一层的参数] + IP旧值

以 caller() 、add() 函数为例，汇编语言代码：

![image-20250312174519491](imgs\image-20250312174519491.png)

* 汇编语言需要**给每个函数添加标记**

* 使用 `call <标记>` 调用函数

  使用 `ret` 返回

#### 调用和返回时 IP寄存器 的动作

![image-20250312174827642](imgs\image-20250312174827642.png)

* `call <标记>` 时，IP 寄存器的旧值 **压栈保存**，IP 寄存器**指向新值**(被调用函数的起始地址)
* `ret` 时，IP寄存器的旧值 **弹出栈顶**，IP 寄存器**恢复旧值**

#### 访问栈帧 (push、pop、mov)

![image-20250312180955475](imgs\image-20250312180955475.png)

* 函数调用栈的**栈底在高地址，栈顶在低地址**

![image-20250312201006443](imgs\image-20250312201006443.png)

* CPU 内部只有一个 ebp，一个esp

* **ebp**(栈底指针) 、**esp**(栈顶指针) 分别指向**当前正在运行函数栈帧**的栈底、栈顶

![image-20250312201317413](imgs\image-20250312201317413.png)

![image-20250312201429923](imgs\image-20250312201429923.png)

* 访问栈帧数据

  1. 使用 进行 push、pop 操作读写栈顶元素（默认的操作位数是 4字节）

  2. 直接使用 mov 指令获取到栈帧任意位置的值

     esp、ebp 的数据可以进行修改

#### 切换栈帧(enter、leave)

发生**函数调用**和**返回**时，都需**切换**当前栈帧

##### 函数调用

![image-20250312202025806](imgs\image-20250312202025806.png)

* 函数调用，`call <标记>`，这个指令会令IP寄存器**旧值压入栈顶**，再把**新值赋值给IP**寄存器

  所以，**调用者函数**的操作 **push IP旧值** 入栈

* **被调用者函数**需要**切换栈帧**

  1. `push ebp`，**记录**上一个**栈底**指针
  2. `mov ebp, esp`，**调整栈顶**指针指向当前栈帧的栈顶元素

* 每个函数被调用时，首先都要执行这两条指令

  这意味着**每个栈帧的栈底，存的都是上层函数的基址**

* 这两条指令 等价于 `enter`

##### 函数返回

![image-20250312203101584](imgs\image-20250312203101584.png)

* **被调用者函数**需要**切换栈帧**

  1. `mov esp, ebp`，调整栈顶元素指向 **上一个栈帧的栈顶+4** 的位置

  2. `pop ebp`，栈顶指针-4，此时栈顶指针指向上一个栈帧栈顶

     ​		同时，因为栈顶存的是上一层函数的基址，所以此时ebp指向上一个栈帧的栈底

* 每个函数返回时，最后都要执行这两条指令

  这两条指令 等价于 `leave`

* 函数返回，`ret`，这个指令会**从栈顶获取IP旧值，恢复IP**

  所以，**被调用者函数**的操作 **pop IP旧值** 出栈

![image-20250312203941781](imgs\image-20250312203941781.png)

* 除了main函数，其他函数的代码构成都是

  标记 —— enter —— 函数内容 —— leave —— ret

* ret 之后，IP指向**被调用函数的下一条指令**

  在IP旧值被压入栈之前，就自动 (IP) + "1" -> IP 了

* 不管是切换到新栈帧，还是返回到旧栈帧，都是被调用函数做的

#### 栈帧内容，传参、传返回值

![image-20250313141510674](imgs\image-20250313141510674.png)

* 每个栈帧的**栈底**总是**存**储**上一层**调用函数的 **栈底位置**（每个函数的第一句必定是 `enter`）

  每个栈帧的**栈顶**总是**IP旧值**（调用函数结束后，返回的位置）

* gcc编译器规定，每个**栈帧长度**必须是 **16B的整数倍**（每个字是4B），所以**栈帧会有空闲位置**

  但**当前栈帧**的长度**不受这个限制**

* 函数定义的**局部变量**都会存储在**靠近栈底位置**，而且越**先定义的局部变量**，越**靠近栈顶**

  访问 倒数第一个局部变量 —— [ebp - 4]

  访问 倒数第二个局部变量 —— [ebp - 8]

* 函数要**传递**给下一层函数的**参数**都会存储在**靠近栈顶位置**，而且越**先传递的参数**，越**靠近栈顶**

![image-20250313143802108](imgs\image-20250313143802108.png)

* 假设函数传参有两个参数，调用者函数：

  * 先写入 第二个给下一层函数传递的参数 —— [esp + 4]

  * 再写入 第一个给下一层函数传递的参数 —— [esp]

  * 调用 `call <标记>` 函数会令 IP旧值 入栈，esp+=4，所以栈顶一定存的是 IP旧值

* 假设函数传参有两个参数，被调用者函数：

  * 首先执行 `enter` 指令，ebp = esp = 上一个栈帧的 esp + 4

  * 访问 第一个上层函数传递的参数 —— [ebp + 8]

  * 访问 第二个上层函数传递的参数 —— [ebp + 12]

* **mov 指令不支持 两个操作数都来自内存**

  所以如果想把某个内存的内容，复制到另一块内存地址，**需要用寄存器做中转**，也就是说要两条指令

  例如，caller函数定义了两个局部变量 temp1，temp2，想作为参数传递给下一层函数 add函数

  ~~~
  mov eax, [ebp-8]
  mov [esp+4], eax	// 移动了temp2
  
  mov eax, [ebp-12]
  mov [esp], eax		// 移动了temp1
  ~~~

* 函数只有一个返回值，一般函数的**返回值**存放在 **eax 寄存器**中，调用者函数只需要从 eax 寄存器拿数据，就实现了返回值的传递

![image-20250313145001983](imgs\image-20250313145001983.png)

* 调用的函数可能会 **修改寄存器的内容**

  所以调用者函数在调用之前，如果有需要，**传参之前**要把重要的**寄存器值压栈**保存

  **函数返回之后恢复寄存器的值**

#### 函数调用机器级代码的总结

![image-20250313145902869](imgs\image-20250313145902869.png)

## CISC 和 RISC

![image-20250313151240626](imgs\image-20250313151240626.png)

* CISC 相当于 C语言 + 库函数

  RISC 相当于 C语言

* CISC：80%的代码使用频率不到20%

* **CISC 也不是所有指令都是硬件实现**的，有些指令是内部自己根据自己的简单指令实现的（存储程序）

  RISC 是一条指令一个电路

* CISC 对指令访存不限制，RISC规定只有 Load/Store 指令可以访存

  例如之前的 mul 指令直接从内存取出数据和寄存器的值相乘，显然这时CISC，因为 mul 指令访存了

* 访存限制也导致 **RISC 必须拥有足够的寄存器**，因为只有 Load/Store 可以访存，访存后需要把数据存在寄存器里，然后两个寄存器的数据进行运算，而不能像 CISC 一样直接从内存取数据和寄存器数据进行运算

* CISC 因为有“库函数”，一条指令的执行时间是不可预估的

  **RISC** 因为都是最简单的指令，所以**基本上指令执行都能在一个周期内完成**

* 因此 CISC 很难实现指令流水线，但**RISC必须实现指令流水线**









