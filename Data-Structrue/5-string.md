# 串

重点是字符串匹配模式，其他只做了解。

## 基本概念

+ 串：零个或多个字符组成的有限序列。
+ 子串：串中任意个连续的字符组成的子序列。
+ 空串：长度为零的串。
+ 空白串（空格串）：仅由一个或多个空格组成的串。
+ 空串是任意串的子串，任意串是其自身的子串。

串的基本操作是对子串的操作。

![image-20250113141121699](imgs\image-20250113141121699.png)

## 字符集编码

![image-20250113141652044](imgs\image-20250113141652044.png)

乱码问题就是 使用了不同的编解码方式 导致的。

## 顺序存储

![image-20250113142018981](imgs\image-20250113142018981.png)

顺序串的结构定义方案

* 使用单独的int型变量$length$保存串长。

-》 使用$data[0]$记录串长；优：使得字符位序与数组下标一致。缺：由于$char$类型一个为一字节大小，所以能表示的数字是$0$到$255$，太大的串无法表示。

-》 没有表示串长的变量，使用$\backslash0$表示串结尾，对应$ASCII$码的$0$号字符。缺点是访问串的长度时间复杂度是O(n)

-》 $data[0]$空余，使用单独的变量$length$保存串长，这样解决了串长问题、位序和下标问题、访问串长复杂度问题。

![image-20250113142533834](imgs\image-20250113142533834.png)

## 链式存储

如一般的链式存储结构定义一样，定义一个数据与指向下一位的指针。

但是如果你只在每个结点定义了一个字节的数据，但是又包含了四个字节的指针，那么存储利用率会很低。

如果是顺序表数据类型是整数类型，那么这种利用率低的情况确实无可奈何，但是对于串而言，因为一个字节存储一个字符，所以能一个字节存一个字符类型数据，所以为了提升数据存储利用率，可以每个结点存等多个字符。这个就是**块链串**。

![image-20250113142708844](imgs\image-20250113142708844.png)

## 串的基本操作

### 求子串

![image-20250113143003920](imgs\image-20250113143003920.png)

### 比较串大小

![image-20250113143128075](imgs\image-20250113143128075.png)

### 求子串位置

![image-20250113143300603](imgs\image-20250113143300603.png)

## 模式匹配

模式匹配指在主串中找到与模式串相同的子串并返回其所在位置。

### 朴素模式匹配算法

#### 原理

![image-20250113150552201](imgs\image-20250113150552201.png)

![image-20250113150747688](imgs\image-20250113150747688.png)

![image-20250113150827273](imgs\image-20250113150827273.png)

![image-20250113150905897](imgs\image-20250113150905897.png)

#### 代码表示

![image-20250113151032531](imgs\image-20250113151032531.png)

+ 匹配成功的最好时间复杂度：$O(m)$：刚好第一个就匹配上了，总对比次数为子串长度。
+ 匹配失败的最好时间复杂度：$O((n-m+1))*1)=O(n)$：匹配成功之前，每一次匹配都在第一个字符发现匹配失败。
+ 匹配失败的最坏时间复杂度：$O((n-m+1))*m)= O(nm)$：每一次匹配都到最后一个字母发现匹配失败。

暴力匹配算法的最大问题就是对主串一位位进行对比，当后面的匹配失败后只能回溯主串，只移动一位重新匹配。

### KMP算法

#### 原理

$KMP$算法是对朴素模式匹配算法的优化。

主要思想是失配时，**只有模式串指针回溯，主串指针不变**，找到失配前模式串的**最长公共前后缀**并跳转到最大公共后缀开始匹配，且最大公共前后缀要小于左端子串长度。

主串是未知的，而模式串是已知的，所以对于**串匹配的优化必然基于模式串**。

next数组里存的是最长相等前后缀

#### 手算next数组

**next** = **最长相等先后缀 + 1**（**特别的，next[1] = 0**）

<img src="imgs\image-20250113153720952.png" alt="image-20250113153720952"  />

#### 代码实现

![image-20250113154604609](imgs\image-20250113154604609.png)

#### 算法性能

使用$KMP$算法时需要先计算不同模式串$P$的$next$数组，时间复杂度为$O(m)$，然后使用$KMP$算法计算，时间复杂度为$O(n)$，从而平均**时间复杂度为$O(m+n)$**。

虽然普通模式匹配算法复杂度$O(mn)$，但是一般情况下接近于**$O(m+n)$**。

$KMP$算法对于**重复部分比较多**的模式串匹配**效果更好**。

### KMP算法优化

![image-20250115195913098](imgs\image-20250115195913098.png)
