# 查找

## 基本概念

![image-20250228073222480](imgs\image-20250228073222480.png)

查找表 是指 用于查询的数据集合，没有其他特殊含义。一张图也可能是一个查找表。

### 查找表操作，两种查找表

![image-20250228073530146](imgs\image-20250228073530146.png)

### 查找算法的性能指标

![image-20250228073855693](imgs\image-20250228073855693.png)

评价一个算法效率时，通常要考虑查找成功，查找失败两种ASL

![image-20250228074134245](imgs\image-20250228074134245.png)

![image-20250228074148708](imgs\image-20250228074148708.png)

* 查找失败的结点的查找长度，是**它的父结点所在的高度**（查找长度的定义：查找过程中对比关键字的次数）

## 线性表查找

## 查找算法

### 1. 顺序查找

从头到尾或从尾到头查找，适合于线性表（顺序表/链表都可以）

#### 定义

##### 从头到尾

![image-20250228074707070](imgs\image-20250228074707070.png)

##### 从尾到头（哨兵）

用哨兵的优势是，每一轮循环只需要判断 elem[i] 与 key 是否相等，不需要判断越界。

![image-20250228075018422](imgs\image-20250228075018422.png)

* 从头到脚是默认表在 $[0, ST.TableLen-1]$ 上存储
* 从脚到头是默认表在 $[1, ST.TableLen]$ 存储（0 的位置留下来放哨兵）

#### 查找效率

![image-20250228075345883](imgs\image-20250228075345883.png)

#### 优化查找失败情况（有序表）

![image-20250228075909072](imgs\image-20250228075909072.png)

* （假设是从小到大的有序表）当查找到第一个大于关键字的数时，查找可以提前结束，因此提升了查找失败的查找效率

##### 用查找判定树分析ASL

![image-20250228075935980](imgs\image-20250228075935980.png)

#### 优化查找成功情况（概率不等表）

![image-20250228080230604](imgs\image-20250228080230604.png)

![image-20250228080321723](imgs\image-20250228080321723.png)

### 2. 折半查找（二分查找）

折半查找 只能用于 **有序**的**顺序表**

#### 定义

以顺序表排列从小到大为例：

![image-20250228081715111](imgs\image-20250228081715111.png)



#### 查找效率

![image-20250228084034919](imgs\image-20250228084034919.png)

![image-20250228090209281](imgs\image-20250228090209281.png)

#### 折半查找判定树

+ 若当前$low$和$high$有奇数个元素，则$mid$分割后左右两部分元素个数相等

+ 若当前$low$和$high$有偶数个元素，则$mid$分割后左部分元素个数小于右部分一个

  ![image-20250228084933709](imgs\image-20250228084933709.png)

  ![image-20250228085049106](imgs\image-20250228085049106.png)

* 折半查找的判定树一定是 **二叉排序树** （左 < 中 < 右）
* 折半查找的判定树一定是 **平衡二叉树** （左右子树的高度相差不超过1）
* 折半查找的判定树只有最下边的一层是不满的
* 有$n$元素个数的折半查找判定树，**树高 $h=\lceil\log_2(n+1)\rceil$**（完全二叉树的树高计算方式）
* **失败结点 有 $n+1$ 个**（n 个关键字划分出 n+1 个失败区间）

![image-20250228090309486](imgs\image-20250228090309486.png)

#### 补充知识

1. 虽然说，折半查找的时间复杂度是 $O(\log_2n)$，而顺序查找时间复杂度是 $O(n)$ 。但这里的时间复杂度是一种平均查找长度的预测，根据实际情况不同，顺序查找也可能比折半查找快。

   ![image-20250228090611975](imgs\image-20250228090611975.png)

2. 拓展思考：假如 $mid = \lceil (low + high) / 2 \rceil$，那么 折半查找判定树 会是什么样子

![image-20250228090407814](imgs\image-20250228090407814.png)

3. 折半公式优化：在对$mid$进行取值时，如果数据量太大，查找到右侧时计算$mid$进行两数相加$low+high$可能会数值溢出。那么如何解决？

   * 变幻公式：$(low+high)/ 2 \rightarrow low/2+high/2$

4. 折半查找判定树 和 二叉排序树 的区别：
   * 折半查找判定树一定是平衡二叉树，时间性能为固定的$O(\log_2n)$
   * 而二叉查找树的构造是根据输入来的，时间性能最好为$O(\log_2n)$，最坏可能到$O(n)$

### 3. 分块查找（索引顺序查找）

#### 定义

![image-20250228094840054](imgs\image-20250228094840054.png)

* 有索引表和顺序表，所以别名是索引顺序查找

  先查索引表，再查顺序表

**如果查找索引时使用折半查找，则最后选取low所在的分块**：

折半查找结束时：

- **`low`指针**：指向第一个**大于等于目标值**的索引项位置。
- **`high`指针**：指向最后一个**小于目标值**的索引项位置。

![image-20250228095217123](imgs\image-20250228095217123.png)

#### 查找效率

![image-20250228101301689](imgs\image-20250228101301689.png)

* 如果使用折半查找的方式查找索引表，如果索引表里没有关键字，那么一定是到折半查找失败了，才能继续向区间查找

##### 使用 **顺序查找** 的方式查找索引表

* 随意的分块太复杂，我们只考虑分块均匀的情况

![image-20250228101838847](imgs\image-20250228101838847.png)



##### 使用 **折半查找** 的方式查找索引表

![image-20250228103424243](imgs\image-20250228103424243.png)

![image-20250228103608553](imgs\image-20250228103608553.png)

#### 补充知识

1. 如果查找表是**动态查找表**，则最好用**链式存储**的方式存查找表（至于索引表是顺序表还是链表，取决于希望使用顺序查找还是折半查找的方式查找索引表，顺序查找支持顺序表和链表，折半查找只支持有序的顺序表）

   例如，如果要在顺序表插入8，则要移动大量元素：<img src="imgs\image-20250228104143052.png" alt="image-20250228104143052" style="zoom:50%;" />

   解决方式：<img src="imgs\image-20250228104228746.png" alt="image-20250228104228746" style="zoom:50%;" />

### 4. 散列查找

#### 定义

![image-20250301154727116](imgs\image-20250301154727116.png)

* 散列表 = 哈希表
* 散列查找 = 哈希查找
* 散列函数 建立了 **关键字<->存储地址的映射关系**
* 同义词：映射结果相同的不同关键字被称为同义词
* 冲突：位置被占了

<img src="imgs\image-20250301180707875.png" alt="image-20250301180707875" style="zoom:50%;" />

#### 减少冲突（散列函数）

* 为了提高散列查找的效率，需要尽量减少冲突（即减少同义词出现的概率）

##### 要求

![image-20250301181226245](imgs\image-20250301181226245.png)

##### 除留余数法

![image-20250301173732220](imgs\image-20250301173732220.png)

* 选择的除数一般是不大于数组长度的最大质数（因为以质数做除数会使得余数结果分布更均匀）
* 通用，只要关键字是整数

##### 直接定址法

![image-20250301174057184](imgs\image-20250301174057184.png)

* 散列函数是线性函数
* 适用于关键字连续的情况

##### 数字分析法

![image-20250301174229372](imgs\image-20250301174229372.png)

* 适用于 有数字分布均匀的数码位 的情况

##### 平方取中法

![image-20250301174445380](imgs\image-20250301174445380.png)

* 平方后取中间的几位数字，这几位数字和关键字的每一位数字都有关

提高散列查找的效率，本质上就是空间换时间

##### 折叠法

将关键字分割成位数相同的几部分(最后一部分的位数可以不同)，然后取这几部分的叠加和(舍去进位)作为散列函数的值。

例如，假设关键字为某人身份证号码$430\,1046\,8101\,5355$，则可以用$4$位为一组进行叠加，即有$5355+8101+1046+430=14932$，舍去高位，则有$H(430104681015355)=4932$。

![image-20250301181622179](imgs\image-20250301181622179.png)

#### 处理冲突

##### 拉链法

###### 定义

![image-20250301155114139](imgs\image-20250301155114139.png)

###### 增删改查

* 插入操作时使用头插法效率更高
* 插入操作可以进行优化，使插入后链表有序，提高查找效率

![image-20250301182153963](imgs\image-20250301182153963.png)

##### 开放定址法

###### 定义

![image-20250301182457326](imgs\image-20250301182457326.png)

* 开放定址，即指一个散列表存储地址不仅对同义词开放，对非同义词也开放

![image-20250301182859476](imgs\image-20250301182859476.png)

* $d_0 = 0$，即第0次发生冲突时的探测地址，就是初始存储地址
* $0 ≤ i ≤ m-1$，这里的m是散列表的长度。探测了 $d_0$ - $d_{m-1}$ 说明已经探测了 m 个地址（但是这m次冲突不一定覆盖了散列表的全部地址）

###### 线性探测法

![image-20250301183825573](imgs\image-20250301183825573.png)

* $d_i = 0, 1, 2, 3, ..., m-1$
* 查找操作时，查不到初始地址就查 探测序列指向的地址，直到 **查到空单元** 还没找到，说明没有这个关键字

###### 平方探测法(二次探测法)

![image-20250301184150363](imgs\image-20250301184150363.png)

* $d_i = 0^2, 1^2, -1^2,2^2,-2^2, ..., k^2, -k^2$
* 平方探测法 = 二次探测法

###### 双散列法

![image-20250301200200359](imgs\image-20250301200200359.png)

* 建立了第二个散列函数 $hash_2()$（自定）
* 当发生冲突，输入 初始存储地址 $ket$，根据第二个散列函数 $hash_2()$ 得出第二个散列地址 $hash_2(key)$
* 每次的偏移量 $d_i = i * hash_2(key)$

###### 伪随机序列法

![image-20250301200545763](imgs\image-20250301200545763.png)

* 自定义 $d_i$ 序列

###### 增删改查

* 查找：根据 散列函数 和 关键字 获得 初始存储地址，如果发生冲突，就根据选择的探测方法继续探测其他位置是否存放该关键字，直到最后查找成功，或者查找到空单元意味着查找失败。
* 插入：初始存储地址，冲突则根据指定探测方法找新位置，直到找到空位插入，或者发生了m-1次冲突插入失败
* 删除：查找，查找成功则删除，查找失败则删除失败。
  * 删除元素不能简单的将被删元素的空间置为空，这可能会截断在它之后的探测路径
  * 额外添加一个标志flag，进行删除操作时仅需 flag=1时表示逻辑删除
  * 只能逻辑删除（flag=1）不能物理删除

###### 探测覆盖率

![image-20250301203149101](imgs\image-20250301203149101.png)

#### 查找

* 先根据散列函数判断关键字应该存储在哪个位置，然后在该位置查找关键字是否存在。以拉链法为例：

![image-20250301155255260](imgs\image-20250301155255260.png)

* 在散列表中，查找长度 = 0 的情况是可能发生的（查找长度 = ASL = 比较关键字的个数）

##### $ASL_{成功}$

<img src="imgs\image-20250301155542640.png" alt="image-20250301155542640" style="zoom:50%;" />

* 可以看出 冲突次数 会影响 查找效率，好的散列函数可以尽量减少冲突，最好情况时查找所有关键字的时间复杂度是 $O(1)$

##### $ASL_{失败}$（装填因子）

![image-20250301160317769](imgs\image-20250301160317769.png)

* 散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子

* 装填因子可以在一定程度上反映查找效率，装填因子越大，说明装填进散列表的元素越多，平均查找长度就可能更大。

  但不能说绝对的越小越好（比如上述的这个情况装填因子是0.92，而如果每个空间都只有一个数，则装填因子是1）

* 若只给出了装填因子$\alpha$，则此时平均查找长度为：$ASL=\dfrac{1}{2}(1+\dfrac{1}{1-\alpha})$。

## 用于查找的树

### 1. 二叉排序树 BST（二叉查找树）

#### 定义

![image-20250228113800132](imgs\image-20250228113800132.png)

#### 查找

![image-20250228114022963](imgs\image-20250228114022963.png)

用递归实现二叉排序树的查找：

![image-20250228114138138](imgs\image-20250228114138138.png)

使用非递归的算法，空间复杂度更低一些。

#### 插入

![image-20250228114317087](imgs\image-20250228114317087.png)

每次插入的新结点一定会成为叶子结点

由于该算法是由递归实现，所以最坏情况下的时间复杂度是 $O(h)$

同样，非递归算法空间复杂度更低

#### 构造

![image-20250228114758372](imgs\image-20250228114758372.png)

#### 删除

1. 查找

2. 若被删除结点是叶子结点，则直接删除

3. 若被删除结点只有一棵左子树或右子树，则让子树替代该结点的位置

4. 若被删除结点有左子树和右子树，则让其结点的直接后继（右子树的最小值）或直接前驱（左子树的最大值）替代该结点，然后在子树里删除这个直接后继/直接前驱

删除一个结点，然后重新插入这个结点，得到的二叉排序树可能和原来的二叉排序树是不一样的

#### 查找效率

二叉查找树的查找效率主要取决于树的高度，若是平衡二叉树，则平均查找长度为$O(\log_2n)$，若最坏情况下只有一个单枝树，则平均查找长度为$O(n)$。

![image-20250228122954552](imgs\image-20250228122954552.png)

### 2. 平衡二叉树 AVL

#### 定义

![image-20250228123125629](imgs\image-20250228123125629.png)

* 结点的平衡因子 = 左子树高 - 右子树高

  即平衡二叉树的平衡因子只可能为$-1,0,1$

* **平衡二叉树是特殊的二叉排序树**

#### 插入：调整最小不平衡子树

假设一个二叉排序树已经是平衡二叉树，现在插入了一个新结点，要求调整使其仍然是二叉排序树和平衡二叉树

![image-20250228123242007](imgs\image-20250228123242007.png)

##### LL

![image-20250228124008186](imgs\image-20250228124008186.png)

##### RR

![image-20250228124224523](imgs\image-20250228124224523.png)

##### LR

![image-20250228124725100](imgs\image-20250228124725100.png)

##### RL

![image-20250228124803823](imgs\image-20250228124803823.png)

##### 代码思路

![image-20250228124406079](imgs\image-20250228124406079.png)

* 如果插入序列有序，并且插入 $2^h - 1$ 个结点，则产生的平衡二叉树一定是满二叉树

#### 查找效率

* 若树高为 h ，则最坏情况下，查找一个关键字最多需要对比 h 次

  即查找操作的时间复杂度不可能超过 $O(h)$

* 平衡二叉树：左右子树高度之差不超过1

  * 假设一个平衡二叉树高为 $h$ ，则他最少有 $n_h$ 个结点
  * $n_0 = 0$， $n_1 = 1$， $n_2 = 2$
  * 对于更高的h，满足：
    * 要结点最少，则 这个平衡二叉树 = 1个高为 $h-1$ 的子树 + 1个高为 $h-2$ 的子树 + 1个根结点
    * 所以，$n_h = n_{h-1} + n_{h-2} + 1$（斐波那契数列）

  即：**高度为 h 的 ASL，最少有 $n_h = n_{h-1} + n_{h-2} + 1$ 个结点**

* 一个高度为h的平衡二叉树的结点数目在 $[n_h , 2^h - 1]$ 之间。

  * 一个高为 3 的平衡二叉树的结点数目在 $[4, 7]$ 之间
  * 一个高为 4 的平衡二叉树的结点数目在 $[7, 15]$ 之间
  * 一个高为 5 的平衡二叉树的结点数目在 $[12, 31]$ 之间

  可以看出，**即使一个平衡二叉树的结点个数确定，也不能确定它的高度**

* **一个有$n_h$个结点的平衡二叉树，高度至少是 $ h=\lceil\log_2(n+1)\rceil$**（完全二叉树的性质）

![image-20250228132610345](imgs\image-20250228132610345.png)

#### 删除：一路向北寻找并调整

![image-20250228151018542](imgs\image-20250228151018542.png)

插入和删除操作最耗时的就是查找，所以它们的时间复杂度可以说和查找的时间复杂度相同

### 3. 红黑树 RBT

![image-20250228152321686](imgs\image-20250228152321686.png)

* 平衡二叉树 和 红黑树 的增删查时间复杂度都是 $O(log_2n)$
  * 平衡二叉树 平衡很容易被破坏，每次插入和删除都要计算和修改大量的平衡因子，以及调整二叉树的形态频繁。
  * 红黑树 的性质不容易被增删操作破坏，即使需要调整，时间复杂度也是常数级
* 平衡二叉树多用于静态查找表，红黑树多用于动态查找表

#### 定义

![image-20250301121458199](imgs\image-20250301121458199.png)

红黑树的要求：左根右，根叶黑，不红红，黑路同

* 红黑树是特殊的二叉排序树
* 在红黑树里，叶子节点指的是失败节点（也叫外部节点，null结点）
* 红黑树是三叉链表，有指向父节点的指针

![image-20250301122334855](imgs\image-20250301122334855.png)

* 黑路同不仅适用于根结点，也适用于红黑树中的任意一个结点
* 叶子节点是算在内的，但出发的结点不算在内

#### 性质

1. 从根到叶结点的**最长路径不大于最短路径的两倍**（由性质4，5得到）

2. 有$n$个内部结点的红黑树的高度$h\leqslant2\log_2(n+1)$（后续证明）

   因此红黑树查找、插入、删除的时间复杂度都是$O(\log_2n)$

#### 插入

![image-20250301125004254](imgs\image-20250301125004254.png)

> 新结点如果是非根节点则默认涂红，这样可以保证黑路同
>
> * 插入新结点如果破坏了红黑树结构，一定是破坏了 不红红

![image-20250615160732111](imgs\image-20250615160732111.png)

* 黑叔时，处理完爷父儿直接结束，不会破坏红黑树
* 不管LL、LR、RL、RR，都是新爷和旧爷换颜色

![image-20250615160802880](imgs\image-20250615160802880.png)

* 红叔时，处理完叔父爷变色，要对爷作为新结点考察

* 插入结点产生的新结点，只可能破坏不红红

  爷结点作为新结点，可能破坏不红红、黑路同

![image-20250615161152109](imgs\image-20250615161152109.png)

![image-20250301130548260](imgs\image-20250301130548260.png)

证明：有$n$个内部结点的红黑树的高度$h\leqslant2\log_2(n+1)$

![image-20250301131855970](imgs\image-20250301131855970.png)

* 问题：求n对应的最大h

> 首先，求黑高 h 对应的最小 n
>
> ​	最少情况肯定是没有红色结点，同时为了满足黑路同，这一定是一个满二叉树
>
> ​	所以黑高为 h 的红黑树，$n ≥ 2^h - 1$
>
> 因此，求 n 对应的最大树高 h
>
> ​	假设红黑树高=h，则 $黑高 ≥ \frac{h}{2}$
>
> ​	一定有 n ≥ $2^\frac{h}{2} - 1$ 
>
> ​	即 $h\leqslant2\log_2(n+1)$

#### 删除

![image-20250301132517591](imgs\image-20250301132517591.png)

> 红黑树RBT 是 二叉排序树BST，所以和 平衡二叉树AVL 一样，删除操作还是按照二叉排序树来删。
>
> 只是删完可能会破坏 AVL/RBT 的性质，所以要调整

### 4. B树

> AVL，RBT 都是特殊的 BST ，它们都是一种二叉树
>
> 而这里的 B树 是 m 阶树，不是二叉树

#### m叉查找树

##### 定义

![image-20250301135211935](imgs\image-20250301135211935.png)

![image-20250301135139404](imgs\image-20250301135139404.png)

* m叉查找树，一个结点里最多有m-1个关键字，m个分支
* 结点内部 **关键字有序**（所以可以使用顺序查找和折半查找）

#### m叉查找树优化（B树定义）

##### 1. 防止树高过高

![image-20250301135515475](imgs\image-20250301135515475.png)

* 强制要求结点关键字个数 —— $≥ \lceil{m/2}\rceil - 1$ 个
* 无法强制要求根结点的关键字个数 —— 有时树中存储的关键字过少，甚至不足 $\lceil{m/2}\rceil - 1$ 个

##### 2. 任何结点的所有子树高度相同

​	![image-20250301140223884](imgs\image-20250301140223884.png)

##### B树定义

能实现以上两点优化的m叉查找树就是B树

![image-20250301141809130](imgs\image-20250301141809130.png)

* B树 别名 **多路平衡查找树**

#### 性质

##### 有n个关键字B树的最小高度

* 默认叶子节点所在层不计入B树高度

![image-20250301144204282](imgs\image-20250301144204282.png)

##### 有n个关键字B树的最大高度

![image-20250301145854602](imgs\image-20250301145854602.png)

* 求结点为 n 的B树的最大高度
  * n个关键字的B树必有 n+1 个叶子节点，是因为这n个关键字划分出了 n+1 个失败区间
  * 也就是说，层数为h的B树，最少存量是 $2\lceil{m/2}\rceil^{h-1} - 1$个元素
  * 如果 n < 最少存量，就构不成高度 h
  * 因此，$n ≥ 2\lceil{m/2}\rceil^{h-1} - 1$


+ 有$n$个非叶结点的$m$阶$B$树中至少包含 $(n-1)(\lceil{m/2}\rceil-1)+1$ 个关键字。（根结点最少有1个，其他结点每个最少有 $\lceil{m/2}\rceil-1$个）

#### 查找

$B$树的查找包含两个基本操作：

1. 在$B$树中找结点。
2. 在结点内找关键字。

由于$B$树常存储在磁盘上，因此前一个查找操作是在磁盘上进行的，而后一个查找操作是在内存中进行的，即在找到目标结点后，先将结点信息读入内存，然后在结点内采用顺序查找法或折半查找法。

在$B$树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找，则说明树中没有对应的关键字，查找失败。

#### 插入

##### 新元素必然插入到终端结点

<img src="imgs\image-20250301151527835.png" alt="image-20250301151527835" style="zoom:50%;" />

* 新元素插入一定是插入到最底层的终端结点，因为B树要求失败节点必须在同一层

  <img src="imgs\image-20250301151614766.png" alt="image-20250301151614766" style="zoom:33%;" />

  
  
  ##### 调整方法

![image-20250301152500282](imgs\image-20250301152500282.png)

#### 删除

* 对非终端结点的删除总是可以转化成对终端结点的删除（删除它的直接前驱或者直接后继）

  例如，删除 80（把77移到80的位置，然后当作删除77处理）

  ![image-20250301205648592](imgs\image-20250301205648592.png)

* 删除终端结点：

  1. 删除后结点关键字个数不低于下限，直接删，移动后边元素

  2. 低于下限，兄弟够借，则兄弟传给父，父传给自己
  
     例如，删掉 38
  
     ![image-20250301233524523](imgs\image-20250301233524523.png)
  
     ![image-20250618211230541](imgs\image-20250618211230541.png)
  
   3. 低于下限，兄弟不够借，则兄弟，父，自己，都进行合并。父缺了一个可能又会低于下限，则继续合并直到根
  
      例如，删掉 49
  
      ![image-20250618211509109](imgs\image-20250618211509109.png)
  
      ![image-20250618211139020](imgs\image-20250618211139020.png)
  
      
  
      ![image-20250618211615158](imgs\image-20250618211615158.png)
  
      ![image-20250301233912591](imgs\image-20250301233912591.png)

![image-20250301234017142](imgs\image-20250301234017142.png)

### 5. B+树

#### 定义

* **B+树是分块查找进化版**
  * 分块查找只有一个索引表
  * 而B+树有多层索引表

![image-20250301234854068](imgs\image-20250301234854068.png)

##### B+树和B树的相同之处

* 对于每个结点的分支数的要求都是一样的
* B+树也要求平衡，即叶子结点也必须都在同一层
* 结点内的关键字必须有序

##### B+树和B树的不同之处

* B树的结点里有m个关键字，就会有m+1个分支

* B+树的结点里有m个关键字，就会有m个分支

  

* 因为分支数要求都是一样的，但是m个关键字对应的分支数不一样，所以对结点内关键字的要求不一样

  * B树对于根结点的关键字要求：$[1, m-1]$, 其他结点：$[\lceil {m/2} \rceil - 1, m-1]$
  * B+树对于根结点的关键字要求：$[1, m]$，其他结点：$[\lceil {m / 2} \rceil, m]$

  

* B树里的叶子结点指的是失败结点，所以如果有n个关键字，则有n+1个叶子结点

* B+树里的叶子结点指的是查找表里的结点，所以如果有n个关键字，则所有叶子结点里关键字数目是n（叶子结点数不确定）

  

* B+树也可以通过指针p对所有的关键字进行顺序查找

  

* 在B树里要查记录，如果能查找成功，一定在访问叶结点之前。如果查找失败，一定是访问到叶结点

* 在B+树里要查记录，不管查找成功还是失败，一定是访问到叶结点（索引表只存关键字，叶节点存的有指向完整记录的指针）

  

* B树每个结点 存x个关键字，x+1个分支指针，x个关键字指向的记录
* B+树的索引表 存x个关键字，x个分支指针。只有查找表才存n个关键字指向的记录。
* 所以在磁盘空间相等的情况下，B+树的索引表可以存储更多的关键字，让树更”胖矮“，查找更快

