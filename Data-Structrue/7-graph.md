# 图

主要了解概念，算法具体实现不是重点。

## 基本概念

### 图的定义

#### G，V，E

* 图是顶点集和边集构成的二元组，即**图$G$由顶点集$V$和边集$E$组成**，记为**$G=(V,E)$**

* 其中$V(G)$表示图$G$中**顶点的有限非空集（图一定是非空的）**，$E(G)$表示图$G$中顶点之间的关系（边）集合。

* 若$V=\{v_1,v_2\cdots,v_n\}$，则用**$\vert V\vert$表示图$G$中顶点的个数，也称图$G$的阶**，$E=\{(u,v)\vert u\in V,v\in V\}$，用**$\vert E\vert$表示图$G$中边的条数**，其中 u, v 必须是V中的顶点。

#### 无向图 VS 有向图

![image-20250222173840424](imgs\image-20250222173840424.png)

#### 简单图，多重图

![image-20250222174053484](imgs\image-20250222174053484.png)

一般的图默认是简单图。

无向图 和 有向图 都有 简单图 和 多重图 的概念，要求都如上。

#### 顶点的度 VS 入度/出度

![image-20250222174551105](imgs\image-20250222174551105.png)

TD(v)	TD指的是total degree

* 无向图 只有 TD(v)。对于$n$个顶点的无向图，每个顶点的度最大为$n-1$。

* 有向图 TD(v) = ID(v) + OD(v)。对于$n$个顶点的有向图，每个顶点的度最大为$2n-2$。

#### 顶点的路径，回路，连通 VS 强连通

![image-20250222175111232](imgs\image-20250222175111232.png)

* 以上都属于两个点之间的概念
* 点到点之间的路径可能不唯一，但是点到点之间的距离一定是唯一的。

联通 的概念属于 无向图中的两个顶点

强连通 的概念属于 有向图中的两个顶点

#### 连通图 VS 强连通图

![image-20250222175313907](imgs\image-20250222175313907.png)

连通图 的概念属于 无向图

强连通图 的概念术语 有向图

#### 子图，生成子图

![image-20250222175501403](imgs\image-20250222175501403.png)

子图：顶点集和边集 都是 原来的图的子集，并且子图也要满足是一个图的条件（顶点集不为空，边集的两端必定在顶点集里）

生成子图：子图的顶点集 和 原来的图的顶点集 完全一致。

无向图 和 有向图 都有 子图 和生成子图 的概念，要求都如上。

#### 连通分量 VS 强连通分量

![image-20250222180225101](imgs\image-20250222180225101.png)

![image-20250222180328489](imgs\image-20250222180328489.png)

连通分量 是 无向图 的概念

强连通分量 是 有向图 的概念

#### 生成树，生成森林

![image-20250222180453436](imgs\image-20250222180453436.png)

生成树 是 连通图 的概念，连通图 是 无向图 的概念

* 生成树的顶点集 等于 原图的顶点集
* 若图的顶点为$n$，则其生成树包含$n-1$条边（去掉生成树的一条边则会变成非连通图，若加上一条边则会形成一个回路）
* 生成树 不是唯一的
* 极小连通子图和生成树的概念不是等价的，生成树是包含图中全部顶点的一个极小连通子图。

![image-20250222180731543](imgs\image-20250222180731543.png)

生成森林 是 非连通图 的概念，非连通图 是 无向图 的概念

### 几种特殊的图

#### 带权图（网）

![image-20250223113917983](imgs\image-20250223113917983.png)

带权图 = 网

无向图 和 有向图 都有 带权图 的概念

#### 无向完全图 VS 有向完全图

![image-20250223114030166](imgs\image-20250223114030166.png)

+ 无向完全图 有 $C_n^2$ 条边
+ 有向完全图 有 $2C_n^2$ 条边

#### 稀疏图，稠密图

![image-20250223114424201](imgs\image-20250223114424201.png)

+ 稀疏图：一般$\vert E\vert<\vert V\vert\log\vert V\vert$的图。
+ 稠密图：与稀疏图对应的概念

#### 树 VS 有向树

![image-20250223114546537](imgs\image-20250223114546537.png)

<img src="imgs\image-20250223114728420.png" alt="image-20250223114728420" style="zoom:50%;" />

+ 树 是 无向图 的概念
+ 有向树 是 有向图 的概念
+ **树 是连通图，但 有向树 不是 强连通图**

![image-20250223115159911](imgs\image-20250223115159911.png)

## 图的存储结构

### 邻接矩阵

#### 不带权图邻接矩阵

![image-20250223115459781](imgs\image-20250223115459781.png)

* 邻接矩阵的**空间复杂度是$O(\vert {V^2} \vert)$**，适用于存储**稠密图**。
* 对于**无向图**，图的**边数**等于 **矩阵内所有非零点的数量 / 2**
* 对于**有向图**，图的**边数**等于 **矩阵内所有非零点的数量**
* **无向图**的邻接矩阵**关于主对角线对称**，可以**压缩存储**。

根据邻接矩阵求一个顶点的度/入度/出度

![image-20250224003348197](imgs\image-20250224003348197.png)



#### 带权图邻接矩阵

![image-20250224003550876](imgs\image-20250224003550876.png)

有的带权图邻接矩阵 会把**指向自己的度设为 ∞，有的设为 0**，两种都表示是指向自己的。

![image-20250224004616033](imgs\image-20250224004616033.png)

#### 性质

> * 确定图中有多少条边，时间复杂度是$O(\vert {V^2} \vert)$
>
> * 确定任意两个顶点之间是否有边，时间复杂度为$O(1)$
> * 只要每个顶点确定了编号，邻接矩阵的表示方式唯一

### 邻接表

#### 不带权图邻接表

![image-20250224005916186](imgs\image-20250224005916186.png)

![image-20250224010154360](imgs\image-20250224010154360.png)

#### 带权图邻接表 

就是在 边上 加一个 边权值 属性

#### 性质

![image-20250602171131298](imgs\image-20250602171131298.png)

* 邻接表适合存储稀疏图

* 邻接表的表示方式不唯一（边的顺序可能不同）

### 十字链表 （有向图

存储有向图：	邻接矩阵：空间复杂度高

​				邻接表：查找入度/入边不方便

![image-20250224012231085](imgs\image-20250224012231085.png)

> 顺着 ”弧尾相同的下一道弧“ 一直找，能找到 该顶点的所有出边
>
> 顺着 ”弧头相同的下一道弧“ 一直找，能找到 该顶点的所有入边

* 空间复杂度是$O(\vert V\vert+\vert E\vert)$

* 查找入度/入边，出度/出边都方便

* 十字链表图表示是不唯一的

### 邻接多重表 （无向图

存储无向图：	邻接矩阵：空间复杂度高

​				邻接表：边存储冗余，增加/删除 顶点或边 时改动大（不仅要改本顶点，任何相连的顶点都要改

![image-20250224013323880](imgs\image-20250224013323880.png)

* 空间复杂度为$O(\vert V\vert+\vert E\vert)$。

* 邻接多重表表示是不唯一的。

![image-20250224013436019](imgs\image-20250224013436019.png)

## 图的基本操作

### 查找

1. 判断图G是否存在边<x, y>或者(x, y)![image-20250224014245334](imgs\image-20250224014245334.png)

2. 列出图G中与结点x邻接的边![image-20250224014426638](imgs\image-20250224014426638.png)	![image-20250224014651885](imgs\image-20250224014651885.png)

### 插入

1. 在图G中插入顶点x

   * **邻接矩阵的大小是初始化时定好的，插入新顶点其实就是添加一行一列**

   ![image-20250224015343717](imgs\image-20250224015343717.png)

2. 添加一条边

   * 邻接表使用头插法比尾插法快。

   ![image-20250224020515334](imgs\image-20250224020515334.png)

### 删除

1. 在无向图G中删除顶点x

   * 邻接矩阵删除和顶点相关的一行一列要移动大片元素，因此新增一个bool变量表示边的有效性

   * 邻接表删除顶点， 最好情况：该顶点没有任何相连的边 （$O(1)$）。

   ​				最坏情况：该顶点和所有边都相连，而且都在链表末尾（$O(E)$）![image-20250224015853670](imgs\image-20250224015853670.png)

* 在有向图G中删除顶点x![image-20250224020225053](imgs\image-20250224020225053.png)

2. 删除一条边

   ![image-20250224020817033](imgs\image-20250224020817033.png)

### 其他

1. 求图G中顶点x的第一个邻接点![image-20250224020950073](imgs\image-20250224020950073.png)

   

   ![image-20250224021104934](imgs\image-20250224021104934.png)

2. 求下一个邻接点

   ![image-20250224021234158](imgs\image-20250224021234158.png)

![image-20250224021424024](imgs\image-20250224021424024.png)

### 遍历

分为广度优先$BFS$与深度优先$DFS$。

广度优先类似层序遍历，深度优先类似先序遍历。

 广度优先是每一次遍历都要把所有的相邻顶点全部遍历到，而深度优先是每一次遍历只遍历最近的一个一直深入。

#### 广度优先遍历

##### 思路

类似树的层次遍历，但是由于图里有环路，要添加一个数组判断顶点是否被访问过

![image-20250224122457812](imgs\image-20250224122457812.png)

##### 代码实现

有向图和无向图都是这个代码

![image-20250224123013667](imgs\image-20250224123013667.png)

![image-20250224123730016](imgs\image-20250224123730016.png)

##### 性质

![image-20250224123443515](imgs\image-20250224123443515.png)

遍历图的时间开销主要来源于

* 遍历各个顶点
* 查找顶点的所有邻接点
* 两者不是相乘的关系，而是相加的关系

![image-20250224124417475](imgs\image-20250224124417475.png)

##### 广度优先生成树

![image-20250224124857169](imgs\image-20250224124857169.png)

![image-20250224124944539](imgs\image-20250224124944539.png)

邻接矩阵生成的广度优先生成树是唯一的，邻接表不唯一，所有生成树也是不唯一的。

![image-20250224125111596](imgs\image-20250224125111596.png)

![image-20250224125638277](imgs\image-20250224125638277.png)

+ 因为广度优先算法不需要回退，所以不是一个递归算法。
+ 对于**非带权图**，使用$BFS$可以解决单源最短路径问题，因为广度优先搜索按照距离由近到远。

#### 深度优先遍历

##### 代码实现

类似树的先根遍历，但是由于图里有环路，要添加一个数组判断顶点是否被访问过

![image-20250224130025272](imgs\image-20250224130025272.png)

![image-20250224141446832](imgs\image-20250224141446832.png)

![image-20250224141538188](imgs\image-20250224141538188.png)

##### 性质

![image-20250224141632408](imgs\image-20250224141632408.png)

![image-20250224141835832](imgs\image-20250224141835832.png)

![image-20250224142135641](imgs\image-20250224142135641.png)

##### 深度优先生成树

![image-20250224142208351](imgs\image-20250224142208351.png)

+ 是一个递归算法，所以需要一个工作栈。

+ 使用$DFS$算法递归地遍历一个无环有向图，并在退出递归时输出相应顶点，这样得到的顶点序列是逆拓扑有序。（因为栈的先进后出特性）

+ *图的广度优先生成树的高度小于等于深度优先生成树的高度*

#### 图遍历与图连通性

![image-20250224142652039](imgs\image-20250224142652039.png)

![image-20250224142732832](imgs\image-20250224142732832.png)

![image-20250224142831975](imgs\image-20250224142831975.png)

## 图的应用

### 最小生成树（最小代价树）

#### 生成树定义

（生成树 是 连通图 的概念，连通图 是 无向图 的概念）

通过BFS，DFS都可以得到图G的一个生成树（广度优先生成树，深度优先生成树）

![image-20250224144903219](imgs\image-20250224144903219.png)

#### 最小生成树定义

（最小生成树 是 带权连通无向图 的概念）

![image-20250224144812030](imgs\image-20250224144812030.png)

![image-20250224145206956](imgs\image-20250224145206956.png)

获得最小生成树算法就是Prim算法和Kruskal算法

#### Prim算法（选顶点）

![image-20250224145719236](imgs\image-20250224145719236.png)

#### Kruskal算法（选边）

![image-20250224150000802](imgs\image-20250224150000802.png)

#### 性质

![image-20250224150103217](imgs\image-20250224150103217.png)

时间复杂度的由来

![image-20250224150301012](imgs\image-20250224150301012.png)

![image-20250224150754701](imgs\image-20250224150754701.png)

![image-20250224150928681](imgs\image-20250224150928681.png)

![image-20250224151307338](imgs\image-20250224151307338.png)

* 对所有边，都要判定是否要加入到最小生成树，所以要判断E次

* 每次判断边，要判断它 是否连接了两个本来就连通的顶点

  使用并查集 —— 

  * 把确认添加的边，连接的顶点放进一个集合，其他顶点各自当作一个集合
  * 只需要判断顶点是否在已连接顶点的集合里
  * 并查集中，判断两个元素是否属于同一个集合，最佳算法的时间复杂度是$O(log_2E)$

![image-20250224151350550](imgs\image-20250224151350550.png)

### 最短路径

最短路径一定是简单路径（不存在环）。但是无论有没有环的有向图与是否存在最短路径无关。

#### 单源最短路径

##### BFS算法（无权图）

![image-20250224152949558](imgs\image-20250224152949558.png)

![image-20250224153350783](imgs\image-20250224153350783.png)

因为bfs算法特性决定每个点到根节点路径最短，即生成树每个点到根节点的路径都是最短的，所以生成树的高度是最小的

##### Dijkstra算法（带权图、无权图）

![image-20250224154708972](imgs\image-20250224154708972.png)

![image-20250224155151373](imgs\image-20250224155151373.png)

Dijkstra算法不适用的场景：

![image-20250224155304018](imgs\image-20250224155304018.png)

#### 每对顶点间最短路径

##### Floyd算法

![image-20250224160146283](imgs\image-20250224160146283.png)

* 这样运行 |V| - 1 轮，每一轮都新增一个允许的结点，其实就是判断，每一个两个顶点之间的路径上，加入了这个新增顶点会不会让路经更短

* 每次尝试用顶点 x 中转时， x 行 x 列的内容不需要改变，主对角线元素不需要改变

![image-20250224162029764](imgs\image-20250224162029764.png)

代码：

![image-20250224161428792](imgs\image-20250224161428792.png)

根据A 和 path 倒推任意两个顶点之间的最短路径

![image-20250224180853890](imgs\image-20250224180853890.png)

* 不仅需要关注从起点到终点的中间结点

  **也要关注从中间结点到另一个中间结点，因为它们之间可能还有中间结点**

* $Floyd$算法出题基本上都是四个顶点及以下的图

* 能**解决**带**负权值**的问题

* **不能解决**带有**负权回路**的图（即有负权值的边组成回路，这种图可能没有最短路径）

![image-20250224181521432](imgs\image-20250224181521432.png)

### 有向无环图 DAG

#### 定义

![image-20250224181611019](imgs\image-20250224181611019.png)

#### 应用一 省略表达式

<img src="imgs\image-20250224181841293.png" alt="image-20250224181841293" style="zoom:50%;" />

如果不用树，而是用有向无环图表示，可以节省计算和存储

![image-20250224181952484](imgs\image-20250224181952484.png)

##### **合并规律：顶点中不出现重复的操作数**

![image-20250224182524387](imgs\image-20250224182524387.png)

##### 手动合并方法

![image-20250224182955506](imgs\image-20250224182955506.png)

第四步操作后的结果：

<img src="imgs\image-20250224183104259.png" alt="image-20250224183104259" style="zoom:33%;" />

#### 应用二 拓扑排序

##### AOV网的定义

AOV网一定是一个有向无环图

![image-20250224184624417](imgs\image-20250224184624417.png)

**拓扑排序** 可以用来判断 **图中有没有回路**

![image-20250224185004492](imgs\image-20250224185004492.png)

##### 代码实现

![image-20250224185730408](imgs\image-20250224185730408.png)

##### 性质

![image-20250224185851162](imgs\image-20250224185851162.png)

##### 逆拓扑排序

每次删除出度为0的点

如果需要 逆拓扑排序，则使用邻接表查找一个顶点的入边 时间复杂度很高，更适合用邻接矩阵（也可以用逆邻接表）

**也可以用DFS实现逆拓扑排序**（前提是有向无环图）

![image-20250224190615555](imgs\image-20250224190615555.png)

![image-20250224190751882](imgs\image-20250224190751882.png)

#### 关键路径

##### AOE网的定义

![image-20250225123648485](imgs\image-20250225123648485.png)

##### 关键路径的定义

+ 只有一个入度为$0$的顶点，即开始顶点（源点），表示整个工程的开始。
+ 只有一个出度为$0$的顶点，称为结束顶点（汇点），表示整个工程的结束。

![image-20250225123937168](imgs\image-20250225123937168.png)

求关键活动，关键路径：

![image-20250225124919076](imgs\image-20250225124919076.png)

+ 关键活动时间增加，整个工程工期延长

  关键活动时间减少，整个工程工期缩短

+ 关键活动时间减少，可能变为非关键活动

+ 关键路径可能不止一条，若有**多条关键路径**

  必须**提高所有关键路径关键活动**才能**缩短工期**

+ 关键路径是从源点到汇点路径长度最长的路径

![image-20250225125326551](imgs\image-20250225125326551.png)

![image-20250225125340511](imgs\image-20250225125340511.png)
