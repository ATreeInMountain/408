# 栈

栈结构与线性表类似，是只允许一端（表尾）进入或删除的线性表。即**后进先出$LIFO$**。

**栈顶**就是**允许插入和删除**的一端，而另一端就是栈底。

进栈顺序：$A\rightarrow B\rightarrow C\rightarrow D$，出栈顺序：$D\rightarrow C\rightarrow B\rightarrow A$。

<img src="imgs\image-20250108191441486.png" alt="image-20250108191441486" style="zoom:50%;" />
$$
C^n_m = \frac{n!}{m!(n-m)!}
$$


## 顺序栈

### 顺序栈定义

设置栈顶指针可以为$0$（代表栈顶元素的下一个存储单元）也可以为$-1$（代表栈顶元素当前未知）。

### 顺序栈操作

#### 顺序栈初始化

栈顶指针初始化为$-1$，因为索引最小为$0$。如果初始化为$0$也可以，不过其操作有所不同。

<img src="imgs\image-20250109192116978.png" alt="image-20250109192116978" style="zoom: 33%;" />

#### 进栈

首先要判满，然后才能进栈。若栈顶指针指的是当前元素，即初值为$-1$，需要先自加再进栈，如果不先自加就会覆盖在原来的栈顶元素上。若栈顶指针指的是当前元素的下一个位置，即初值为$0$，则先进栈再自加，因为指向的下一个位置，所以指向的位置是空的，所以可以存入然后自加，若先自加则中间就空了一格。

<img src="imgs\image-20250109192255411.png" alt="image-20250109192255411" style="zoom:33%;" />

#### 出栈

首先要判空，然后才能出栈。若栈顶指针指的是当前元素，即初值为$-1$，需要先出栈再自减，如果由于指的是当前元素所以要先将这个指向的元素弹出，然后自减，否则弹出的就是靠近栈底的下一个元素。若栈顶指针指的是当前元素的下一个位置，即初值为$0$，则先自减再出栈，因为指向的下一个位置，所以指向的位置是空的，要先自减指向有元素的一格才能出栈。

对于出栈元素的处理，既可以将原来的存储单元设置为`NULL`也可以不处理，因为栈顶指针不指向这些单元，用户是不知道里面是什么的，之后重新用到这些存储单元也会覆盖原来的数据。

<img src="imgs\image-20250109192504659.png" alt="image-20250109192504659" style="zoom:33%;" />

#### 注意实现方式

<img src="imgs\image-20250109192708736.png" alt="image-20250109192708736" style="zoom:33%;" />

### 共享栈

即根据栈底不变，让两个顺序栈共享一个一维数组，将两个栈的栈底设在数组两端，栈顶向共享空间延申。

存取数据时间复杂度为$O(1)$。

<img src="imgs\image-20250109192746063.png" alt="image-20250109192746063" style="zoom:33%;" />

## 链栈

链栈基本上就是只能操作一头的链表，所以从定义上其基本上没有区别。基本上以表头为栈顶。

## 栈的应用

### 括号匹配

<img src="imgs\image-20250110173700447.png" alt="image-20250110173700447" style="zoom:33%;" />

发生以下三种情况证明匹配失败：

1. 左右括号不匹配
2. 右括号匹配时，栈已经空了
3. 没有要处理的括号了，但栈里还有元素

![image-20250110174325802](imgs\image-20250110174325802.png)

### 表达式求值

表达式分为三个部分：操作数、运算符、界限符。

#### 后缀表达式（逆波兰表达式）

在计算机中后缀表达式更通用，因为不需要判断运算顺序

##### 手算

###### 中缀转后缀

![image-20250110183712572](imgs\image-20250110183712572.png)

###### 后缀转中缀(计算后缀表达式)

![image-20250110183903115](imgs\image-20250110183903115.png)

##### 机算

###### 中缀转后缀

在这里，栈是用来存放生效次序不确定的运算符的

![image-20250111143038692](imgs\image-20250111143038692.png)

###### 后缀转中缀(计算后缀表达式)

![image-20250111142943513](imgs\image-20250111142943513.png)

###### 计算中缀表达式

在计算机中，**计算中缀表达式 = 中缀转后缀 + 计算后缀表达式**

而 **中缀转后缀** 和 **计算后缀表达式** 都是从左往右进行的，所以在计算时可以同时进行，加快运算速度。

![image-20250111143448412](imgs\image-20250111143448412.png)

![image-20250111143613637](imgs\image-20250111143613637.png)

#### 前缀表达式（波兰表达式）

##### 手算

###### 中缀转前缀

和中缀转后缀的区别：1. 顺序是【运算符 左操作数 右操作数】	2. 前缀表达式遵循**右优先**原则

##### 机算

###### 前缀转中缀（计算前缀表达式）

和后缀转中缀的区别：1. **从右往左扫描**	2. **先弹出的在左**

![image-20250110191815576](imgs\image-20250110191815576.png)

![image-20250110192016398](imgs\image-20250110192016398.png)

### 递归

函数调用的特点：最后被调用的函数最先执行结束$LIFO$。

函数调用时需要一个栈存储：调用返回地址、实参、局部变量。用栈来让递归算法转换为非递归算法。

![image-20250111143840434](imgs\image-20250111143840434.png)

![image-20250111151004191](imgs\image-20250111151004191.png)

![image-20250111151119511](imgs\image-20250111151119511.png)

递归可以将原始问题拆分为属性相同、规模较小的问题。但是如果太多层会造成栈溢出。
