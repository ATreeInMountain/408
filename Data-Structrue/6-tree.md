# 树

## 基本概念

### 树的基本概念

+ 树：$n$个结点的有限集（树是一种递归的数据结构，适合于表示具有层次的数据结构）。是**递归定义**的。

+ 空树：结点数为$0$的数。

+ 子树：当$n>1$时，其余结点可分为$m$个互不相交的有限集合，每个集合本身又是一棵树，其就是根结点的子树。

  

+ 根结点：只有子结点没有父结点的结点。**除了根结点外，树任何结点都有且仅有一个前驱**。

+ 分支结点（非终端结点）：**度>0的结点**

+ 叶子结点：没有子结点只有父结点的结点。

+ 祖先：**根结点到结点的路径上的任意结点**都是该结点的祖先。

+ 子孙：以该结点孩子以及该结点所有孩子的孩子组成

+ 双亲（父）：一个结点的直接前驱。

+ 孩子：一个结点的直接后继。

+ 兄弟：有**共同双亲**结点的结点。

+ **堂兄弟**：**双亲结点在同一层**的结点。

  

+ 路径：树的路径是**从上往下**的，祖先到子孙有路径，子孙到祖先没有

+ 路径长度：路径上所经过的**边**的个数。

+ 树的路径长度：指<u>根到每个结点</u>的<u>路径长</u>的<u>总和</u>。

  

+ 结点的**层次**（深度）：从上往下数，根结点在第一层。

+ 结点的**高度**：从下往上数，叶子结点的高度是1。

+ **树的高度**（深度）：总共有多少层。

+ 结点的**度**：一个结点的**孩子（分支）个数**。

+ **树的度**：树中**结点的最大度数**。

  

+ **有序树**：树各结点的子树**从左至右有次序**。

+ **无序树**：树各结点的子树从左至右**无次序**。

### 森林的基本概念

+ 森林是$m$棵互不相交的树的集合。
+ 一颗树可以被分为森林。
+ 有空森林。

### 树的性质

![image-20250116132717596](imgs\image-20250116132717596.png)

![image-20250116132512674](imgs\image-20250116132512674.png)

![image-20250116132756671](imgs\image-20250116132756671.png)

![image-20250116132924323](imgs\image-20250116132924323.png)

![image-20250116132955571](imgs\image-20250116132955571.png)

![image-20250116133051267](imgs\image-20250116133051267.png)

![image-20250116133110952](imgs\image-20250116133110952.png)

## 二叉树

### 二叉树的基本概念

+ 二叉树是**$n(n>=0)$**个结点构成的有限集合。
+ 二叉树可以为**空二叉树**，也可以是由一个根结点和两个互不相交的被称为根的**左子树和右子树**构成。左子树和右子树又分别是一棵**二叉树**，二叉树是**有序树**，左右子树不能颠倒。

![image-20250116194718436](imgs\image-20250116194718436.png)

### 特殊二叉树

![image-20250116195007678](imgs\image-20250116195007678.png)

如果一个完全二叉树只有一个孩子结点，那一定是左孩子。

![image-20250116195157670](imgs\image-20250116195157670.png)

![image-20250116195402136](imgs\image-20250116195402136.png)

![image-20250116195458356](imgs\image-20250116195458356.png)

### 二叉树的性质

![image-20250120154140087](imgs\image-20250120154140087.png)

![image-20250120154154032](imgs\image-20250120154154032.png)

![image-20250120154223760](imgs\image-20250120154223760.png)

![image-20250120154317980](imgs\image-20250120154317980.png)

![image-20250123152322348](imgs\image-20250123152322348.png)

![image-20250123152345924](imgs\image-20250123152345924.png)

### 二叉树存储结构

#### 顺序存储

这种存储结构需要从下标$1$开始存储，若从$0$开始则不满足父子结点的性质。

![image-20250123152608950](imgs\image-20250123152608950.png)

如果是完全二叉树，可以按照顺序进行存储，如果$i$有左孩子则$2i\leqslant n$，若有右孩子则$2i+1\leqslant n$，若有叶子或分支结点则$i>\lfloor\dfrac{n}{2}\rfloor$:

![image-20250123152745852](imgs\image-20250123152745852.png)

如果不是完全二叉树，则让二叉树的编号与完全二叉树相对应再存入数组，如果需要判断结点是否存在，就查看该结点的 `isEmpty` 属性是否为true。

![image-20250123152845789](imgs\image-20250123152845789.png)

这种存储方法会浪费较多内存，最坏情况下高度为$h$，且只有$h$个结点的单支树也需要$2^h-1$个存储单元。

![image-20250123152923291](imgs\image-20250123152923291.png)

#### 链式存储

链式树具有两个分别指向左右子树的指针。

含有$n$个结点的二叉链表中，链域一共有$2n$个（每个点有两个链域）。一共有$n-1$个指针指向某个结点，于是有$2n-(n-1)=n+1$个链域没有指向任何东西。

![image-20250123153302207](imgs\image-20250123153302207.png)

代码实现二叉链表的操作

![image-20250123153446832](imgs\image-20250123153446832.png)

如果要保存父结点的位置，可以添加一个父结点指针，从而变成三叉链表。

![image-20250123153832163](imgs\image-20250123153832163.png)

### 二叉树遍历

遍历是按照某种次序将所有结点都访问一遍。

#### 顺序遍历

##### 定义

顺序遍历就是深度优先的遍历，分为三种：

+ 先序遍历：根左右$NLR$。
+ 中序遍历：左根右$LNR$。
+ 后序遍历：左右根$LRN$。

根据算算数表达式的分析树的不同先序、中序、后序遍历方式可以得到前缀、中缀、后缀表达式。

![image-20250123154848525](imgs\image-20250123154848525.png)

##### 代码和复杂度分析

![image-20250123155231257](imgs\image-20250123155231257.png)

以先序遍历为例，可以看出若树的高度为$h$，则时间复杂度为$O(3n)$ 即 $O(n)$，空间复杂度为$O(h+1)$ 即 $O(h)$。

**先中后序遍历，都会对一个结点路过三次**，先序遍历在第一次路过时访问结点，中序遍历在第二次路过时访问结点，后序遍历在第三次路过时访问结点。

##### 求树的深度（应用）

![image-20250123155844229](imgs\image-20250123155844229.png)

#### 层序遍历

##### 定义

层序遍历就是广度优先的遍历。

![image-20250123160306349](imgs\image-20250123160306349.png)

##### 代码

不确定在算法过程中队列里最多要放多少个元素，所以使用链队而不是顺序队列

![image-20250123160732396](imgs\image-20250123160732396.png)

### 遍历序列构造二叉树

二叉树 和 遍历序列 是 多对一 的关系。一个二叉树的特定遍历方式（比如中序遍历）只对应一个遍历序列，但是一个遍历序列可能是多种二叉树通过同样的遍历方式得到的。

![image-20250123193735814](imgs\image-20250123193735814.png)

根据序列推出唯一二叉树：

![image-20250123194104345](imgs\image-20250123194104345.png)

#### 前序+中序

前序：根+左+右；中序：左+根+右。所以根据三个部分对应相同可以推出。

![image-20250123194639040](imgs\image-20250123194639040.png)

根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出：前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序。因为前序序列和中序序列可以唯一地确定一棵二叉树，所以对于先序遍历的$n$个元素，可以确定卡特兰数$\dfrac{1}{n+1}C_{2n}^n$个二叉树。

#### 后序+中序

后序：左+根+右；中序：左+根+右。所以根据三个部分对应相同可以推出。

![image-20250123194901399](imgs\image-20250123194901399.png)

#### 层序+中序

层序：根+左根+右根；中序：左+根+右。所以根据根结点和左右子树的根结点来确定。

![image-20250123195456941](imgs\image-20250123195456941.png)

![image-20250123195551669](imgs\image-20250123195551669.png)

### 线索二叉树

#### 定义

对于普通的二叉树，找前驱，找后继，遍历，都只能从根结点开始

![image-20250124160832772](imgs\image-20250124160832772.png)

一棵二叉树具有n个结点，共2n个指针域，有n-1个枝杈，所以有**n+1个空白指针域**。可以使用这些指针域**记录前驱、后继信息**。

![image-20250124161608535](imgs\image-20250124161608535.png)

概念术语：

![image-20250124161848821](imgs\image-20250124161848821.png)

![image-20250124162005918](imgs\image-20250124162005918.png)

#### 代码

线索化就是要遍历一遍二叉树，然后对当前结点进行处理。

对于普通二叉树如何寻找某个结点的中序遍历的前驱：

![image-20250124184229311](imgs\image-20250124184229311.png)

创建中序遍历的线索二叉树（中序线索化）

![image-20250124184743551](imgs\image-20250124184743551.png)

![image-20250529152136504](C:\Users\21016\AppData\Roaming\Typora\typora-user-images\image-20250529152136504.png)

创建先序遍历的线索二叉树（先序线索化）

> 线索化会对前驱的右子树、当前结点的左子树添加线索指针（可能会为当前的结点添加左子树指针）
>
> 中序遍历的顺序是左根右，在遍历当前结点之前，左子树已经被遍历过
>
> 先序遍历是根左右，如果不加限制，可能会**错误的访问到线索而不是左子树**

![image-20250124185508277](imgs\image-20250124185508277.png)

![image-20250124190257171](imgs\image-20250124190257171.png)

#### 查找前驱后继

建立线索二叉树就是为了解决问题：前驱、后继、遍历

##### 以中序遍历为例

###### 怎样找后继

<img src="imgs\image-20250124194645750.png" alt="image-20250124194645750" style="zoom: 50%;" />

<img src="imgs\image-20250124194808279.png" alt="image-20250124194808279" style="zoom:50%;" />

* 如果rtag==1，说明右子树指针指向的就是后继结点
* 如果rtag==0，说明有右子树，后继结点就是右子树的最左结点

###### 延申出的顺序遍历方法

<img src="imgs\image-20250124194840158.png" alt="image-20250124194840158" style="zoom:50%;" />

###### 怎样找前驱

###### 延伸出的逆序遍历方法

![image-20250124195112283](imgs\image-20250124195112283.png)

##### 以先序遍历为例

###### 怎样找后继

![image-20250124195327730](imgs\image-20250124195327730.png)

* rtag==0，返回rchild
* rtag==1
  * ltag==0，返回lchild
  * ltag==1，返回rchild

###### 怎样找前驱

前序遍历是根左右，如果当前结点有左孩子，无法直接指向前驱，则需要找到当前结点的父结点。

所以前序遍历无法通过二叉链表找到前驱，除非从头开始遍历。

![image-20250124195517506](imgs\image-20250124195517506.png)

需要用三叉链表，找到父结点，然后有四种情况：

+ $p$为左孩子，则根据根左右，$p$的父结点为根所以在$p$的前面，$p->pre=p->parent$。
+ $p$为右孩子，其左兄弟为空，则根据根左右，顺序为根右，所以$p->pre=p->parent$。
+ $p$为右孩子且有左兄弟，根据根左右，$p$的前驱就是左兄弟子树中最后一个被先序遍历的结点
+ 若$p$是根结点，则没有先序前驱。

![image-20250126135422093](imgs\image-20250126135422093.png)

##### 以后序遍历为例

###### 怎样找前驱

![image-20250126140059994](imgs\image-20250126140059994.png)

###### 怎样找后继

后序遍历是左右根，如果当前结点有右孩子，无法直接指向后继，则需要找到当前结点的父结点。

所以后序遍历无法通过二叉链表找到后继，除非从头开始遍历。

![image-20250126140521634](imgs\image-20250126140521634.png)

需要用三叉链表，找到父结点，然后有四种情况：

+ $p$为右孩子，根据左右根，所以$p->next=p->parent$。
+ $p$为左孩子，右孩子为空，根据左右根，所以$p->next=p->parent$。
+ $p$为左孩子，右孩子非空，根据左右根，所以$p->next=$右兄弟子树中第一个被后序遍历的结点
+ 若$p$是根结点，则没有后序后继。

![image-20250126140750142](imgs\image-20250126140750142.png)

![image-20250126140952140](imgs\image-20250126140952140.png)

## 树与森林

### 树的逻辑结构

![image-20250201122557049](imgs\image-20250201122557049.png)

### 树的存储结构

#### 双亲表示法

> 找双亲很方便，找孩子要遍历

![image-20250201122731506](imgs\image-20250201122731506.png)

![image-20250201123636617](imgs\image-20250201123636617.png)

>  树的顺序存储中，结点位置和数组下标之间没有必然的联系
>
> 二叉树的顺序存储，物理结构和逻辑结构是挂钩的
>
> 但！二叉树也是树，也可以用树的这种物理结构。

* 增加结点

![image-20250201122833483](imgs\image-20250201122833483.png)

结点数 + 1

* 删除结点

  * 删除终端结点

    <img src="imgs\image-20250201122943850.png" alt="image-20250201122943850" style="zoom: 50%;" />

    

    <img src="imgs\image-20250201123007895.png" alt="image-20250201123007895" style="zoom:50%;" />

  * 删除非终端结点

​		需要删除以该结点为根结点的子树

<img src="imgs\image-20250201123349678.png" alt="image-20250201123349678" style="zoom:50%;" />

![image-20250201123512262](imgs\image-20250201123512262.png)

结点数 - 1

#### 孩子表示法

> 找孩子很方便，找双亲要遍历

![image-20250201124017798](imgs\image-20250201124017798.png)

#### 孩子兄弟表示法

使用这种方法可以实现

##### 树和二叉树的相互转换



![image-20250201124545297](imgs\image-20250201124545297.png)

![image-20250201124703128](imgs\image-20250201124703128.png)

##### 森林与二叉树的转换

![image-20250201124748332](imgs\image-20250201124748332.png)

![image-20250201124916438](imgs\image-20250201124916438.png)

### 树的遍历

+ 先根遍历：若树非空，先访问根结点，再依次对每棵子树进行先根遍历。

![image-20250201125516006](imgs\image-20250201125516006.png)

+ 后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后访问根结点。

![image-20250201125655065](imgs\image-20250201125655065.png)

+ 层次遍历：用辅助队列实现
  1. 若树非空，根结点入队。
  2. 若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队。
  3. 重复步骤二直到队列为空。

![image-20250201125812582](imgs\image-20250201125812582.png)

> **后根遍历和先根遍历** 是 **深度优先遍历**
>
> **层次遍历** 是 **广度优先遍历**

### 森林的遍历

* 先序遍历森林：相当于**从左到右先根遍历**森林里的每一棵**树**（假装所有的树的根节点在第二层，第一层是一个虚拟的根节点，然后对这棵树进行先根遍历）

![image-20250201130639092](imgs\image-20250201130639092.png)

* 中序遍历森林：相当于**从左到右后根遍历**森林里的每一棵**树**

![image-20250201130900514](imgs\image-20250201130900514.png)

|    树    |   森林   |  二叉树  |
| :------: | :------: | :------: |
| 先根遍历 | 先序遍历 | 先序遍历 |
| 后根遍历 | 中序遍历 | 中序遍历 |

> 一个森林有$n$个顶点、$e$条边，则一共有 <u>n-e</u> 棵树。
>
> * 假设有x棵树
> * 森林对应的二叉树有 n 个顶点，e+x-1 条边
> * 因此 n - 1 = e + x - 1，即 x = n - e

## 树的应用

### 哈夫曼树

+ 路径和路径长度：从树中的一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作路径长度。
+ 结点的权：有某种现实含义的数值。
+ 结点的带权路径长度：从根到该结点的路径长度（经过边数）与该结点权的乘积称为结点的带权路径长度。
+ 树的带权路径长度：树中所有**叶子**的带权路径长度之和称为树的带权路径长度$WPL=\sum_{i=1}^nw_il_i$。

![image-20250201131123536](imgs\image-20250201131123536.png)

#### 哈夫曼树的定义

+ 哈夫曼树（最优二叉树）：带权路径长度最短的二叉树。（不一定是完全二叉树）

![image-20250201131249012](imgs\image-20250201131249012.png)

#### 哈夫曼树的构造

![image-20250201131634103](imgs\image-20250201131634103.png)

+ 每个初始结点最终都会变成叶子结点，且**权值越小到根结点的路径长度越长**。
+ **哈夫曼树的结点总数为$2n-1$**。（有$n$个结点，要结合$n-1$次，每次会产生一个新的结点，所以最终树里会有$2n-1$个结点。又因为二叉树均满足 $n_0 = n_2 + 1$，所以哈夫曼树的结点总数也可以说是 $2n_2+1$）
+ 哈夫曼树**不存在度为$1$的结点**。(构建哈夫曼树时，都是两个两个合在一起的，所以没有度为一的结点，即$n_1=0$)
+ **哈夫曼树不唯一**，但是$WPL$必然最优。

#### 固定长度编码 VS 可变长度编码

![image-20250201132351772](imgs\image-20250201132351772.png)

#### 前缀编码

哈夫曼编码让字符集中的每一个字符都是**叶子结点**，这保证了**没有任何一个结点是另一个结点的前缀**

![image-20250201132545779](imgs\image-20250201132545779.png)

#### 哈夫曼编码

![image-20250201133035518](imgs\image-20250201133035518.png)

### 并查集

并查集本质上是**集合**

在集合这种逻辑结构之下，**两个元素的关系只有：属于同一个子集 和 不属于同一个子集**

> **可以用互不相交的树来表示多个集合**。（是树，不是二叉树）
>
> 用森林可以进行判断某个元素**属于哪个集合**，判断两个元素**是否属于同一个集合**等的判断。
>
> **集合**有时也需要进行**合并**操作，这也可以用森林实现

![image-20250201142145972](imgs\image-20250201142145972.png)

![image-20250201142547619](imgs\image-20250201142547619.png)

#### 存储结构

森林的三种存储方式：双亲表示法（顺序存储）、孩子表示法（顺序+链式）、孩子兄弟表示法（链式）

结合并查集出现的目的，**应该使用 双亲表示法 存储并查集**。这样，查询树的根结点（找元素属于哪一个集合、判断两个元素是否属于同一个集合）、让一棵树的双亲结点指向另一棵树的根结点（合并两个集合）都是容易实现的操作。

![image-20250201143521781](imgs\image-20250201143521781.png)

#### 代码实现

![image-20250201143630290](imgs\image-20250201143630290.png)

![image-20250201143828931](imgs\image-20250201143828931.png)

##### 时间复杂度

* 合并Union 的时间复杂度为$O(1)$
* 查找Find 的最坏时间复杂度为$O(n)$
* 合并n个只有单个元素的集合的时间复杂度为$O(n^2)$（合并$n-1$次，每次都要进行查找根元素的操作）

<img src="imgs\image-20250201143945791.png" alt="image-20250201143945791" style="zoom:33%;" />





#### Union操作的优化-小树合并到大树

查找操作的时间复杂度和树的高度有很大关联，可以**通过优化Union操作，尽量缩小树的高度，从而让Find操作实现起来更快**

优化的主要思路是，**总是把小树合并到大树上**。

![image-20250201144911094](imgs\image-20250201144911094.png)

* 优化后，Union操作的时间复杂度还是$O(1)$

* Find操作的最坏时间复杂度是$O(log_2n)$
* 合并n个只有单个元素的集合的时间复杂度为$O(nlog_2n)$（合并$n-1$次，每次都要进行查找根元素的操作）

#### Find操作的优化-路径压缩

Find操作过程中，顺手把沿途结点的父结点都设为根结点

![image-20250201150200518](imgs\image-20250201150200518.png)

![image-20250201150416899](imgs\image-20250201150416899.png)

* 优化后，Union操作和Find操作的时间复杂度都是$O(1)$
* 合并n个只有单个元素的集合的时间复杂度为$O(nα(n))$（合并$n-1$次，每次都要进行查找根元素的操作）

![image-20250201150646525](imgs\image-20250201150646525.png)
