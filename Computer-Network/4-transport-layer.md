# 传输层

![image-20250602234504738](imgs\image-20250602234504738.png)

* 用户提供**原始数据** -> 应用层根据具体应用目的**选择**是否添加**首**部 -> 传输层添加**首**部 -> 网络层添加**首**部 -> 数据链路层添加**首**部**尾**部

* 传输层需要向应用层提供服务，同时使用网络层提供的服务

![image-20250602234753754](imgs\image-20250602234753754.png)

* 网络层实现 主机到主机 的通信
* 传输层实现 端到端 的通信

## 端口号、Socket、熟知端口

![image-20250603173447564](imgs\image-20250603173447564.png)

* 各主机使用的端口号相互独立
* **TCP和UDP**使用的**端口号**也**相互独立**

* 发送进程传输层需要包含的数据 ——

  1. 发送进程的传输层**协议**
  2. 发送进程的**端口号**
  3. 接收进程的**IP地址、端口号**

  接收方会根据发送进程的传输层协议确认**接收进程**使用的**传输层协议**

* TCP和UDP都有套接字Socket，用于指定通信IP和端口号，这样不需要每次通信都包含协议、IP、端口号

![image-20250603173726513](imgs\image-20250603173726513.png)

* 端口号长度为 **16bit**，能标识的端口号是 **0-65535**

  * **特殊端口号 0-1023**，都被分配给重要的系统进程，用户进程不允许使用

  * 剩余的端口号分成服务器类和客户端类

    * 服务器端口用 1024 - 49151
    * 客户端端口用 49152 - 65535

    但这个是建议分类，可以不遵循

## 传输层功能

* 端到端传输
* 复用和分用
* 差错检测
* 向应用层提供两种服务

### 复用和分用

![image-20250603173956163](imgs\image-20250603173956163.png)

* 复用和分用 —— 对TCP/UDP**协议**进行复用和分用

![image-20250603182820011](imgs\image-20250603182820011.png)

* 复用和分用其实也发生在网络层

* IP层首部的协议字段表明当前包装了哪种协议，17表示UDP、6表示TCP

* DNS(53)、DHCP(67) 、RIP(520)使用UDP协议

  HTTP(80)、HTTPS(443)、FTP(20/21) 使用TCP协议

### 差错检测

![image-20250603174736106](imgs\image-20250603174736106.png)

* 差错检测 —— TCP和UDP都进行差错检测，都会丢弃错误的报文段
  * **TCP**丢弃后会**申请重传**（比较靠谱）
  * **UDP**丢了也**不通知**发送方（不太靠谱）

### 有连接 vs 无连接

![image-20250603175155661](imgs\image-20250603175155661.png)

* 有连接的传输 —— 建立连接 -> 数据传输 -> 释放连接

  无连接的传输 —— 数据传输

### 可靠 vs 不可靠

![image-20250603175405397](imgs\image-20250603175405397.png)

* 可靠传输 —— 接收方有接收反馈

  不可靠传输 —— 接收方无反馈，发送方也无法确认接收方到底有没有收到正确数据

* TCP —— 面向连接的，可靠的

  UDP —— 无连接的，不可靠的

![image-20250603175644091](imgs\image-20250603175644091.png)

## UDP vs TCP 

![image-20250603190410690](imgs\image-20250603190410690.png)

* UDP是无连接的
* TCP需要三次握手、四次挥手，是面向连接的

![image-20250603190530323](imgs\image-20250603190530323.png)

* UDP支持单播、组播、多播
* TCP仅支持单播

![image-20250603190745216](imgs\image-20250603190745216.png)

* UDP：每次传输一个完整的报文，不支持报文自动拆分、重装（如果报文过大，UDP直接拒绝传输）
* TCP：支持报文自动拆分、重装，因此可以传输长报文

![image-20250603191234956](imgs\image-20250603191234956.png)

* 使用IP协议的**网络层**是**不可靠**的
* UDP不可靠，TCP可靠

![image-20250603191354902](imgs\image-20250603191354902.png)

* UDP首部 —— 8B
* TCP首部 —— 20B - 60B，因为还要负责可靠传输、差错控制、流量控制等

![image-20250603191527321](imgs\image-20250603191527321.png)

## UDP

### UDP首部

![image-20250603192431087](imgs\image-20250603192431087.png)

* 端口号是16bit，可以表示的端口范围是 0-65535，通常0-1023号端口是特殊端口
* UDP首部 = 源端口(16)+目的端口(16)+总长度(16)+校验和(16)
  * 当不期待对方回复时，源端口可以为全0
  * 总长度16bit，UDP理论长度0-65535

### UDP校验

![image-20250603193256689](imgs\image-20250603193256689.png)

* 把被校验数据**16bit一组**

  1. **逐比特相加**
     * 当加法有溢出，需要“**回卷**” —— 把溢出的1加到最低位
  2. **按位取反**

  最终得到的结果就是校验位

* 接收方收到数据，把被校验数据16bit一组相加（要回卷），最后的结果和校验位相加，结果全1即无差错

![image-20250603194200564](imgs\image-20250603194200564.png)

* UDP在**首部前**有一个**伪首部**，它也参加校验

  得到校验位后，删除伪首部

  所以**伪首部不会在网络层进行传输**

![image-20250603194527555](imgs\image-20250603194527555.png)

![image-20250603194633144](imgs\image-20250603194633144.png)

* IP数据报的首部校验和也是16bit一组进行校验

  * 区别：IP数据报只校验首部，不管数据部分

    ​	   IP数据报校验数据时不会考虑伪首部	

## TCP

![image-20250603234110585](imgs\image-20250603234110585.png)

* **TCP**连接后，数据传输阶段是**全双工**模式

* **3次握手、4次挥手**

* **4次挥手 = 2 + 2次挥手**，分别是客户端宣布不再发送、服务器端宣布不再发送

  也可以是服务器端先宣布不再发送

![image-20250604171754716](imgs\image-20250604171754716.png)

* 建立**一次TCP连接**，可以**传输多个报文**

* UDP是面向报文的，TCP是面向字节流的

* **MSS** —— TCP允许承载的最大**数据部分长度**（不包括首部长度）

  TCP一次传输的数据可以不足MSS，只要不超过MSS就行

### 1）TCP的流量控制

![image-20250604190542284](imgs\image-20250604190542284.png)

* 接收方通过**滑动窗口**实现对发送方的**流量控制**

![image-20250604191235999](imgs\image-20250604191235999.png)

* **rwnd** = 当前接收方**接收窗口**的大小

  接收方累计确认时，发送ack+rwnd

  发送方根据ack确认下一时刻自己应该从哪个报文段起发，根据**rwnd和自身cwnd**调整发送窗口

* TCP用**超时重传**机制处理**丢失的数据报文**（差错检验是校验到**报文出错**，这时会主动**申请重传**）

![image-20250604191145531](imgs\image-20250604191145531.png)

* 有时，如果接收缓存已满，接收方**把rwnd设置为0**

  当接收方处理好接收数据，可以继续接收时，会发消息**提示发送方新的rwnd**

  然而，带有新的rwnd的消息可能出现报文丢失，如果不做处理，接收方一直等待接收，发送方一直窗口为0，产生**死锁**

* **零窗口探测报文** —— 发送方检测到rwnd=0，启用**持续计时器**，时间到后主动发送零窗口探测报文，询问新的rwnd

  ​				     发送方发送零窗口探测报文后，**刷新**持续计时器，时间到后继续发送零窗口探测报文

  即使零窗口探测报文丢失，下一个持续计时器结束时也会被再次发送，因此不会产生死锁（打破了循环等待）

* TCP规定，即使当前接收窗口为0，紧急报文、零窗口报文也必须被接收

![image-20250604193140759](imgs\image-20250604193140759.png)

* **swnd = min(rwnd, cwnd)**

  即 发送窗口大小 = min(接受窗口大小, 拥塞窗口大小)

![image-20250604193242880](imgs\image-20250604193242880.png)

### 2）TCP的拥塞控制

![image-20250604193446676](imgs\image-20250604193446676.png)

* 拥塞 ——  网络上的分组在增多，但吞吐量反而下降
* 应通过**拥塞控制**，尽量让拥塞控制曲线**接近理想**

![image-20250604221035475](imgs\image-20250604221035475.png)

* **拥塞窗口 = cwnd** —— 网络拥塞程度

  **接收窗口 = rwnd** —— 接收方的接收窗口大小

  **发送窗口 = swnd** —— 发送方的发送窗口大小

* 越拥塞，拥塞窗口cwnd越**小**

* 判断网络拥塞的依据 —— **超时重传**出现的频率

* ssthresh —— 慢开始门限

  * 拥塞窗口 < ssthresh —— 慢开始
  * 拥塞窗口 > sshthresh —— 拥塞避免


#### 慢开始 + 拥塞控制 ![image-20250605163234142](imgs\image-20250605163234142.png)

* 传输轮次 —— 指发送方把发送窗口的数据发送出去，接收方返回回应的一次流程

  ​		 	传输轮次的时间不是确定不变的

* 慢开始 + 拥塞控制，拥塞窗口的变化流程：

  1. 初始时，**cwnd = 1**
  2. 只要**接收方回应报文显示接受到了发送窗口的所有报文，cwnd = cwnd * 2 —— 慢开始**
  3. **cwnd = ssthresh（慢开始门限）**
  4. 只要**接收方回应报文显示接受到了发送窗口的所有报文，cwnd = cwnd + 1 —— 拥塞控制**
  5. 网络拥塞到一定程度，某次数据传输时出现了丢包，发送方需要对某些报文段进行**超时重传**了
     * **ssthresh = cwnd / 2**
     * **cwnd = 1**

* “**慢开始**”指一开始 拥塞窗口是1，**并不是指 cwnd 增长速度慢**

* “**拥塞避免**”是使用这种方式不容易拥塞，而**不是完全避免发生网络拥塞**

##### 缺点

![image-20250605164433822](imgs\image-20250605164433822.png)

* 有时即使丢包也不一定是网络拥塞
* 如果由于个边丢包，产生超时重传，让cwnd重置为1，就会降低传输效率

#### 快重传 + 快恢复

![image-20250605165250917](imgs\image-20250605165250917.png)

* 接收方不再连续确认，而是对收到的报文段**逐个确认**

  但**发送方不等确认**，依然按照自己的发送窗口发送

* 如果收到失序报文段，接收方就**重复确认**之前的确认消息

* 如果**发送方收到3个连续的重复确认**，就能得知出现了丢包，就会**直接重传**（即使此时该包的重传时间还没到）

  这样在超时重传的时限之前，发送方重新发送并接收到确认，避免了超时重传，也就**避免了cwnd重置为1**

![image-20250605171011922](imgs\image-20250605171011922.png)

* 方案1：ssthresh = 原cwnd/2

  ​	      cwnd = 原cwnd/2

  ​	      然后开始拥塞避免

* 方案2：ssthresh = 原cwnd/2

  ​	      cwnd = 原cwnd/2 + 3

  ​	      然后开始拥塞避免

![image-20250605171247730](imgs\image-20250605171247730.png)

* 如果发生了3个重复确认，快重传+快恢复
* 如果发生了超时重传，慢开始

![image-20250605171659324](imgs\image-20250605171659324.png)

* 产生超时重传，ssthresh=cwnd/2，cwnd=1，然后慢开始，当cwnd=ssthresh，拥塞控制

### 3）超时重传时间RTO 的设置

#### （1）设置 RTO 面临的问题

![image-20250605175343381](imgs\image-20250605175343381.png)

* **超时重传时间 = RTO**
* RTO的设置准则：略大于RTT

![image-20250605175317724](imgs\image-20250605175317724.png)

* 然而每个IP数据报的转发路由可能不同，各线路的速度不一致，这导致RTT也不一样

#### 加权平均往返时间 RTTs

![image-20250605175620406](imgs\image-20250605175620406.png)

* RTTs 的设置：

  1. 刚开始测量一条线路得到 RTT0，RTTs = RTT0
  2. 测量越来越多的线路，每次测量后的 RTTx，都有 **RTTs = (1-α) * 原RTTs + α * RTTx**

  最后设置**RTO略大于RTTs**就行

* α大 —— 新的RTT对RTTs影响较大

  α小 ——  新的RTT对RTTs影响不大

* **RFC6298 推荐 α = 0.125**

#### $RTO = RTT_S + 4 * RTT_D$

![image-20250605180333929](imgs\image-20250605180333929.png)

* α 的推荐值是 0.125

  β 的推荐值是 0.25

#### （2）测量 RTT 面临的问题

![image-20250605180756733](imgs\image-20250605180756733.png)

* 如果发送方发了两个报文段，接收方发了一个回复

  无法确保是对第一个的回复，还是对第二个的回复

#### Karn算法和改进

![image-20250605225101041](imgs\image-20250605225101041.png)

* Karn算法 —— 只要重传了，就丢弃这次测试，重新测试
  * 问题 —— 有些RTT很长，按照当前RTO测了很多次都要重传
  * 解决 —— 如果重传，当前RTO增大，然后重新测试（一般增大方式是2倍）

![image-20250605230858759](imgs\image-20250605230858759.png)

### 4）TCP的可靠传输

![image-20250605231249075](imgs\image-20250605231249075.png)

* 后沿不可能后退（不能撤回已确认的回复）
* 前沿则都有可能

![image-20250605231413624](imgs\image-20250605231413624.png)

* 发送方通过**3个指针**标明发送状态

![image-20250605231921413](imgs\image-20250605231921413.png)

![image-20250605232103888](imgs\image-20250605232103888.png)

![image-20250605232158882](imgs\image-20250605232158882.png)

### 5）TCP三次握手

![image-20250605233251287](imgs\image-20250605233251287.png)

* 客户端 **请求连接**消息 

  ​	-> 服务器 **连接接受**消息

  ​		-> 客户端 **普通确认**消息

* 全双工通信，所以**双方都要发送自己的初始序号**

  seq = x 表示客户端的初始序号

  seq = y 表示服务器的初始序号

* **请求连接/连接接受**报文，都**不允许携带数据**，但**消耗1个序号**

  所以请求连接的 seq = x，连接接受的 ack = x + 1

  ​	连接接收的 seq = y，普通确认的 ack = y + 1

![image-20250605233717237](imgs\image-20250605233717237.png)

* 第三次握手，是有必要的

  防止已失效的连接请求被服务器响应，占用服务器资源

![image-20250605234130052](imgs\image-20250605234130052.png)

### 6）TCP四次挥手

![image-20250605235337364](imgs\image-20250605235337364.png)

* 4挥手 = 2 + 2次挥手

  先挥手（FIN = 1）意味着自己已经没有数据要发送了

  没主动挥手的一方，仍然可以发送消息

* **请求释放**报文，**不允许携带数据**，但**消耗1个序号**

* **服务器**四次挥手后**立即断开**

  **客户端**四次挥手后**等待2MSL后断开**

![image-20250606172608942](imgs\image-20250606172608942.png)

* 客户端等待2MSL
  * 保证四次挥手的完整性
  * 保证本次TCP连接传输的所有数据都已离开网络，新一轮连接不会出现旧报文段

![image-20250606172916668](imgs\image-20250606172916668.png)

* **保活计时器** —— 防止由于客户端故障，持续占用服务器资源

### 3）TCP报文段格式

#### （1）源端口、目的端口

![image-20250604195911202](imgs\image-20250604195911202.png)

#### （2）序号seq、确认号ack、字段ACK

![image-20250604194833333](imgs\image-20250604194833333.png)

* **序号 = seq** —— 数据部分首部的编号，用于字节流的拆装

  * 发送方自行设置序号，不一定从0开始

    例如，发送方规定第一个发送的TCP报文段，数据部分的编号是500，则第一个报文段的序号就填500

![image-20250604194939661](imgs\image-20250604194939661.png)

* **确认号 = ack = ack_seq** ——期待的数据部分编号

![image-20250604195012577](imgs\image-20250604195012577.png)

* 首部还有字段**ACK**，**当ACK=0时，确认号无效**

![image-20250604195200332](imgs\image-20250604195200332.png)

* 序号和确认号各占32bit，因为TCP支持全双工通信，双方可能边发边收

#### （3）数据偏移、填充、保留

![image-20250604195446716](imgs\image-20250604195446716.png)

* **数据偏移** —— 占**4bit**，以**4B为单位**表示**首部长度**

  所以首部最后要有**填充**字段凑足4B的整数倍

* IP有418首总偏，TCP只有4首

![image-20250604195742445](imgs\image-20250604195742445.png)

* 保留 —— 无意义

#### （4）窗口、校验和

![image-20250604200154145](imgs\image-20250604200154145.png)

* 即 rwnd（接收窗口） 值
* swnd = min(rwnd, cwnd)

![image-20250604215317845](imgs\image-20250604215317845.png)

* 和UDP一样的校验方式，也要加上伪首部后校验，校验后删除伪首部（两者的区别是伪首部内容略有不同）

#### （5）标志位 

###### SYN、FIN

![image-20250604215431840](imgs\image-20250604215431840.png)

* SYN —— SYN=1时，表明是一个连接请求/连接接受报文

  此时若 ACK=0 代表这是一个连接请求报文，若 ACK=1 代表这是一个连接接受报文

![image-20250604215607430](imgs\image-20250604215607430.png)

* FIN —— 四次挥手时，打招呼释放连接

* SYN段 —— SYN=1的段，即三次握手的第1、2个段

  FIN段 —— FIN=1的段，即四次挥手的第1、3个段

  ACK段 —— ACK=1的段，即ACK有效段（除了三次握手的第1段，其它都是ACK段）

###### RST

![image-20250604215725947](imgs\image-20250604215725947.png)

* RST —— 提醒断开连接

###### PSH

![image-20250604215818088](imgs\image-20250604215818088.png)

* PSH —— 接收方收到后直接给进程，不要等缓冲区满

###### URG、紧急指针

![image-20250604220056381](imgs\image-20250604220056381.png)

* URG —— URG=1时表明紧急指针有效
* 紧急指针 —— 指明紧急数据的长度，发送方会优先发送紧急数据





















