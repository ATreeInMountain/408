# 概述

## 操作系统的定义

![image-20250318203142331](imgs\image-20250318203142331.png)

## 操作系统的功能

### 1）系统资源的管理者

![image-20250318203333203](imgs\image-20250318203333203.png)

### 2）为上层提供方便易用的服务

![image-20250318203645026](imgs\image-20250318203645026.png)

* 封装，屏蔽下层硬件实现的细节

![image-20250318205630791](imgs\image-20250318205630791.png)

* 联机命令接口 = 交互式命令接口

* 脱机命令接口 = 批处理命令接口

* **程序接口 = 系统调用 = 广义指令**

* 用户接口不包含GUI

### 3）最接近硬件的一层软件：

![image-20250318210612161](imgs\image-20250318210612161.png)

* 操作系统是系统**软件**

* 组织硬件协调配合，实现更复杂的功能

### 定义和功能总结

![image-20250318210744667](imgs\image-20250318210744667.png)

## 操作系统的四个特征

* 并发、共享、虚拟、异步
* 并发和共享是两个最基本的特征，两者互为存在条件

### 并发

![image-20250318211152574](imgs\image-20250318211152574.png)

+ 一个CPU同一时刻只能执行一个程序
+ 操作系统和并发是一同诞生的，**并发是操作系统最基本的特性**

### 共享

![image-20250318211523715](imgs\image-20250318211523715.png)

+ 共享：资源共享
  + 互斥共享方式
  + 同时共享方式（宏观同时，微观交替）

+ 有时候可能是真的“同时”，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见

![image-20250318211849900](imgs\image-20250318211849900.png)

* 并发和共享互为存在条件

### 虚拟

![image-20250318212204125](imgs\image-20250318212204125.png)

* 虚拟：假装存在
  * 时分复用技术 —— 虚拟处理器（进程并发执行，就好像有多个CPU在执行这些进程）
  * 空分复用技术 —— 虚拟存储器（进程并发执行，就好像它们都装在内存里）

* 没有并发性，就谈不上虚拟性

### 异步

![image-20250318212725398](imgs\image-20250318212725398.png)

+ 异步：因为资源争用，进程的执行走走停停，以不可预知的速度向前推进
+ 只有系统拥有并发性，才会导致异步性

### 操作系统特征总结

![image-20250318212906267](imgs\image-20250318212906267.png)

## 操作系统的发展历史

### 手动操作阶段

![image-20250318213200354](imgs\image-20250318213200354.png)

+ 独占全机、人机速度矛盾

### 单道批处理系统

![image-20250318213350432](imgs\image-20250318213350432.png)

* 外围机 把 要执行的所有程序 存到磁带里

+ 优：磁带的读写比打孔纸快，所以一定程度上优化了人机速度矛盾

  缺：单道批处理程序只能串行执行，$CPU$大量时间用于等待$I/O$

### 多道批处理系统

![image-20250318213853511](imgs\image-20250318213853511.png)

+ 操作系统正式诞生

+ 程序流水线，宏观上看算并发（操作系统和并发、共享一起诞生）

+ 优：资源利用率提高

  缺：没有人机交互，不能中途控制执行的程序

### 分时操作系统

![image-20250318221111212](imgs\image-20250318221111212.png)

+ 时间片

+ 优：解决人机交互问题；多个用户共同使用一台计算机，且感受不到其他人存在

  缺：时间片的分配绝对公平，不能优先处理紧急任务

### 实时操作系统

![image-20250318221352996](imgs\image-20250318221352996.png)

+ 能优先响应紧急任务，不用等待时间片排队
+ 及时、可靠
+ 分类：
  + 硬实时系统：动作必须绝对在指定时间内完成
  + 软实时系统：可以接受偶尔违反规定

### 其他操作系统

![image-20250318221646640](imgs\image-20250318221646640.png)

+ 网络操作系统、分布式操作系统、个人计算机操作系统

### 发展历史总结

![image-20250318221748920](imgs\image-20250318221748920.png)

## 操作系统运行机制

### 内核程序 VS 应用程序

![image-20250318222048299](imgs\image-20250318222048299.png)

* 应用程序 —— 写应用软件

  **内核程序 —— 写操作系统内核**

* 操作系统 = 内核 + 其他

  内核是操作系统最重要的部分

### 特权指令 VS 非特权指令

![image-20250318222454106](imgs\image-20250318222454106.png)

* 特权指令 —— 只有内核程序才能使用的指令

  非特权指令 —— 内核程序、应用程序都能用的指令

* CPU 能自动判断特权指令和非特权指令

### 内核态 VS 用户态

![image-20250318222703861](imgs\image-20250318222703861.png)

* 内核态 —— CPU 当前正在执行内核程序

  用户态 —— CPU 当前正在执行应用程序

+ 区分内核态和用户态 —— 程序状态字寄存器$PSW$中的某标志位（修改这个标志位的指令是特权指令）

+ 在用户态检测到了特权指令 —— 引发**中断信号**，停止运行当前应用程序，**回到内核态**

  ​							操作系统对当前情况进行处理，**处理完让其它应用程序运行**

+ 内核态 = 核心态 = 管态

  用户态 = 目态

### 内核态 <-> 用户态切换

![image-20250318223451778](imgs\image-20250318223451778.png)

* 内核态 -> 用户态：

  使用特权指令，修改PSW中的标志位为用户态

* 用户态 -> 内核态：

  触发中断信号，让操作系统夺回CPU使用权（比如使用特权指令，除0操作等）

* 开机时 CPU 处于内核态

  开机结束进入用户态

  用户态触发中断信号变回内核态

  内核态处理完错误，再进入用户态

  ......

### 运行机制总结

![image-20250318224110015](imgs\image-20250318224110015.png)

## 中断和异常

* **中断 是CPU从用户态切换到内核态的唯一方式**

  CPU 在用户态时触发了中断信号，操作系统会夺回CPU使用权，CPU 变成内核态

* 如果**没有中断**技术，当前运行的应用程序会一直运行，**不可能实现并发**

### 内中断 VS 外中断

* 内中断 —— 与当前执行的**指令**有关，中断信号来自**CPU内部**
  * 陷入指令 —— 应用程序主动中断（系统调用），是非特权指令
  * 故障 —— 可修复的，如缺页中断
  * 终止 —— 不可修复的，如使用特权指令或非法的非特权指令

* 外中断 —— 与当前执行的指令无关，中断信号来自**CPU外部**

  <img src="imgs\image-20250318225419672.png" alt="image-20250318225419672" style="zoom:50%;" />

  * 时钟中断 —— 时钟部件按时发出中断信号，实现进程的时间片轮换，从而实现并发
  * I/O中断 —— I/O设备完成了CPU发出的指令，给CPU一个结束信号

![image-20250318225855745](imgs\image-20250318225855745.png)

* 异常 —— 通常内中断也称叫异常

  中断 —— 通常“中断”就指的是外中断

* 每个**指令周期的末尾**，计算机都会**检查外中断**（内中断在执行指令的时候就自动检查了）

### 中断机制的基本原理

![image-20250318230130103](imgs\image-20250318230130103.png)

* 不同的中断产生**不同的中断信号**

  根据中断信号查**中断向量表**，找到对应的**中断处理程序起址**，然后运行对应的中断处理程序

* **中断处理程序是内核程序**

### 中断和异常的总结

![image-20250318230625881](imgs\image-20250318230625881.png)

## 系统调用

### 系统调用的作用

![image-20250322230341183](imgs\image-20250322230341183.png)

* 用户和操作系统交互：**GUI、命令接口、程序接口** 

  应用程序和操作系统交互：**程序接口** 

* 程序接口由一组**系统调用**组成，通过系统调用请求**操作系统内核服务**

![image-20250322231138217](imgs\image-20250322231138217.png)

* 用**低级语言、高级语言的库函数**可以直接访问系统调用

  有些库函数不使用系统调用（比如只封装了算数运算的库函数，不需要访问操作系统内核）

![image-20250322231347994](imgs\image-20250322231347994.png)

* 系统调用的作用：

  操作系统内核 对 共享资源 进行统一的管理

  **用户进程通过系统调用，向操作系统内核发送访问共享资源的请求**

  操作系统内核对各个请求协调处理

### 应用程序怎样实现系统调用

![image-20250322232428887](imgs\image-20250322232428887.png)

1. 传参（指定哪个系统调用程序，以及执行这个系统调用程序需要的所有参数）
2. 陷入指令，引发内中断
   * CPU从用户态转成内核态，找到对应的系统调用程序地址
   * CPU根据传递的参数，执行系统调用程序
   * CPU执行完，返回应用程序，回到用户态

* 陷入指令 = trap指令 = 访管指令
* 陷入指令只能在用户态执行，不能在内核态执行

![image-20250322232553637](imgs\image-20250322232553637.png)

## 操作系统体系结构

* 即怎样设计操作系统内核

  操作系统 = 非内核 + 内核

![image-20250322232911476](imgs\image-20250322232911476.png)

* 内核组成部分：

  1. **必须放在内核中的模块**：**时钟**管理、**中断**管理、**原语**


  1. **可以不在内核里保留的模块**：进程管理、存储器管理、设备管理等

  2. 大内核 —— 时钟管理、中断处理、原语、进程管理、存储器管理、设备管理 在内核

  ​		     大内核 = 宏内核 = 单内核

* 微内核 —— 时钟管理、中断处理、原语 在内核

### 大内核、微内核

![image-20250322233542947](imgs\image-20250322233542947.png)

宏内核：

* 优：**性能高**，内核各部分功能（进程管理、存储管理、设备管理）可以**直接相互调用**（因为都在内核里）

  缺：内核庞大复杂**难以维护**；内核某个功能出错可能导致整个**系统崩溃**

微内核：

* 优：内核小**易于维护**；内核某个功能出错**不会系统崩溃**

  缺：**性能低**，需要频繁切换用户态/核心态；用户态下**各功能模块不能直接相互调用**，只能通过内核的”消息传递“来间接通信

![image-20250322233725200](imgs\image-20250322233725200.png)

### 分层结构

![image-20250322234552353](imgs\image-20250322234552353.png)

* 优：逐层调试方便；易扩充易维护（只需要保证接口吻合）

  缺：分层难（只允许高调低，而有些功能需要互相调用）；调用时间长（不能跨层调用）

### 模块化

![image-20250331175004697](imgs\image-20250331175004697.png)

* 内核 = 主模块 + 可加载内核模块

* 优：逻辑清晰易于维护，可以多模块同时开发（只要定义好每个模块的接口）；

  ​	易扩充，支持动态加载新的内核模块；
  
  ​	调用效率高（任何模块都可以直接调用其他模块，不需要像分层结构一样消息传递）
  
  缺：定义模块接口难
  
  ​	难以调试（模块之间相互依赖）

* **分层结构是一种特殊的模块化**，特殊之处在于依赖关系是单向的，这也给分层结构带来了设计困难，但是易于调试的特点

### 外核

如果使用这种结构，则 **操作系统 = 内核 + 外核**

![image-20250331181000888](imgs\image-20250331181000888.png)

* 抽象：分配不连续的存储空间，映射成连续的虚拟空间给用户进程/文件

* **外核** —— 给用户进程**分配未经抽象的系统资源**，并保证这些资源被安全使用

* 优：用户进程对硬件资源的使用更灵活（使用的不再是虚拟的连续空间，而是真的连续空间，访问连续数据的速度变快）；

  ​	没有映射层，提高了资源访问效率

  缺：降低了系统一致性；

  ​	系统变复杂

### 操作系统结构总结

![image-20250331181037818](imgs\image-20250331181037818.png)

## 操作系统引导

### 安装了OS的磁盘组成

* 安装了操作系统的磁盘 —— MBR + C盘 + D盘 + 其他分盘

  * 主引导记录 MBR —— 磁盘引导程序 + 分区表

    分区表记录C、D、其他盘占据的磁盘地址和空间大小

  * C盘 —— PBR + 根目录 + 其他

    操作系统安装在C盘，所以C盘也称为活动分区

### 操作系统引导（开机过程）

* 内存 = RAM + ROM
  * 其中ROM是 基本输入输出系统BIOS，包含ROM引导程序，即自举程序。
  * ROM的特点是只读，大多数ROM不会断电即失

![image-20250401161437493](imgs\image-20250401161437493.png)

1. CPU从固定的位置取指令，执行**BIOS**的自举程序
   * 自举程序 —— 先硬件自检（磁盘、内存条），然后开机
2. 把**MBR**读入内存，执行磁盘引导程序，扫描分区表找到活动分区
3. 从活动分区找到**PBR**读入内存，执行其中的程序
4. 从根目录中找到**启动管理器**（操作系统初始化程序）读入内存，执行程序，完成一系列开机操作

## 虚拟机

* 把**一台物理机器** 虚拟化为 **多台虚拟机器**

  每台虚拟机器上都可以 **独立运行一个操作系统**

* 虚拟物理机器的工具：

  虚拟机管理程序 = 虚拟机监控程序 = VMM = Hypervisor

![image-20250401163512215](imgs\image-20250401163512215.png)

* **第一类VMM —— 直接划分硬件**，每个虚拟机器有独立的硬件资源

  （CPU划分时间片；内存、磁盘划分空间）

  * 第一类VMM运行在**操作系统层面**，VMM运行在内核态
  * 虚拟机器的操作系统运行在用户态，它发出的特权指令会被VMM截获和处理

* 第二类VMM —— **请求宿主操作系统分配硬件资源**

  它分配的硬件资源是经过宿主操作系统抽象的，而这些资源可能又被VMM抽象分配给虚拟OS，所以虚拟OS的硬件资源访问慢

  * 第二类VMM运行在**应用程序层面**，VMM大部分运行在用户态，小部分运行在内核态
  * 虚拟机器的操作系统也运行在用户态，它发出的特权指令会被VMM截获，转化成VMM对宿主OS的系统调用

![image-20250401164416573](imgs\image-20250401164416573.png)

* 最高特权级 —— 把特权指令划分等级，最高特权级是Ring0，然后是Ring1...

  ​			     这样做的好处是划分更精细，应用程序可以最大程度的自己处理需求，访问OS的频度下降

* 第一类VMM权限更大，性能更好，但可迁移性差；第二类VMM正好相反









