# 内存管理

![image-20250415160055845](imgs\image-20250415160055845.png)

* **存储单元&地址 是一一对应的**

* **计算机按什么编址，指示了存储单元的大小**

  例如计算机“按字节编址”，指一个存储单元有1B的存储元

## 装入、链接

### 程序运行过程

![image-20250415163022542](imgs\image-20250415163022542.png)

* 程序运行过程：

  1. 编译：高级语言 -> 低级语言
  2. 链接：链接模块、库函数，形成一个完整的装入模块（装入模块 = 可执行文件，例如.exe文件）
  3. 装入（装载）：由装入程序将装入模块装入内存
  4. 执行

* 程序指令中的地址是逻辑地址（相对地址，基址是程序起址）

  问题：1. 程序各个模块组合，生成完整的逻辑地址（链接的任务）

  ​	   2. 逻辑地址 -> 物理地址（装入的任务）

### 三种链接方式（完整逻辑地址）

![image-20250415163149348](imgs\image-20250415163149348.png)

* 静态链接 —— 生成一个装入模块，形成所有的逻辑地址

![image-20250415163303656](imgs\image-20250415163303656.png)

* 装入时动态链接 —— 链接和装入同时进行（没有装入模块）

  ​				    在链接、装入时，生成完整的逻辑地址

![image-20250415163610403](imgs\image-20250415163610403.png)

* 运行时动态链接 —— 运行、链接、装入同时进行

  ​				     运行时需要的模块，才会被链接和装入（灵活，节省内存空间）

### 三种装入方式（逻辑->物理地址）

![image-20250415153641998](imgs\image-20250415153641998.png)

* 绝对装入 —— .exe里是物理地址

  ​			在**编译**时，知道程序运行时的内存地址，直接把逻辑地址转换成物理地址，然后翻译成.exe

* 缺：缺乏动态重定位，程序移植困难

![image-20250415155044210](imgs\image-20250415155044210.png)

* 可重定位装入(静态重定位) —— .exe里是逻辑地址，内存里是物理地址

  ​							不改变逻辑地址，翻译成.exe文件，**装入**内存时把逻辑地址转化成物理地址

* 缺：必须一次分配整个程序内存空间；程序运行期间不能移动

![image-20250415155752078](imgs\image-20250415155752078.png)

* 动态运行时装入(动态重定位) —— .exe里是逻辑地址，内存里是逻辑地址，运行时是物理地址

  ​							有专门的重定位寄存器，存放程序起址。在**执行**时CPU负责根据基址和逻辑地址获得物理地址

* 优：程序运行时可以在内存移动；允许不分配连续空间；允许一次装入部分代码；实现虚拟存储

![image-20250415164230876](imgs\image-20250415164230876.png)

## 操作系统-内存管理-四个任务

![image-20250429133735198](imgs\image-20250429133735198.png)

### 1. 内存空间的分配和回收

![image-20250415165145899](imgs\image-20250415165145899.png)

#### 1）连续分配管理方式

* 连续分配 —— 系统为用户分配的必须是连续的内存空间

* 内存 = 系统区 + 用户区

  系统区 —— 存放操作系统相关数据

  用户区 —— 存放用户进程相关数据

##### i. 单一连续分配

![image-20250424125908687](imgs\image-20250424125908687.png)

* 单一分区分配 —— 用户区同一时刻只能有一道用户进程（不支持多道程序并发）

  优：无外部碎片，不一定需要内存保护（用户区只有一个进程，不担心进程间越界访问，系统区也不需要保护，重启即可恢复）

  缺：有内部碎片，不支持多道程序并发

##### ii. 固定分区分配

![image-20250424140651257](imgs\image-20250424140651257.png)

![image-20250424142732815](imgs\image-20250424142732815.png)

* 固定分区分配 —— 把用户区划分成**固定**的分区，每个分区能且**仅能放入一个**作业（允许多道程序并发）

  * 分区大小相等

    优：无外部碎片，适用于一台计算机控制**多个相同对象**的场合

    缺：不灵活，对于占用区域小的进程会产生内部碎片，对于占用区域大的进程放不下（即使内存剩余空间足够）

  * 分区大小不等 —— 需要用**分区说明表**记录每个分区的起址、分区大小、分配状态

    优：无外部碎片，灵活，可以满足不同大小的进程需求

    缺：也可能产生内部碎片，对于占用区域大的进程也可能放不下（即使内存剩余空间足够）

##### iii. 动态/可变 分区分配

![image-20250424152914353](imgs\image-20250424152914353.png)

* 动态分区分配 —— 分区的大小和数目**动态可变**

  优：更灵活，无内部碎片

  缺：有外部碎片

* 解决外部碎片 —— **紧凑/拼凑**

  带紧凑技术的系统，程序装入内存时最好用**动态重定位**的装入方式

  紧凑之后，需要修改进程PCB里的**基址**

###### 问题1：分区记录方式

* 空闲分区表 or  空闲分区链

![image-20250424143752854](imgs\image-20250424143752854.png)

* 空闲分区表 —— 空闲分区的起址 + 分区大小[ + 分配状态]

  空闲分区链 —— 通过指针指向上一个和下一个空闲分区

###### 问题2：分配、回收分区

* 分配情况1 —— 分配（进程5），空闲区域**大于**请求空间

  空闲区个数不变，起址和大小改变

  ![image-20250424144247042](imgs\image-20250424144247042.png)

* 分配情况2 —— 分配（进程5），空闲区域**等于**请求空间

  空闲区个数-1

  ![image-20250424144356901](imgs\image-20250424144356901.png)

* 回收情况1 —— 回收（进程4），进程前满后空

  空闲分区数目不变，后空的起址和大小改变

  ![image-20250424144452963](imgs\image-20250424144452963.png)

* 回收情况2 —— 回收（进程3），进程前空后满

  空闲分区数目不变，前空的大小改变

  ![image-20250424150519239](imgs\image-20250424150519239.png)

* 回收情况3 —— 回收（进程4），进程前空后空

  空闲分区个数-1（三个空闲分区合并）

  ![image-20250424150634487](imgs\image-20250424150634487.png)

* 回收情况4 —— 回收（进程2），进程前满后满

  空闲分区个数+1

  ![image-20250424150840608](imgs\image-20250424150840608.png)

* 空闲分区表的分区，可能按照 起址/分区从大到小/分区从小到大 排序

###### 问题3：分配哪个空闲分区

* 每次分配完，需要刷新空闲分区表/空闲分区链

1. 首次适应算法
   * 空闲分区表/空闲分区链 按地址从小到大 顺序记录空闲分区
   * 找 **满足要求的最低地址分区**，然后分配
2. 最佳适应算法
   * 空闲分区表/空闲分区链 按区块容量递增 顺序记录空闲分区
   * 找 **满足要求的最小分区**，然后分配
3. 最坏适应算法/最大适应算法
   * 空闲分区表/空闲分区链 按区块容量递减 顺序记录空闲分区
   * 找到第一个空闲分区（**最大分区**），然后分配
4. 邻近适应算法
   * 空闲分区表/空闲分区链 按地址从小到大 顺序记录空闲分区
   * 找 **下一个满足要求的分区**，然后分配（类似于首次适应算法，只是不是每次从最低地址寻找，而是从上次查找结束的位置开始）

* 最佳适应算法和最坏适应算法，每次分配完可能要对空闲分区表/链进行重新排序，算法开销比较大
* 首次适应算法的性能相对最佳

![image-20250424153226856](imgs\image-20250424153226856.png)

![image-20250424162252898](imgs\image-20250424162252898.png)

#### 2）非连续分配管理方式

* 为用户进程分配的可以是一些离散的内存区域

##### i. 基本分页存储管理

###### 分页存储

![image-20250425143118541](imgs\image-20250425143118541.png)

* **页框/页帧/内存块/物理块/物理页面** —— ***内存在物理上***分成的大小相等的区域

  页框号从0开始

* **页/页面** —— ***进程在逻辑上***分成和页框大小相等的区域

  页号从0开始

* **进程的页**会放到**内存的页框**当中，页面和页框是**一一对应**的关系

![image-20250425143240181](imgs\image-20250425143240181.png)

* 每个进程有一张页表

* 页表 —— 存储 页号 与 页框号  的一一对应关系

  每一个页表项，存储一个对应关系

* **页表在进程的PCB里**

![](imgs\image-20250425143657181.png)

* 每个**页表项只需要记录页框号**/页帧号/内存块号/物理块号/物理页面号

  因为页表项连续存储，**页号/页面号是隐含的**

* 如果有 $2^{20}$ 个页框，则页框号至少要 20bit ，至少要 3Byte

  此时，查找页号为 i 的进程页，就在页表项的 起址+3*i 处查看对应的物理块号

* **页表中存的是内存块号，而不是内存起始地址**

  内存起始地址 = 内存块号 * 页框大小

###### 逻辑地址 -> 物理地址

![image-20250425145029960](imgs\image-20250425145029960.png)

* 为了方便计算页号、页内偏移量、页面大小一般设为 **$2$的整数幂**

  如果每个页面大小为$2^kB$，用二进制数表示逻辑地址，则**末尾$k$位即为页内偏移量**，其余部外就是页号

* 逻辑地址 —— 进程页号 + 页内偏移量

  * 进程页号 = 逻辑地址 / 页面大小
  * 页内偏移量 = 逻辑地址 % 页面大小

* 物理地址 —— 页框起址(页框号*页框大小) + 页内偏移量

![image-20250425145927399](imgs\image-20250425145927399.png)

###### 基本地址变换机构(查页表)

![image-20250428225139959](imgs\image-20250428225139959.png)

* **页表寄存器 PTR** —— CPU内部，用于存储当前正在运行进程的 **页表起址F** 和 **页表长度M**

  页表，页表起址F 和 页表长度M 存放在进程的PCB里，当进程被调度，F 和 M 被放到 PTR

  页表长度 = 页表项的个数

* 进程的 **PCB** 是操作系统管理的数据结构，存放在**内存里的系统区**

![image-20250428224946523](imgs\image-20250428224946523.png)

* **页表长度** = 页表项个数

  **页表项长度** = 一个页表项的存储空间大小

  **页面大小** = 一个页面的存储空间大小

* 逻辑地址  -> 物理地址：

  1. 拆分逻辑地址 A，拆出页号 P、页内偏移量 W（页面大小为 L）

     * P = A / L

     * W = A % L 

  2. 判断页号越界（页表长度为 M）
     * P ≥ M 则越界，因为页表项索引从0开始

  3. 找到对应的页表项地址，取出物理块号（页表起址 F）
     * 页表项地址 = F + P * 页表项长度
     * 取出页表项里存储的物理块号 b

  4. 物理地址 E = b * L + W

  5. 访问物理地址 E 

例题：

![image-20250428231901781](imgs\image-20250428231901781.png)

* 页内偏移量占10位 = 页表项长度是10位 = 页面大小是$2^{10}$个存储单元
* 页式管理中的地址是**一维**的，用户只需提供一个逻辑地址，无需像段式管理那样显式指定段号和段内偏移量。系统通过页面大小自动完成地址分解。

![image-20250428232048978](imgs\image-20250428232048978.png)

* **页表是连续存储**在PCB的

  方便根据页号查询页表项 （页表项 = 页表起址 + 页号 * 页表项长度）

* 为了方便查询页表，会尽量使每个页面**恰好装满**页表项

  例如一个页表项有20bit大小，其实只需要3B，但是为了恰好装满页面，一般会让它占4B	

![image-20250428233051100](imgs\image-20250428233051100.png)

* 单级页表 —— 访问内存两次（访问页表 + 访问目标内存单元）

###### 基本地址变换机构(查快表)

![image-20250428233427594](imgs\image-20250428233427594.png)

* **快表 = 联想寄存器 = TLB**，存储在**专门的高速缓存**

  快表空间更小，是最近访问页表项的副本

* **慢表 = 页表**，存储在内存

![image-20250428235422657](imgs\image-20250428235422657.png)

* 当**进程切换**的时候，快表的内容也会被**清除**

* 引入快表之后，地址转换流程 —— 

  1. 拆分 逻辑地址

  2. 判断页号越界
  3. 查快表

  [ 4. 查页表

  5. 把该未命中的页表项存入快表]
  6. 取出物理块号，计算物理地址
  7. 访问物理地址

* 由于**局部性原理**，快表命中率高

* 计算快表查找效率时，要注意系统**是否支持快慢表同时查找**

局部性原理：

![image-20250429000432025](imgs\image-20250429000432025.png)

* 局部性原理，所以快表可以大幅提升查询速度

![image-20250429000518551](imgs\image-20250429000518551.png)

* 没有快表：

  访存两次（访问页表 + 访问目标内存单元）

* **引入快表**的查询：

  * 命中：访问快表一次，访存一次（访问目标内存单元）
  * 没命中、不支持快慢表同时查找：访问快表一次，访存两次（访问页表 + 访问目标内存单元）
  * 没命中、支持快慢表同时查找：访存两次（访问页表 + 访问目标内存单元）

* TLB是**专门**用来存储页表项副本的，不是普通的Cache

###### 多级页表

![image-20250429001743436](imgs\image-20250429001743436.png)

* 单级页表的问题：

  1. 页表太大，而且需要连续存储（多级页表）
  2. 局部性原理，没必要整个页表常驻内存（虚拟存储技术）

* 两级页表 —— 对页表再分页

  外层 ：**页目录表/外层页表/顶层页表**

  内层：二级页表

![image-20250429003146446](imgs\image-20250429003146446.png)

* **页目录表 = 顶层页表 = 外层页表**

* 32bit 的地址，页面大小是4KB，每个页表项大小是4B

  * $4KB = 2^{12}B$，页内偏移量占12bit

  单级页表：20 + 12

  * $4KB / 4B = 1K$，一页存储1K个页表项
  * $2^{20} / 1K = 1K$，单级页表被划分成 1K 个页面存储
  * $1K / 1K = 1$，需要用 1 个页面存储下一级页表的目录，所以这是顶级页表

  两级页表：10 + 10 + 12

![image-20250429003332700](imgs\image-20250429003332700.png)

* 两级页表地址变换流程 —— 

  1. 拆分 逻辑地址

  2. 判断顶层页号越界
  3. 查顶层页表，找到二级页表的物理块号
  4. 查二级页表，找到数据的物理块号
  5. 访问物理地址

![image-20250429004038913](imgs\image-20250429004038913.png)

* **多级页表**注意事项：
  * **各级页表的大小不能超过一个页面**
  * 访存次数
* 多级页表比单级页表访存次数更多，所以访问数据速度更慢（时间换空间）
* 多级页表会使用页表基址寄存器（$PTBR$）来存储页表基址，此时$PTBR$会存储当前进程的一级页表的物理地址

![image-20250429004229186](imgs\image-20250429004229186.png)

#####  ii. 基本分段存储管理

![image-20250429004430152](imgs\image-20250429004430152.png)

* 分段存储 —— 按照程序自身逻辑分段（程序可读性更高）

  段名(易读) -> 段号(计算机标识)，编译程序实现

* **每个段**在内存中占据**连续空间**，但各段之间可以不相邻

* 每段从0开始编址

![image-20250429005837949](imgs\image-20250429005837949.png)

* 段式存储，**逻辑地址 = 段号**(通过段名映射得到) + **段内地址**(通过变量名映射得到)

  **段号的位数**决定了每个进程最多可以分几个段

  **段内地址的位数**决定了每个段最大长度

![image-20250429010533927](imgs\image-20250429010533927.png)

* 使用页表 —— 逻辑页号 -(页表)> 物理页号 -(计算)> 页物理基址

  **页式管理**中的地址是**一维**的，用户只需提供一个**逻辑地址**，就能得到物理地址

* 使用段表 —— 逻辑段号 -(段表)> 段基址

  **段式管理**中，地址是**二维**的（需显式提供**段号**和**段内偏移**）

* 段表的属性 —— 段号、段基址、段长

  ​			     段号是隐式的

* 段表项长度 —— 段基址 + 段长

  各段长可能不相同，但各段表项长度相同

  * 段基址 —— 物理内存地址有多少位，段基址就占多少位
  * 段长 —— 逻辑地址 = 段号 + 段内地址，段内地址的位数就是段长的位数

* **段表寄存器** —— CPU内部，用于存储当前正在运行进程的 **段基址F** 和 **段表长度M**

  段表，F 和 M 都存放在进程的**PCB**里，当进程被调度，F 和 M 被放到 段表寄存器

  段表长度 = 段表项个数，即该程序有多少个段

![image-20250429123454782](imgs\image-20250429123454782.png)

* 段式存储，地址转换流程 —— 

  1. 拆分 逻辑地址，拆出段号、段内偏移量

  2. 判断段号越界

  3. 找到对应的页表项地址，取出段基址、段长
  4. **判断段长越界**
  5. 物理地址 = 段基址 + 段内偏移量
  6. 访问 物理地址

![image-20250429131332107](imgs\image-20250429131332107.png)

* 分页对用户不可见

  分段对用户可见

* 页长固定，由系统决定

  段长不固定，由编程人员决定

* 分页是一维的，给出逻辑地址

  分段是二维的，给出段号(段名)+段内地址(变量名)

* 分段有利于信息共享和保护

  * 进程共享的段，必须是纯代码或可重入代码（不属于临界资源，可以共享）

  分页时页面不是按逻辑模块划分的。这就很难实现共享

* 单级页表 访存两次；有快表，访存一次

  分段 访存两次；有快表，访存一次

![image-20250429131520885](imgs\image-20250429131520885.png)

##### iii. 段页式存储管理

![image-20250429131648877](imgs\image-20250429131648877.png)

* 分页 —— 不利于模块共享
* 分段 —— 产生外部碎片

![image-20250429131814400](imgs\image-20250429131814400.png)

* 段号、页号、页内偏移量的位数的含义

* 段页式存储管理 —— 先分段再分页

  分段用户可见，分页用户不可见

  是**二维**的，给出段号、段内地址

![image-20250429132550802](imgs\image-20250429132550802.png)

* 段式存储：

  * 段表 = 段号（隐含） + 段长 + 段基址

* 段页式存储：

  * 段表 = 段号（隐含） + 页表长度 + 页表所在物理块号
  * 页表 = 页号（隐含） + 页面物理块号

  一个进程对应一个段表，每个段表项对应一个页表，所以段页式存储，**段表只能有一个，页表可以有多个**

![image-20250429133410897](imgs\image-20250429133410897.png)

* 三次访存 —— 段表、页表、数据物理地址

  可以用快表，最少访存一次（访问目标内存单元）

* 需要判断段号越界（每个进程的段长不确定）

  需要判断页号越界（每个段包含的页数是不确定的）

  不需要判断偏移量越界（每个页的页面大小是确定的）

![image-20250429132510566](imgs\image-20250429132510566.png)

### 2. 内存空间扩充

![image-20250415165301606](imgs\image-20250415165301606.png)

* 内存空间扩充：
  1. 覆盖技术
  2. 交换技术
  3. 虚拟存储技术

#### 1）覆盖技术

![image-20250416175610458](imgs\image-20250416175610458.png)

* 内存 = **一个固定区 + 若干覆盖区**

  固定区**一次装入不再修改**，覆盖区可以根据需要用不同的代码段覆盖

  树形图里，同阶层的模块共享同一个覆盖区，是**不可能被同时访问**的程序段

* 缺：需要程序员声明覆盖结构

#### 2）交换技术

![image-20250424122605573](imgs\image-20250424122605573.png)

* 对进程**换出**（挂起）**换入**（中级调度）内存

  （即使进程换出，进程的**PCB**也是**常驻内存**的，PCB里存着进程在外存的存放位置）

* 问题1 —— 换出的进程保存在外存的什么位置

  * 磁盘 = 文件区（追求存储率，*离散分配*） + 对换区（追求换入换出速度，*连续分配*）
  * 换出的进程，保存在**对换区**

* 问题2 —— 什么时候换出

  * 在**内存空间紧缺**时换出，**系统负荷降低**时停止换出

    内存空间紧缺 —— 例如经常发生缺页

    系统负荷降低 —— 例如缺页率明显下降

* 问题3 —— 选择换出进程

  * 阻塞进程
  * 低优先级进程
  * 内存驻留时间长进程

![image-20250424122928057](imgs\image-20250424122928057.png)

* **覆盖**是在**同一**程序或进程中的

  **交换**是在**不同**进程（或作业）之间的

#### 3）虚拟存储技术

![image-20250429145632616](imgs\image-20250429145632616.png)

* 传统存储管理方式（连续分配、分连续分配）
  * 一次性
  * 驻留性

![image-20250429150043725](imgs\image-20250429150043725.png)

* 虚拟存储技术有效的原因 —— 局部性原理
* 定义 ——
  * 需要的信息在内存，暂时不需要的信息留在外存
  * 访问到外存数据时，把数据调入内存
  * 暂时用不到的内存数据，也会被调出外存
  * 逻辑上扩充了内存容量
* 虚拟存储技术特征 —— 
  * 多次性（对应一次性）
  * 对换性（对应驻留性）
  * 虚拟性 （逻辑扩容）

![image-20250429150756555](imgs\image-20250429150756555.png)

* 由于对换性，虚拟存储技术 适合 在内存里 **非连续**存储 作业的数据

* 基于传统的三种非连续分配技术：基本分页、基本分段、段页式

  结合虚拟存储技术：**请求分页、请求分段、请求段页式**

* 外存换入技术 —— **请求调页/请求调段**

  内存换出技术 —— **页面置换/段置换**

![image-20250429151237561](imgs\image-20250429151237561.png)

##### 请求分页存储管理

![image-20250429152717761](imgs\image-20250429152717761.png)

* 基于基本分页系统，增加了请求调页(调入)、页面置换(调出)功能

  **操作系统**需要**提供** 请求调页/请求调段、页面置换/段置换 功能

* 基本页表 -> 请求页表的新增字段：

  * 外存地址（页面在外存存放位置）
  * 状态位（是否调入内存）
  * 访问字段（用于选择调出哪个页面，访问字段可能是据上次访问过去的时间，也可能是最近访问次数，取决于置换算法需要）
  * 修改位（用于确定调出时需不需要写回外存）

###### 缺页中断机构

![image-20250429153620747](imgs\image-20250429153620747.png)

* 缺页中断时机 —— 访问的页面不在内存
* 缺页中断需要**操作系统**处理，会**阻塞**进程，调页完成后放入**就绪**队列
* 缺页中断处理，需要**请求分页**，必要时还需要**页面置换**（用页面置换算法）

![image-20250429154149097](imgs\image-20250429154149097.png)

* 缺页中断是程序运行时发生的，属于**内中断**中的**故障(可被修复)**

  **一条指令**可能会引发**多次**缺页中断

* I/O中断是外中断

###### 地址变换机构

* 基本分页 -> 请求分页，在地址转换时的新增步骤：
  * 请求调页（发现访问的块不在内存中）
  * 页面置换（请求调页时页表已满）
  * 更新状态位、访问字段、修改位

请求分页的地址变换流程：

![image-20250429160058354](imgs\image-20250429160058354.png)

* 在具有快表机构的请求分页系统中，访问一个逻辑地址时，发生缺页时的地址变换步骤：

  查快表（未命中）――查慢表（发现未调入内存）—―调页（调入的页面对应的表项会直接加入快表）―—查快表（命中）――访问目标内存单元

![image-20250429171638803](imgs\image-20250429171638803.png)

###### 四种页面置换算法

* 页面置换算法的目标 —— 降低缺页率

![image-20250429172051616](imgs\image-20250429172051616.png)

* 操作系统无法提前预判页面访问序列，因此最佳置换算法是无法实现的

* 页面置换**一定**在缺页中断时发生

  发生缺页中断**不一定**发生页面置换

* $缺页率 = 缺页次数 / 总访问次数$

![image-20250429172422592](imgs\image-20250429172422592.png)

* Belady 贝拉迪异常
* 只有FIFO置换算法会产生 Belady 异常

![image-20250429172629866](imgs\image-20250429172629866.png)

* 最近最久未使用算法LRU，访问字段表示距离上一次访问的时间
* 除了最佳置换算法OPT（无法实现），性能最好的就是LRU
* LRU性能好，但实现困难，开销大

![image-20250429173345195](imgs\image-20250429173345195.png)

* 时钟置换算法 = Clock 算法 = 最近未用算法 = NRU 算法

  取 可行性、性能、实现开销 平衡的一种算法

  访问字段表示最近有没有被访问过

1. 简单的Clock算法：1、3、4、2、5、6、3、4、7

​	1、3、4、2、5

​	<img src="imgs\image-20250429173425005.png" alt="image-20250429173425005" style="zoom: 50%;" />

​	6

​	<img src="imgs\image-20250429173446343.png" alt="image-20250429173446343" style="zoom:50%;" />	<img src="imgs\image-20250429173458614.png" alt="image-20250429173458614" style="zoom:50%;" />

​	3、4

​	<img src="imgs\image-20250429173522780.png" alt="image-20250429173522780" style="zoom:50%;" />

​	7

​	<img src="imgs\image-20250429173546838.png" alt="image-20250429173546838" style="zoom:50%;" />	<img src="imgs\image-20250429173601023.png" alt="image-20250429173601023" style="zoom:50%;" />

* 简单Clock算法最多经过两轮扫描

2. 改进型的时钟置换算法 —— 除了考虑访问位，也考虑修改位

   改进型时钟置换算法 = 改进型Clock 算法 = 改进型最近未用算法 = 改进型NRU 算法

   ![image-20250429175633461](imgs\image-20250429175633461.png)

   * 一轮扫描样例

     第一轮：找(0, 0)，不修改任何标志位

     <img src="imgs\image-20250429174524310.png" alt="image-20250429174524310" style="zoom:50%;" />	<img src="imgs\image-20250429174456894.png" alt="image-20250429174456894" style="zoom:50%;" />

   * 二轮扫描样例

     第一轮：...

     第二轮：找(0, 1)，并把路过的访问位都归0

     <img src="imgs\image-20250429174624237.png" alt="image-20250429174624237" style="zoom:50%;" />	<img src="imgs\image-20250429174759978.png" alt="image-20250429174759978" style="zoom:50%;" />

   * 三轮扫描样例

     第一轮：...

     第二轮：...

     第三轮：找(0, 0)，不修改任何标志位

     <img src="imgs\image-20250429174900717.png" alt="image-20250429174900717" style="zoom:50%;" />	<img src="imgs\image-20250429174925618.png" alt="image-20250429174925618" style="zoom:50%;" />	<img src="imgs\image-20250429174954156.png" alt="image-20250429174954156" style="zoom:50%;" />

   * 四轮扫描样例

     第一轮：...

     第二轮：...

     第三轮：...

     第四轮：找(0, 1)，不修改任何标志位

     

     <img src="imgs\image-20250429175134268.png" alt="image-20250429175134268" style="zoom:50%;" />	<img src="imgs\image-20250429175151147.png" alt="image-20250429175151147" style="zoom:50%;" />	<img src="imgs\image-20250429175204266.png" alt="image-20250429175204266" style="zoom:50%;" />	<img src="imgs\image-20250429175227816.png" alt="image-20250429175227816" style="zoom:50%;" />

* 改进型Clock算法最多经过四轮扫描

![image-20250429175725295](imgs\image-20250429175725295.png)

###### 页面分配策略

![image-20250429181206423](imgs\image-20250429181206423.png)

* 驻留集 —— 系统给进程分配的内存块数（页面置换算法的窗口大小）

  在采用了虚拟存储技术的系统中，一般 驻留集大小 < 进程的总大小

  驻留集过大：浪费内存，影响并发

  驻留集过小：窗口抖动，性能下降

* 固定分配 —— 提前分配好驻留集，运行期间固定不变

  可变分配 —— 分配的驻留集，在运行期间可以改变大小

* 局部置换 —— 缺页时只能在自己的驻留集内置换

  全局置换 —— 缺页时可以使用 操作系统保留的 驻留集

* 固定分配 + 全局置换 的搭配不可能出现

![image-20250429182040669](imgs\image-20250429182040669.png)

* 固定分配 + 局部置换

* 可变分配 + 全局置换

* 可变分配 + 局部置换

  和固定分配局部置换的区别是如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块

![image-20250429200215250](imgs\image-20250429200215250.png)

* 预调页 —— 运行前预估调页，主要用于进程的首次调入
* 请求调页 —— 运行期间缺页时调页

![image-20250429201129765](imgs\image-20250429201129765.png)

* 对换区大小足够

<img src="imgs\image-20250429200625550.png" alt="image-20250429200625550" style="zoom:50%;" />

* 对换区空间不足

  <img src="imgs\image-20250429200918612.png" alt="image-20250429200918612" style="zoom:50%;" />

* UNIX方式

  <img src="imgs\image-20250429201058177.png" alt="image-20250429201058177" style="zoom:50%;" />

###### 补充概念

![image-20250429201702397](imgs\image-20250429201702397.png)

* 抖动/颠簸 —— 刚换出的页面马上要换入内存，刚换入的页面马上要换出内存

  产生抖动的主要原因是进程的 工作集＞驻留集

  **所有**的页面置换算法都可能存在抖动

  可以撤销部分进程来减缓抖动

* 工作集 ≤ 窗口尺寸

* 要求 驻留集 ≥ 工作集，否则可能会发生抖动

* 基于局部性原理，可以根据工作集设计一种**页面置换算法**――选择一个不在工作集中的页面进行淘汰

![image-20250429202313549](imgs\image-20250429202313549.png)

###### 内存映射文件

* 作用：

  1. 方便程序员访问文件数据

  2. 方便多个进程共享同一个文件

传统文件访问方式：

![image-20250429203956553](imgs\image-20250429203956553.png)

* read 读入内存、write 写回外存

内存映射文件的访问方式：

![image-20250429204420467](imgs\image-20250429204420467.png)

* mmap 建立外存到内存的映射，但实则还没有调入页面

  返回一个内存指针指向映射到的内存位置

* 使用内存映射文件，不需要考虑缺页时read，写回时write，操作系统自动完成

  即方便程序员访问文件数据

![image-20250429204605749](imgs\image-20250429204605749.png)

* 方便多个进程共享同一个文件

![image-20250429204735155](imgs\image-20250429204735155.png)

* 这种特性非常适合用来管理**大尺寸文件**


### 3. 逻辑地址 -> 物理地址（装入）

![image-20250415165337598](imgs\image-20250415165337598.png)

* 可重定位装入 = 静态重定位
* 动态运行时装入 = 动态重定位

### 4. 内存保护（防止越界访问）

![image-20250415165503107](imgs\image-20250415165503107.png)

* 方式一：上限寄存器 + 下限寄存器

  ​		直接比较物理地址，有没有超过上下限

![image-20250415165630462](imgs\image-20250415165630462.png)

* 方式二：重定位寄存器 + 界地址寄存器（即基址寄存器 + 限长寄存器）

  ​		比较逻辑地址，有没有超过界地址寄存器的数据大小

![image-20250415165937125](imgs\image-20250415165937125.png)







