# 进程管理

## 进程概念

### 进程 VS 程序

![image-20250401193612251](imgs\image-20250401193612251.png)

* 程序 —— 静态的指令集合
* 进程 —— 动态的，程序执行一次就出现一个进程

### 进程控制块PCB

![image-20250401194505903](imgs\image-20250401194505903.png)

* 操作系统需要记录的进程信息都保存在 **进程控制块PCB** 中

  PCB 是进程存在的唯一标志 

### 进程实体的组成

* 进程 = PCB + 程序段 + 数据段（默认“进程”就是“进程实体”，除非题中特意考察进程实体的知识）

  PCB 是操作系统控制进程需要的信息

  程序段、数据段 是进程自己运行需要的信息

![image-20250401195044543](imgs\image-20250401195044543.png)

* 可执行文件存放在磁盘里，需要执行时才放进内存

* **进程实体 = 进程映像，是静态的，是进程在某个时间的快照**

  进程是动态的，一个进程对应的进程实体是不断改变的

![image-20250401195609263](imgs\image-20250401195609263.png)

* 进程是系统进行**资源分配和调度的独立单位**

* 如果一个**程序运行多次**，会产生**多个进程**

  这些进程各自具有独立的PCB、数据段

  但它们**共享相同的程序段**

### 进程的五大特性

![image-20250401195954579](imgs\image-20250401195954579.png)

![image-20250401200126054](imgs\image-20250401200126054.png)

* 在引入线程之后，进程就不再是调度的基本单位，但依然是资源分配的基本单位

## 进程的状态与转换

![image-20250401200754522](imgs\image-20250401200754522.png)

* 创建态 —— 初始化PCB、分配资源
* 就绪态 —— 具备运行条件，但没有获得CPU

![image-20250401200933592](imgs\image-20250401200933592.png)

![image-20250401201018359](imgs\image-20250401201018359.png)

* 运行态 —— 就绪态的进程，获得CPU资源

* 阻塞态 —— 运行态的进程主动请求等待某个事件发生，CPU阻塞它，换另一个就绪态进程运行

  ​		     进程请求的事件发生后，从阻塞态回到就绪态

![image-20250401201417407](imgs\image-20250401201417407.png)

* 终止态 —— 进程运行exit系统调用或进程出现不可修复的错误，进入终止态

  ​		     CPU做一系列善后工作（回收资源，回收PCB等），PCB被销毁后进程彻底消失

### 五状态模型

![image-20250401201808637](imgs\image-20250401201808637.png)

* 阻塞态 只能来自 运行态，只能去往 就绪态

  **运行态 -> 阻塞态，主动**（进程主动申请事件发生导致阻塞，例如等待键盘输入）

  **阻塞态 -> 就绪态，被动**（事件什么时候发生，进程控制不了）

* 运行态 -> 就绪态，时间片到

![image-20250401202549708](imgs\image-20250401202549708.png)

* 进程大多数情况下处于：就绪态、运行态、阻塞态

  所以 **就绪态、运行态、阻塞态 是进程的三种最基本的状态**

* 阻塞态 = 等待态

  创建态 = 新建态

  终止态 = 结束态

* **进程状态**用进程控制块**PCB的一个变量 state** 标记

* 操作系统需要**对同一状态的进程进程统一的管理**（进程组织）

### 进程组织

#### 链接方式

![image-20250401203132351](imgs\image-20250401203132351.png)

* **执行**指针、**就绪**队列指针、**阻塞**队列指针，分别指向不同状态的PCB

  * 一个CPU在同一时刻只能执行一个进程，所以如果是**单CPU计算机，任意时刻都只有一个进程处于运行态**

  * 就绪队列会把**优先级高的进程放在队头**

  * 有时因为阻塞原因的不同，进行进一步的**阻塞队列再划分**

#### 索引方式

![image-20250401203648338](imgs\image-20250401203648338.png)

### 进程状态总结

![image-20250401203728291](imgs\image-20250401203728291.png)

## 进程控制

### 进程控制的概念

* **进程控制 = 进程状态转换**

  所谓对进程的控制，其实就是控制进程在五个状态之间的转换

![image-20250401204553433](imgs\image-20250401204553433.png)

* **进程控制需要用原语实现**

  否则会出现操作系统关键数据结构信息不统一的情况

### 实现原语 —— 开中断、关中断

![image-20250401205039587](imgs\image-20250401205039587.png)

* 实现**原语**：关中断、开中断指令

  关中断期间，CPU执行完一条指令，不再查看是否有外部中断信号

* 关中断、开中断指令是**特权指令**

### 进程控制相关的原语

#### 进程的创建

![image-20250401205517945](imgs\image-20250401205517945.png)

* 进程的创建 —— 创建原语

#### 进程的终止

![image-20250401205827176](imgs\image-20250401205827176.png)

* 进程的终止 —— 撤销原语

  撤销父进程之前，必须撤销其所有的子进程

#### 进程的阻塞和唤醒

![image-20250401210210540](imgs\image-20250401210210540.png)

* 进程的阻塞 —— 阻塞原语

* 进程的唤醒 —— 唤醒原语

* 进程被什么阻塞，就应该被什么唤醒，所以**阻塞原语、唤醒原语总是成对使用**

#### 进程的切换

![image-20250401211006130](imgs\image-20250401211006130.png)

* 运行态 -> 就绪态时，向PCB中存入当前运行环境（PC、IR、通用寄存器等）

  就绪态 -> 运行态时，恢复PCB中存放的运行环境

* 保存运行环境、恢复运行环境，是实现进程并发执行的关键技术

### 进程控制总结

![image-20250401211213228](imgs\image-20250401211213228.png)

## 进程通信

* 进程通信的必要性：进程间有时需要进行消息传递

  例如把微博转发到QQ，微博进程和QQ进程就发生了通信

### 进程通信和操作系统

![image-20250401225508553](imgs\image-20250401225508553.png)

* 不允许进程之间直接相互通信，必须经过操作系统的控制

### 进程通信方式

#### 共享存储

![image-20250401225838912](imgs\image-20250401225838912.png)

1. 基于存储区的共享 —— 操作系统不管存储区内部的数据形式、位置

   **灵活性高，速度快**

2. 基于数据结构的共享 —— 共享空间的数据形式、位置固定

   灵活性低，速度慢

* 进程需要经过P、V操作实现对共享存储区的**互斥访问**

#### 消息传递

* 消息 = 消息头 + 消息体

  消息头 = 发送进程PID + 接收进程PID + 消息长度等信息

* 发送原语 `send(接收ID, msg)`

  接收原语 `receive(发送ID, &msg)`

  发送方需要指明接收方ID，接收方需要指明发送方ID

![image-20250401230405367](imgs\image-20250401230405367.png)

* 直接通信方式 ——

  * 发送进程 —— send(接收ID, msg)，就填接收进程的PID

    使消息进入接收进程的消息队列

  * 接收进程 —— receive(发送ID, &msg)，就填发送进程的PID

    从消息队列获取到传递的消息

![image-20250401231400473](imgs\image-20250401231400473.png)

* 间接通信方式 —— 

  * 发送进程 —— send(接收ID, msg)，就填信箱ID

    使消息进入信箱

  * 接收进程 —— receive(发送ID, &msg)，就填信箱ID

    从信箱获取到传递的消息

* 可以多个进程向同一个信箱 send，也可以多个进程从一个信箱 receive

#### 管道通信

![image-20250401231810786](imgs\image-20250401231810786.png)

* **管道本质是特殊的共享文件（pipe文件）**

* 管道也是从内存开辟的共享存储区

  但和共享存储方式不同的是，管道通信的存储区更类似于**循环队列，数据先进先出**

![image-20250401232512271](imgs\image-20250401232512271.png)

* **半双工通信** 

* 管道是**互斥**访问资源

* **读进程**会在管道空时**阻塞**

  **写进程**会在管道满时**阻塞**

* 默认认为一个管道只允许**多个写，一个读**

  但是如果问一个管道是否可以多个写，多个读，答案是可以

### 进程通信总结

![image-20250401233023769](imgs\image-20250401233023769.png)

## 线程

![image-20250401233719394](imgs\image-20250401233719394.png)

* 程序动态运行产生进程

  如果进程只是串行执行程序指令，一个进程不可能同时做很多事（例如QQ进程既要聊天，又要传递文件）

  所以把进程再划分成多个线程

![image-20250401234302142](imgs\image-20250401234302142.png)

* 引入线程前：

  * 进程 是系统 **资源分配** 和 **调度** 的基本单位

* 引入线程之后：

  * 进程是 **资源分配** 的基本单位，线程是 **调度** 的基本单位

  * 系统的**并发度提高**
  * 同一进程间的线程切换，不需要切换环境，并发**系统开销减小**

![image-20250401234644656](imgs\image-20250401234644656.png)

### 线程实现方式

#### 用户级线程 ULT

![image-20250402135357376](imgs\image-20250402135357376.png)

* 可以把一段处理事务的**代码逻辑**看作一个**用户级线程**（例如处理视频、文字、文件的代码逻辑分别对应一个线程）

![image-20250402140128198](imgs\image-20250402140128198.png)

* 特点：

  * **应用程序的线程库**管理所有的用户级线程
  * **操作系统不知道**用户级线程的存在
  * 同一个进程的用户级线程之间的**切换**，不需要操作系统参与，**不需要CPU变态**
  * 进程依然是资源分配和调度的基本单位

* 优：线程切换开销小，效率高（同一个进程的用户级线程之间的切换不需要CPU变态）

  缺：操作系统不知道用户级线程的存在，进程依然是处理机调度的基本单位

  （导致问题：1. 用户级线程阻塞，会阻塞所属进程，导致进程里的全部用户级线程都阻塞

  ​			2. 进程才是调度基本单位，同一个进程里的用户级线程不能并发）

#### 内核级线程 KLT

![image-20250402141207507](imgs\image-20250402141207507.png)

* 特点：

  * **操作系统内核管理**所有的内核级线程
  * 内核级线程之间**切换**，**需要CPU变态**
  * 进程是资源分配的基本单位，线程是调度的基本单位

* 优：1. 一个内核级线程阻塞，不会阻塞进程的其它线程；

  ​	2. 同一个进程里的内核级线程可以并发

  缺：线程切换开销大（线程切换由操作系统内核完成，需要CPU切换到核心态，然后返回用户态）

### 多线程模型

![image-20250402141457756](imgs\image-20250402141457756.png)

* 一对一模型 —— 1个用户级线程对应1个内核级线程

![image-20250402141601209](imgs\image-20250402141601209.png)

* 多对一模型 —— 多个用户级线程对应1个内核级线程

![image-20250402142334023](imgs\image-20250402142334023.png)

* 多对多模型 —— n个用户级线程对应m个内核级线程(**n ≥ m**)
  * 克服了一对一模型需要频繁切换CPU状态的缺点
  * 克服了多对一模型并发度低的缺点

![image-20250402142410583](imgs\image-20250402142410583.png)

### 线程的状态与转换

![image-20250402142629385](imgs\image-20250402142629385.png)

### 线程的组织与控制

![image-20250402143045463](imgs\image-20250402143045463.png)

* **只有内核级线程才有TCB**，因为操作系统只知道KLT
* **PC、寄存器、堆栈指针** —— 线程切换时需要保存/恢复的内容
* **线程表**存的是TCB，可能是一个进程拥有一个，也可能是整个操作系统拥有一个，取决于具体的计算机

## 处理机调度

![image-20250402174356675](imgs\image-20250402174356675.png)

* 调度的本质 —— 确定获取资源的顺序

### 调度三个层次

#### 高级调度

![image-20250402174552884](imgs\image-20250402174552884.png)

* 高级调度 —— **作业调度**，把作业从磁盘调到内存

* 每个作业只调入一次，调出一次

  调入时建立PCB，调出时撤销PCB

#### 低级调度

![image-20250402174801102](imgs\image-20250402174801102.png)

* 低级调度 —— **进程调度/处理机调度**，把进程从就绪态变成运行态
* 低级调度需要频度很高（实现微观并发）

#### 中级调度

![image-20250402175143485](imgs\image-20250402175143485.png)

* 中级调度 —— **内存调度**，控制**挂起进程重新进入内存**
* 频率： 高级调度 < 中级调度 < 低级调度

### 挂起、七状态模型

![image-20250402175515774](imgs\image-20250402175515774.png)

* 挂起 和 阻塞 的区别：
  * **挂起**，是因为内存负载太多，需要把一些放在内存的进程调出到**外存**
  * **阻塞**，是因为进程请求的事件还没有发生，这时进程还在**内存**

* 就绪挂起、阻塞挂起也有对应的挂起队列

  有时因为阻塞挂起的阻塞原因不同，细分成多个阻塞挂起队列

![image-20250402175934924](imgs\image-20250402175934924.png)

![image-20250402180102586](imgs\image-20250402180102586.png)

### 低级调度

![image-20250402180413829](imgs\image-20250402180413829.png)

* 低级调度 = 进程调度 = 处理机调度
* 进程可以切换：
  * 进程主动放弃处理机 —— 正常终止、异常终止、请求阻塞
  * 进程被动放弃处理机 —— 时间片到、紧急事件（如I/O中断）、出现优先级更高的进程
* 进程不能切换：
  * 正在处理**中断**
  * 进程在**操作系统内核程序临界区**
  * 正在执行**原语**

#### 临界资源 VS 内核临界资源

![image-20250402181523368](imgs\image-20250402181523368.png)

* 临界资源 —— 需要互斥访问的资源

  临界区 —— 访问临界资源的代码

  因为**临界资源**需要**互斥访问**，所以各进程的**临界区**也需要**互斥运行**

* 内核程序临界资源 —— 有关**内核数据结构**的临界资源，例如就绪队列

* 如果进程正在执行内核程序临界区，不能进行进程调度，因为内核临界资源很重要，对它的处理需要一气呵成

  如果进程正在执行普通临界区，可以进行进程调度

#### 非抢占式 V 抢占式

![image-20250402181943784](imgs\image-20250402181943784.png)

* 非抢占式 —— **只能进程主动放弃处理机**（包括正常终止、异常终止、主动阻塞）

  实现简单，系统开销小但是无法及时处理紧急任务

  适合于早期的批处理系统

* 抢占式 —— 如果由中断，或更高优先级进程进入，**可以让进程被动放弃处理机**（包括时间片到、紧急情况、高优先级）

  可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）

  适合于分时操作系统、实时操作系统

#### 进程调度 VS 进程切换

![image-20250402183543305](imgs\image-20250402183543305.png)

* 进程调度 —— 选择一个将要运行的进程 + 进程切换

  进程切换 —— 当前运行进程下处理机，选择好的进程上处理机

* 进程切换的主要步骤：

  1. 对正在运行的进程：保存旧PC、通用寄存器、堆栈、PSW 等现场信息到它的PCB
  2. 对将要运行的进程：从它的PCB恢复PC、通用寄存器、堆栈、PSW 等现场信息

  进程切换是有开销的，频繁进行进程切换将降低系统效率

![image-20250402184035240](imgs\image-20250402184035240.png)

#### 调度时机

![image-20250402191122663](imgs\image-20250402191122663.png)

* 调度时机：
  1. 运行进程主动放弃：
     * 正常终止
     * 异常终止
     * 主动阻塞
  2. 被动放弃：
     * 时间片到
     * 紧急情况（如I/O中断）
     * 出现高优先级进程（如创建了一个优先级更高的新进程）
  
* 非抢占式—— 主动放弃时会触发调度程序工作

  抢占式 ——主动放弃、被动放弃都会触发调度程序工作

#### 闲逛进程

![image-20250402191931936](imgs\image-20250402191931936.png)

* **CPU永远不会空闲**，没有其他就绪进程时，CPU就运行**闲逛进程（idle）**

* 闲逛进程特点：

  * 优先级最低

  * 能耗小
  * 执行末尾例行检查中断
  * 不需要CPU之外的资源，不会被阻塞

### 调度算法评价指标

![image-20250402192434114](imgs\image-20250402192434114.png)

* CPU利用率 —— CPU忙碌的时间占总时间的比例

  设备利用率 —— 设备忙碌的时间占总时间的比例

![image-20250402192544076](imgs\image-20250402192544076.png)

* 系统吞吐量 —— 单位时间内完成作业的数量

![image-20250402192730233](imgs\image-20250402192730233.png)

* 周转时间 —— 作业从提交到完成花费的时间

  周转时间 = 作业完成时刻 - 作业提交时刻 = 等高级调度的时间 + 在就绪态的时间 + 在运行态的时间 + 在阻塞态的时间

  用户更关心单个作业的周转时间

* 平均周转时间 —— 所有作业，周转时间的平均值

  操作系统更关心平均周转时间

![image-20250402193034386](imgs\image-20250402193034386.png)

* 带权周转时间 = $\frac{作业周转时间} {作业实际运行时间}$ 

  带权周转时间 ≥ 1，越小越好

* 平均带权周转时间 —— 所有作业的带权周转时间平均值，越小越好

![image-20250402193556463](imgs\image-20250402193556463.png)

* 等待时间 —— 周转时间 - 被CPU、I/O设备服务的时间：
  * 对进程来说，等待时间 = 在就绪态时间
  * 对作业来说，等待时间 = 高级调度时间 + 在就绪态时间

* 周转时间 = 高级调度的时间 + 在就绪态的时间 + 在运行态的时间 + 在阻塞态的时间

  被CPU、I/O设备服务的时间（即进程在运行态、阻塞态的时间）一般是确定不变的

  所以调度算法的关键目标就是 **减少等待时间**

![image-20250402194209115](imgs\image-20250402194209115.png)

* 响应时间 —— 设备产生请求到首次被响应的时间

#### 指标总结

![image-20250402194301093](imgs\image-20250402194301093.png)

### 调度算法

#### 1. 先来先服务 FCFS

![image-20250402195915144](imgs\image-20250402195915144.png)

* 一般是非抢占式
* 对长作业有利，短作业不利
* 不会导致饥饿

![image-20250402200026269](imgs\image-20250402200026269.png)

#### 2. 短作业优先 SJF/SPF

![image-20250402202059849](imgs\image-20250402202059849.png)

* 有抢占式，非抢占式
* 对短作业有利，长作业不利
* 作业运行时间难以预估
* 会产生饥饿现象

##### 非抢占式

![image-20250402200330834](imgs\image-20250402200330834.png)

##### 抢占式（最短剩余时间优先 SRTN）

![image-20250402201235991](imgs\image-20250402201235991.png)

误区：

![image-20250402201456663](imgs\image-20250402201456663.png)

* 如果只说“短作业优先算法”

  默认认为是**非抢占式**

* **抢占式** 算法性能比非抢占式的**更好**

* SJF算法平均等待时间、平均周转时间最少 ——

  这种说法一般指的是 **抢占式的短作业优先算法/最短剩余时间算法/SRTN**

  如果其它选项没有明显错误，可以认为这个说法是错误的

#### 3. 高相应比优先算法 HRRN

* FCFS：只考虑了等待时间
* SJF/SPF：只考虑了运行时间
* HRRN：等待时间、运行时间都考虑

![image-20250402203340711](imgs\image-20250402203340711.png)

* 非抢占式
* 相应比 = $\frac{等待时间 + 运行时间}{运行时间}$ ，相应比越大越优先执行
* 不会导致饥饿

![image-20250402202651636](imgs\image-20250402202651636.png)

#### 批处理系统调度算法小结

![image-20250402203513913](imgs\image-20250402203513913.png)

* FCFS、SJF/SPF、HRRN，都适合早期批处理系统

  没有考虑响应时间，**不能处理紧急任务，交互性差**

#### 4. 时间片轮转 RR

![image-20250402224921943](imgs\image-20250402224921943.png)

* 只用于低级调度（进程调度）

  因为时间片是处理机的时间片

  作业进入内存产生进程才能被分配时间片

* 抢占式，时钟中断时就剥夺当前运行的进程

* 不同的计算机，时间片大小可能不同

* 很公平，不处理紧急任务

![image-20250402224349717](imgs\image-20250402224349717.png)

![image-20250402224120920](imgs\image-20250402224120920.png)

* 如果P1刚用完时间片，P2同时进入就绪队列，默认P2排在P1前

  即新进程比退下来的进程排列靠前

* 时间片不宜过大 —— 退化成FCFS

  时间片不宜过小 —— 进程切换开销太大

#### 5. 优先级

![image-20250402230102127](imgs\image-20250402230102127.png)

* 抢占式或非抢占式
* 优先数 和 优先级 的关系视题定
* 会导致饥饿

##### 非抢占式

![image-20250402225224095](imgs\image-20250402225224095.png)

##### 抢占式

![image-20250402225406034](imgs\image-20250402225406034.png)

优先级：

![image-20250402225820609](imgs\image-20250402225820609.png)

* 如何判断优先级：

  1. 根据优先级的级别，设置多个就绪队列
  2. 只有一个就绪队列，优先级越高的进程，越靠近队头

* 优先级设置：

  * 静态优先级 —— 优先级固定不变

  * 动态优先级 —— 优先级有初始值，会动态调整

    + 进程等待了很长时间，则提升其优先级
    + 进程占用了很长时间，则降低其优先级
    + 进程频繁进行I/O操作，则提升其优先级

    HRRN某种程度上就是动态优先级

* 设置优先级的策略 —— 系统进程、前台进程、I/O繁忙型进程优先

  * 系统进程：先完成操作系统自己的工作
  * 前台进程：提升用户体验
  * I/O繁忙型进程：尽早地让I/O这种低速设备开启工作

#### 6. 多级反馈队列

* HRRN：考虑等待和运行时间

  RR：考虑了响应时间

  优先级：考虑了紧急事件

  多级反馈队列：综合以上优点

![image-20250402231510536](imgs\image-20250402231510536.png)

* 抢占式
* 会饥饿

![image-20250402230920055](imgs\image-20250402230920055.png)

* 反馈队列分等级，等级越高，优先级越高，运行时间越短

* 新进程默认在第1级队列

* 任意时刻，CPU只会运行优先级最高的反馈队列里的队头进程

  （例如运行第2级反馈队列的P2到一半，突然进入新进程P3，P3抢夺处理机）

* 若用完该等级对应的时间片，进程还没有结束，则该进程进入下一级反馈队列的队尾

  若已经是最低一级的反馈队列，则重新进入该层队列的队尾

#### 交互式系统调度算法小结

![image-20250402231743877](imgs\image-20250402231743877.png)

#### 7. 多级队列

![image-20250402233013527](imgs\image-20250402233013527.png)

* 多级队列 —— 给进程分类

  多级反馈队列：进程生来平等，逐渐降级

  多级队列：进程生来不平等，系统进程 > 交互式进程 > 批处理进程，不会降级

* 根据进程级别不同如何分配处理及资源：

  * 方法1：固定优先级，例如优先执行系统进程，最后执行批处理进程
  * 方法2：时间片分配，例如三个队列分配时间50%，40%，10%

* 不同级别的队列，可以使用不同的调度算法


## 进程同步和互斥

### 基本概念

![image-20250402234748037](imgs\image-20250402234748037.png)

* 进程的四大特性：并发、共享、虚拟、异步

  * 异步性 —— 进程的运行是走走停停，以不可预知的速度前进的

  * 然而有时，进程间需要满足**进程同步，即直接制约关系**（某个进程的执行必须在另一个进程之前）

    例如管道通信，只有发送方发送了消息，接收方才能接收消息

![image-20250402234845463](imgs\image-20250402234845463.png)

* 临界资源 —— 互斥共享的资源
* **进程互斥，即间接制约关系**，由于多个进程访问同一个临界资源引起

![image-20250402235418056](imgs\image-20250402235418056.png)

* 访问临界资源的代码 = 
  * 进入区 —— 上锁
  * 临界区 —— 也称临界段，访问临界资源
  * 退出区 —— 解锁
  * 剩余区 —— 其它处理

* 处理进程互斥，需要尽量满足四个原则：
  * 空闲让进 —— 进程访问空闲临界资源，允许进入
  * 忙则等待 —— 进程访问上锁临界资源，要等
  * 有限等待 —— 不能无限等
  * 让权等待 —— 缺临界资源的进程，要让出处理机（不要让CPU忙等）

![image-20250402235648168](imgs\image-20250402235648168.png)

### 进程互斥的软件实现方法

![image-20250403144258837](imgs\image-20250403144258837.png)

* 进程互斥的必要性：有些资源不能交替使用

#### 单标志法

![image-20250403144412148](imgs\image-20250403144412148.png)

* 一个标志位turn，表达现在轮到哪个进程访问资源
* 实现了忙则等待，当资源被占还没有还，上处理机的进程不能占用该资源

![image-20250403144634476](imgs\image-20250403144634476.png)

* 违反空闲让进

  每个进程进入临界区的权限只能被另一个进程赋予，如果P0一直不访问，P1即使想访问也无法访问

#### 双标志先检查法

![image-20250403145059181](imgs\image-20250403145059181.png)

* flag[]数组，表达每个进程访问资源的意愿

* 先检查，后上锁（先询问后表达意愿）

* 违反忙则等待：

  检查和上锁不是一气呵成的

  可能会出现1、5、2、6的情况，两个进程同时都访问了资源

#### 双标志后检查法

![image-20250403145557300](imgs\image-20250403145557300.png)

* flag[]数组，表达每个进程访问资源的意愿

* 先上锁，后检查

* 实现了忙则等待

* 违背了空闲让进，有限等待

  可能会出现1、5、2、6的情况，两个进程都永远无法访问资源

#### Peterson算法

![image-20250403174707773](imgs\image-20250403174707773.png)

* flag[]数组 + turn标记

* Peterson算法，就是双标志后检查法，加了一个turn谦让

  不管前边的代码顺序如何，最后一个谦让的进程会把turn让给对方，代码总能顺利执行

* 实现了空闲让进、忙则等待、有限等待

  **违反让权等待**（while循环忙等）

![image-20250403175105435](imgs\image-20250403175105435.png)

* 软件实现方式，总是 谦让 + 表达意愿

### 进程互斥的硬件实现方法

#### 中断屏蔽方法

![image-20250414195254489](imgs\image-20250414195254489.png)

* 使用开关中断指令，限制临界区的访问

* 缺：不适用于多处理机系统（关中断的处理机上，能保证只有一个进程访问临界区，但其它处理机上也有进程）；

  ​	不适用于用户进程（开关中断是特权指令）
  

#### TestAndSet/TS/TSL指令

![image-20250414195715585](imgs\image-20250414195715585.png)

* 通过硬件一气呵成的实现了“上锁”和“检查”
* 缺：不满足让权等待

#### Swap/Exchange/XCHG指令

![image-20250414195936391](imgs\image-20250414195936391.png)

* 和TSL指令基本一致，都是等待至其它进程让出临界区

  优缺点也一样

![image-20250414200118958](imgs\image-20250414200118958.png)

* 中断屏蔽方法： 单处理机，内核进程
* TSL、Swap指令：多处理机，忙等

### 互斥锁

![image-20250414201051853](imgs\image-20250414201051853.png)

* 锁只有开、关两种状态，标识着当前临界区是否可用
* 使用锁实现互斥，缺点是忙等（自旋锁）浪费处理机资源

![image-20250414201151643](imgs\image-20250414201151643.png)

* 锁适用于 多处理机 + 上锁时间短

  例如，P1的临界资源被P2占用，P2在另一个处理机上运行，直到把锁让出，P1这时仍在处理机上。

  ​	这种情况下自旋避免了反复切换进程上下文

进程互斥的实现 ——

| 名称           | 违反了                             |
| -------------- | ---------------------------------- |
| **软件** ——    |                                    |
| 单标志法       | 空闲让进                           |
| 双标志先检查法 | 忙则等待                           |
| 双标志后检查法 | 空闲让进、有限等待                 |
| Peterson算法   | 让权等待                           |
| **硬件** ——    |                                    |
| 中断屏蔽方法   | 让权等待（只能单处理机、内核指令） |
| TestAndSet指令 | 让权等待                           |
| Swap指令       | 让权等待                           |

### 信号量机制

* 信号量机制 —— 很好的解决进程互斥、进程同步的问题

![image-20250414202624182](imgs\image-20250414202624182.png)

* 信号量 —— 表示系统中**资源数量**的一个变量

* wait(S) = P(S)

  signal(S) = V(S)

* P、V操作，是**一对成对出现的原语**，原语不会被中断

* 使用PV操作，可以解决双标志先检查法中“检查”“上锁”不能一气呵成的问题

#### 整型信号量 VS 记录型信号量

![image-20250414203223098](imgs\image-20250414203223098.png)

* 整形信号量，就是一个整数

  代表目前剩余的资源数量，≥0

* 对整形信号量的操作只有三种：初始化、P操作、V操作

* 使用整形信号量，进程会忙等

![image-20250414211333481](imgs\image-20250414211333481.png)

* 记录型信号量，是一个结构，包括value和L
  * value —— ≥0时代表目前剩余的资源数量，<0时它的绝对值代表正在等待它的进程数量
  * L —— 等待队列
* block() —— 自我阻塞 + 加入等待队列
* wakeup() —— 唤醒一个阻塞进程 + 分配资源

* **记录型信号量实现了让权等待**

![image-20250414211531631](imgs\image-20250414211531631.png)

* 信号量，默认指**记录型信号量**（即默认**不会忙等**）

#### 进程互斥与同步应用

* 默认都指的是记录型信号量
* 流程：分析关系->设置信号量->判断信号量初值

信号量机制实现进程互斥：

![image-20250414212042083](imgs\image-20250414212042083.png)

* 信号量 = semaphore

信号量机制实现进程同步：

![image-20250414212927618](imgs\image-20250414212927618.png)

* 记录型信号量实现进程同步 —— 

  在”前操作“之后执行V(S)

  在”后操作“之前执行P(S)

![image-20250414213116920](imgs\image-20250414213116920.png)

* 互斥信号量初始值为1
* 同步信号量初始值为0（视情况而定）

#### 生产者-消费者问题（一一）

![image-20250414213924777](imgs\image-20250414213924777.png)

* 信号量：

  1. 互斥信号量 mutex —— 两个进程必须互斥的访问“货架”（防止写冲突）

     一般互斥信号量的初始值都是1

  2. 同步信号量 full —— “货架”有“货物”，读者进程才能读取

     一开始没货物，所以full的初始值是0

  3. 同步信号量 empty —— “货架”有“空位”，写者进程才能写入

     一开始全是空位，所以empty的初始值是货架容量

* 互斥信号量的P、V操作，在同一个进程里出现

  同步信号量的P、V操作，在不同进程里出现

![image-20250414214552199](imgs\image-20250414214552199.png)

* **对于P操作，同步信号量必须在互斥信号量之前**（预防死锁）

  V操作无所谓

* 减少临界区的无关代码，防止对临界资源的无意义占用

![image-20250414214928938](imgs\image-20250414214928938.png)

#### 多生产者-多消费者问题（多多）

爸爸往盘子放橘子，妈妈往盘子放苹果，女儿吃橘子，儿子吃苹果。盘子只有一个：

![image-20250415133553211](imgs\image-20250415133553211.png)

* “多” 不是指多个，而是指多类
* 以上四个人相当于四个进程，有三对同步关系(苹果、橘子、盘子)，一对互斥关系(盘子)

![image-20250415134112133](imgs\image-20250415134112133.png)

* **当缓冲区数量=1时，可以消除掉互斥信号量的属性**，不会导致运行出错

![image-20250415134347662](imgs\image-20250415134347662.png)

* 当缓冲区数量>1，必须设置互斥信号量，防止读写冲突

![image-20250415134801429](imgs\image-20250415134801429.png)

* 对于进程同步问题，**PV不是基于进程的，而是基于资源的**

#### 抽烟者问题（一多）

供应者轮流提供产品让吸烟者A、B、C吸烟，缓冲区只有一个：

![image-20250415135513071](imgs\image-20250415135513071.png)

#### 读者-写者问题（互斥）

读-读不冲突，读-写、写-写冲突：

![image-20250415142802438](imgs\image-20250415142802438.png)

* 没有同步问题，只有互斥问题（假定缓冲区有初始数据的）
  1. 针对缓冲区的互斥信号量rw（实现了读-写互斥，但读-读也被迫互斥）
  2. count变量，令只有第一个读进程需要P操作，只有最后一个写进程需要V操作（初步实现读-读共存，但如果恰好两个读进程一起通过了if，就会有一个被阻塞在P操作）
  3. 针对count变量的互斥信号量（读进程互斥访问count变量，实现了读-读共存。但读进程优先，写进程可能会饿死）
  4. 针对每个进程的互斥信号量（实现了先来先服务，读写公平）

#### 哲学家进餐问题（死锁）

五个哲学家，五根筷子（进程需要持有多个资源，怎样避免死锁）：

![image-20250415143811288](imgs\image-20250415143811288.png)

* 解决方案：

  1. 只允许最多四个哲学家同时进餐（破坏循环等待）

  2. 奇数先拿左手，偶数先拿右手（竞争失败的一方在一开始就被阻塞，不会空占资源，破坏循环等待）

  3. 同时拿左右筷子（使用P、V实现一气呵成，破坏请求和保持）![image-20250415144438170](imgs\image-20250415144438170.png)

     * 其实没有实现拿筷子的原子性

       假如0号哲学家拿了筷子

       然后4号哲学家启动，它会被阻塞在P(右筷子)的步骤里

       其它哲学家启动，由于4号哲学家没有释放mutex信号量，其他进程也会被阻塞在P(mutex)的步骤里

       等到0哲学家用餐完毕，释放筷子，4号哲学家被激活，其它进程依次被激活

       这种方式也能解决死锁

### 管程

![image-20250416155159988](imgs\image-20250416155159988.png)

* 类似一个类，管程 = 变量 + 初始化 + 函数，管程有一个名字
* 管程里定义的**变量**，**只能**通过管程提供的**函数访问**
* 管程是管理资源的，所以**同一时刻只允许一个进程执行管程函数**（编译器负责实现）

![image-20250416155939144](imgs\image-20250416155939144.png)

* 同步、互斥的问题全部外包给了管程，进程不需要再考虑它们（封装）
* 管程可以设置变量，来设置解决同步问题

![image-20250416160253943](imgs\image-20250416160253943.png)

![image-20250416160424174](imgs\image-20250416160424174.png)

## 死锁

### 死锁、饥饿、死循环

![image-20250416162142844](imgs\image-20250416162142844.png)

* 死锁 —— 循环等待资源（I/O资源），至少要两个进程参与，**阻塞态**，是OS的问题
* 饥饿 —— 长期等待资源（I/O资源和处理机资源），**就绪态/阻塞态**，是OS的问题
* 死循环 —— while(true)之类，**可以是运行态**，是管理者的代码问题

### 死锁的四个必要条件

![image-20250416162712990](imgs\image-20250416162712990.png)

只要其中任一条件不成立，死锁就不会发生：

 1. 互斥条件 —— 资源只允许互斥共享（如哲学家的筷子、打印机设备）

 2. 不可剥夺条件 —— 资源不能被强制剥夺，只能进程主动释放

 3. 请求和保持条件 —— 进程保持已有资源，同时请求新的资源（循环等待）

 4. 循环等待条件 —— 存在资源循环等待链

    发生死锁 => 循环等待，但循环等待 ≠> 发生死锁，因为可能还有其它同类资源不在等待链里

### 发生死锁的情况

![image-20250416163414660](imgs\image-20250416163414660.png)

* 竞争一种不可剥夺资源，例如双标志后检查法
* 互相持有部分资源并且请求对方的资源
* 互斥信号量写在同步信号量之前

总之，对不可剥夺资源的不合理分配，可能导致死锁。

![image-20250416163948480](imgs\image-20250416163948480.png)

### 死锁的处理策略

#### 预防（静态-破坏必要条件）

破坏四个必要条件中的任意一个，就能破坏死锁

##### 破坏互斥条件

![image-20250416164229126](imgs\image-20250416164229126.png)

* 用SPOOLing技术，把独占设备逻辑改造成共享设备

  缺：保留互斥性有时是必要的

##### 破坏不可剥夺条件

![image-20250416164452309](imgs\image-20250416164452309.png)

* 方案一：进程运行过程中，**发现**资源请求被**阻塞**，**立刻释放**所有已持有资源

  缺：前期工作作废；

  ​	对于要求资源多的进程，可能总是运行一段就发现请求阻塞，不得不反复申请、释放资源，增大系统开销；

  ​	发生饥饿；

  ​	反复申请、释放资源，；

* 方案二：当发生循环等待，**OS介入强行剥夺**资源

  缺：实现复杂，需要考虑进程优先级（先剥夺谁）；

  ​	前期工作作废；

  ​	反复申请、释放资源，增大系统开销；

##### 破坏请求和保持条件

![image-20250416165727686](imgs\image-20250416165727686.png)

* 静态分配方法 —— 进程运行开始时，**获得全部资源 or 不获得资源**，并且程序**运行期间一直保持全部资源**

  缺：进程的整个运行期间都一直保持着所有资源，但有的资源只需要短期持有，因此造成严重的资源浪费；

  ​	对于要求资源多的进程，比资源要求少的进程 优先级更低，可能发生饥饿；

##### 破坏循环等待条件

![image-20250416171702957](imgs\image-20250416171702957.png)

* 顺序资源分配法 —— 给资源分级，必须先访问低级别资源，再访问高级别资源，同级资源必须一次申请完

  ​	这样能保证，当进程A访问不到某资源，此时访问到该资源的进程，一定不需要进程A现有的任何资源。进程间不互相持有对方需要的资源，就不会死锁。

  缺：资源扩展不方便；

  ​	资源浪费(有时其实要先访问高级别资源，再访问低级别资源。这时会造成持有资源但暂时不使用的情况)；
  
  ​	编写复杂(编辑代码时，需要考虑到资源级别)；

![image-20250416172508077](imgs\image-20250416172508077.png)

#### 避免（动态-避免不安全状态）

##### 安全序列 VS 不安全状态

![image-20250416173126148](imgs\image-20250416173126148.png)

+ **安全序列** —— 如果系统按照这种序列分配资源，则**每个进程都能顺利完成**
+ 只要能找出一个安全序列，系统就是安全状态

* 分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态

  也可能不死锁（可能某些进程提前归还资源，就不会死锁）

+ 安全状态 -> **一定不**死锁

  不安全状态 -> **可能**发生死锁

  发生死锁 -> **一定**在不安全状态

##### 银行家算法

手算：

![image-20250416174218294](imgs\image-20250416174218294.png)

序列 P1 -> P3 -> P0 -> P2 -> P4 是安全序列，所以此时系统处于安全状态

代码：

![image-20250416210150215](imgs\image-20250416210150215.png)

* Max矩阵，Allocation矩阵，Need矩阵 分别表示“企业” 申请的最大资源、已被分配的资源、仍需要的资源

  Available数组表示“银行”剩余资源

* 判断是否要分配资源：

  1. Request < Need
  2. Request < Available
  3. 模拟分配后，判断是否是安全状态
  4. 分配，Allocation+Request，Need-Request，Available-Request

#### 检测解除（死锁发生后）

![image-20250416211011029](imgs\image-20250416211011029.png)

* 预设死锁会发生
  * 首先，死锁发生时要能及时检测到
  * 然后，要解决死锁


##### 检测死锁

![image-20250416211647937](imgs\image-20250416211647937.png)

* 资源分配图：

  + 两种结点：进程结点、资源结点

  + 两种边：请求边、分配边


* 检测死锁：

  1. 分配剩余资源，找出不阻塞也不是孤点的进程

  2. 删除该进程所在边，释放占用资源

  3. 重复1、2。直到删除所有边，或者无法再删除边

  4. 能删除所有边 —— 称图“可完全简化”，不会发生死锁

     不能删除所有边 —— 发生死锁，最后还有边的进程就是死锁的进程（如上图P1、P2是死锁进程，P3不是）

##### 解除死锁

![image-20250416212917242](imgs\image-20250416212917242.png)

* 解除死锁：

  1. 资源剥夺法：**挂起**（暂时放到外存上）某些死锁进程（可能导致挂起的进程饥饿）

  1. 撤销进程法/终止进程法：强制**撤销**部分、甚至全部死锁进程（简单，但前期工程作废）

  1. 进程回退法：让一个或多个死锁进程**回退**到足以避免死锁的地步（这要求系统设置还原点）

* 剥夺/终止/回退进程的选择：
  * 优先级低的
  * 执行时间短的
  * 剩余时间长的
  * 占用资源多的
  * 批处理的

![image-20250416213325692](imgs\image-20250416213325692.png)
