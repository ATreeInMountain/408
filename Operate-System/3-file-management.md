# 文件管理

## 基本概念

### 文件的属性

![image-20250424132857477](imgs\image-20250424132857477.png)

操作系统通过文件控制块$FCB$来保护文件元数据：

+ 文件名 —— 主要是为了方便用户找到文件，同一目录下不允许有重名文件
+ 标识符 —— 操作系统区分文件的内部名称，对用户来说毫无可读性
+ 类型 —— 如txt、pdf，不同类型文件打开方式可能不同
+ 位置 —— 文件路径（用户使用）、外存地址（操作系统使用，用户不可见）
+ 大小
+ 创建时间
+ 上次修改时间
+ 文件所有者信息
+ 保护信息 —— 对文件进行保护的访问控制信息

### 文件内部组织方式

![image-20250424133433933](imgs\image-20250424133433933.png)

* **无结构文件 = 流式文件**，例如.txt文件

  由二进制流或字符流组成

* **有结构文件 = 记录式文件**，例如数据库表，.excel文件

  由一条一条的记录组成，记录由一个一个数据项组成
  
  **数据项**是文件系统中**最基本的数据单位**

![image-20250424133704990](imgs\image-20250424133704990.png)

### 文件之间组织方式

![image-20250424133917714](imgs\image-20250424133917714.png)

* 目录 = 文件夹
* 目录是一种特殊的有结构文件

### 操作系统的文件管理功能(文件操作

![image-20250424134201312](imgs\image-20250424134201312.png)

* 最基本的文件管理功能 —— 创建、读、写、删除、打开、关闭

  **在读/写之前必须执行 打开**

  **在读/写之后必须执行 关闭**

* 其它复杂功能都是由这六个功能组合得到的

### 文件存放在外存

![image-20250424135013702](imgs\image-20250424135013702.png)

* 外存也是由**存储单元**组成的，每个存储单元对应一个**物理地址**

* 在外存，若干存储单元组成一个**块/磁盘块/物理块，**每个块**大小相等**

* 操作系统**以块为基本单位**访问外存

  文件的逻辑地址(逻辑块号 + 块内地址) -> 外存的物理地址(物理块号 + 块内地址)

![image-20250424134830322](imgs\image-20250424134830322.png)

## 文件的逻辑结构(主要介绍有结构文件

![image-20250425161814357](imgs\image-20250425161814357.png)

* 无结构文件、有结构文件，是一种**逻辑概念**

  类似数据结构里的”线性表“

![image-20250425161951216](imgs\image-20250425161951216.png)

* **关键字** —— 用来标识 记录 的**数据项**

* 根据**各条记录的长度（占用的存储空间）是否相等**


### 定长记录 VS 可变长记录

* 定长记录：

  ![image-20250430115346337](imgs\image-20250430115346337.png)

* 可变长记录：

  ![image-20250430115701689](imgs\image-20250430115701689.png)

### 逻辑组织方式

#### 1）顺序文件

![image-20250425163108098](imgs\image-20250425163108098.png)

* 顺序文件 —— 文件中的记录一个接一个地顺序排列（类似线性表）

  * 顺序存储 —— 逻辑上相邻，物理上也相邻（类似顺序表）

    链式存储 —— 逻辑上相邻，物理上不一定相邻（类似链表）

  * 串结构 —— 记录不按关键字排列（一般按记录创建/修改时间排）

    顺序结构 —— 记录按关键字排列

![image-20250430121400767](imgs\image-20250430121400767.png)

* 题中提到顺序文件，一般指**顺序存储的顺序文件**

* 顺序文件（即顺序存储的顺序文件）的增删操作需要移动大量元素，比较困难

  如果采用串结构，增加记录相对简单，但失去了关键字快速查找的功能

#### 2）索引文件

![image-20250430121642519](imgs\image-20250430121642519.png)

* 索引文件 —— **索引表 = 索引号 + 长度 + 指针**，每条记录对应一个索引项，索引表**连续存储**
* 即使是**可变长记录文件**，通过建立索引表，也能实现**随机存取**（索引表是定长记录的顺序文件）
* **一个**可变长记录文件，根据不同的数据项可以建立**多个索引表**

#### 3）索引顺序文件

![image-20250430140702326](imgs\image-20250430140702326.png)

* 顺序文件的缺点：不支持随机查找

  索引文件的缺点：索引表占大量空间

* 索引顺序文件 —— 一组记录对应一个索引
* 文件按照某个**关键字进行分组**，每组是一个**顺序文件**

​	分组内部是串结构，索引表是串结构

索引顺序文件的检索效率：

![image-20250430141241034](imgs\image-20250430141241034.png)

* 文件有 n 条记录，使用索引顺序文件方式存储，平均查找次数是 $\sqrt{n} * \frac{2}{2} = \sqrt{n}$ 次
* 对于 n 很大的情况，$\sqrt{n}$ 依然很多

##### 多级索引顺序文件

![image-20250430141700532](imgs\image-20250430141700532.png)

* 建立二级索引，此时平均需要查找 $\sqrt[3]{n} * \frac{3}{2}$ 次

  建立三级索引，平均需要查找 $\sqrt[4]{n} * \frac{4}{2} $ 次

![image-20250430142308029](imgs\image-20250430142308029.png)

## 文件目录

### 目录、文件控制块

![image-20250430144437682](imgs\image-20250430144437682.png)

* 目录 = 文件夹，是一种特殊的**有结构文件**，每个目录项对应一个文件/文件夹

* 一条文件记录 = 一个文件目录项 = 一个**文件控制块 FCB**

  FCB 最重要最基本的属性，就是**文件名**和**物理地址**

  **FCB** 实现了文件名与文件之间的映射，使得用户（用户程序）可以实现**按名存取**

* 每次打开一个目录，都相当于根据目录文件名**访问外存**读入了一次数据

### 文件操作

![image-20250430145019237](imgs\image-20250430145019237.png)

### 目录结构

#### 1）单级目录结构

![image-20250430145310095](imgs\image-20250430145310095.png)

* 单级目录结构 —— 整个系统中只有一个目录

  根目录下全是普通文件，没有文件夹

* 每个文件创建之前会检查系统里有没有重名文件（同一个文件夹下的文件不允许重名，系统里只有一个文件夹）

* 缺：不适合多用户操作系统

#### 2）两级目录结构

![image-20250430145754154](imgs\image-20250430145754154.png)

* 两级目录结构 —— **主文件目录MFD** 下有 **用户文件目录UFD**
* **允许**不同用户的文件重名
* 可以实现**访问限制**（根据用户名和访问文件路径是否匹配）
* 缺：用户不能对自己的文件分类

#### 3）多级目录结构

![image-20250430150227682](imgs\image-20250430150227682.png)

* 多级目录结构 = 树形目录结构

![image-20250430150852075](imgs\image-20250430150852075.png)

* 从根目录出发的文件路径 叫 **绝对路径**

  例如绝对路径 “ /一级目录/二级目录/文件名”（“/”是根目录）

  访问这样的文件一共需要 3次磁盘I/O操作（根据根目录里的外存地址访问一级目录，根据一级目录里的外存地址访问二级目录，根据二级目录里的外存地址访问文件）

* **连续访问同一个目录下的多个文件时，绝对路径的访问效率低于相对路径**

  例如相对路径 "./一级目录/文件名" ("./"是当前目录)
  
  访问这样的文件一共需要 2次磁盘I/O操作（根据当前目录里的外存地址访问一级目录，根据一级目录里的外存地址访问文件）
  
* **树形目录结构不便于实现文件的共享**

#### 4）无环图目录结构

![image-20250430222338423](imgs\image-20250430222338423.png)

* 可以用 **不同的文件名** 指向 **同一个文件**
* **文件、目录**都可以共享
* 删除共享文件 —— **共享计数器**，只有当共享计数器=0时真正删除文件
* **共享文件** 不是 复制文件，两者指向**同一份数据**

### 索引结点

![image-20250430223038994](imgs\image-20250430223038994.png)

* 索引结点 —— FCB的改进，提升查找速度

* 简化目录表 —— 查找各级目录的过程中只需要用到“文件名”这个信息，查找匹配后才需要其它FCB属性（如外存地址等）

  * 目录表仅包含 **文件名 + 索引结点指针**
  * 指针指向的**索引结点中包含 FCB 的其它属性信息**
  * 由于目录表空间减小，可以用更少的页面存储，查找目录时I/O操作更少

* 索引结点平时在外存，访问到对应目录项时调入内存

  * **磁盘索引结点** —— 存放在外存中的索引结点
  * **内存索引结点** —— 存放在内存中的索引结点

  相比之下，内存索引节点需要**增加**一些信息，比如文件是否被修改、此时有几个进程在访问该文件

![image-20250430223625629](imgs\image-20250430223625629.png)

## 文件物理结构/文件分配方式

<img src="imgs\image-20250430225302095.png" alt="image-20250430225302095" style="zoom: 50%;" />

<img src="imgs\image-20250430232056071.png" alt="image-20250430232056071" style="zoom:50%;" />

* 文件物理结构/文件分配方式 —— 文件在外存怎样存放

![image-20250430232207238](imgs\image-20250430232207238.png)

* 一般**磁盘块的大小 = 内存块的大小**（内存和外存交互是以块为单位的）

![image-20250430232416453](imgs\image-20250430232416453.png)

* 类似 **进程在内存分页存储**，操作系统负责 逻辑地址 + 块内偏移量 -> 物理地址 + 块内偏移量

  ​	**文件在外存分页存储**，操作系统负责 逻辑地址 + 块内偏移量 -> 物理地址 + 块内偏移量

  用户都只需要知道逻辑地址

### 1）连续分配

<img src="imgs\image-20250501000142693.png" alt="image-20250501000142693" style="zoom:50%;" />

* 文件的所有分块，存储在连续的磁盘块上
* FCB需要存储 **起始块号** 和 **长度**
* 操作系统负责映射 —— 物理块号 = 起始块号 + 逻辑块号
* 优：
  * 支持**顺序访问和直接访问**
    * 顺序访问 —— 只能从前往后访问（类似单链表）
    * 随机访问 = 直接访问 —— 访问某个块不需要前置访问其它块
  * 顺序读写数据时，连续分配的方式最**快**（磁头的移动距离最近）

* 缺：
  * **不便扩展**（想扩容时发现后续位置已经被其他文件占用）
  * 必须连续存储，产生**磁盘碎片**，存储空间利用率低（类似外部碎片，可以通过紧凑方式解决但耗费时间）

### 2）链式分配

* 链接分配 —— 可以为文件离散分配磁盘块
* 如果没有特殊说明，链式分配**默认指隐式链接方式**

#### i. 隐式链接

<img src="imgs\image-20250501000111131.png" alt="image-20250501000111131" style="zoom: 50%;" />

* FCB需要存储 **起始位置** 和 **结束位置**
* 操作系统负责映射 —— **每个块内存放下一个块的索引**
* 优：
  * 方便扩展（只需要修改链尾，然后修改FCB中的结束位置），不会有碎片问题，外存利用率高
* 缺：
  * 只支持顺序访问，不支持随机访问，查找效率低
  * 指向下一个盘块的指针也要耗费存储空间

#### ii. 显示链接 (有FAT)

![image-20250501000626308](imgs\image-20250501000626308.png)

* FCB需要存储 **起始位置**

* **整个磁盘有一个**专门的 **文件分配表FAT** 存放每一个块 **下一个块的块号**

* **开机时，FAT读入并常驻内存**

* 操作系统负责映射 —— 根据起始位置，一直查FAT，查到第i块

  FAT在内存，所以逻辑块号 -> 物理块号不需要访问磁盘

* 优：

  * 方便扩展（只需要修改链尾，然后修改FCB中的结束位置），不会有碎片问题，外存利用率高
  * 支持随机访问
  * 相比于隐式链接，地址转换不需要访问磁盘，文件访问效率更高

* 缺：

  * FAT要耗费存储空间

### 3）索引分配

![image-20250501195623297](imgs\image-20250501195623297.png)

* 索引分配 —— 类似内存管理中的分页

  * 基本分页存储 —— 每个进程对应一个页表，页表里存储了进程离散分布的块

    页表反映进程的 逻辑块号 和 物理块号 的映射关系，逻辑块号隐式存储

  * **索引分配** —— 每个文件对应一个**索引表**，索引表里存储了文件离散分配的块

    索引表反映文件的 逻辑块号 和 物理块号 的映射关系，**逻辑块号隐式存储**

    假设磁盘有 1TB ，块大小是 1KB，则磁盘有 $1TB / 1kB = 2^{30}$ 个块，块地址30位，可以用4B存储，所以**索引表项长度**是4B

* FCB需要存储**索引块的块号**

  * 存放索引表的块，叫做文件的索引块

  * 存放文件数据的块，叫做文件的数据块

* 页表 —— 每个进程对应一个

  FAT —— 每个磁盘对应一个

  索引表 —— 每个文件对应一个

* 操作系统负责映射 —— 根据FCB的索引块号，找到索引表，查询第i个块所在索引表项找到物理块号，计算并访问物理地址

#### i. 链接方案

* 索引分配的问题 —— 用一个块号指向索引表，但索引表的大小可能会超过一个块

![image-20250501195058778](imgs\image-20250501195058778.png)

* 链接方案 —— 每个索引块内存放指向下一个索引块的链接
* 缺：索引块内部可以随机访问，但索引块之间必须顺序访问（例如要访问第5个索引块的某个索引表项，必须先顺序访问前四个块）

#### ii. 多层索引

![image-20250501200155309](imgs\image-20250501200155309.png)

* 多层索引 —— 类似多级页表，每个文件对应一个**一级索引表**
* 如果使用多层索引，各层索引表的大小不能超过一个磁盘块
* 一个磁盘块占 mKB，采用 n 层索引，每层索引可以存储 p 个索引表项
  * **文件最大长度** —— $p^n * m$ KB
  * **访问I/O次数** —— $n + 1$ 次（前n次访问各级索引表，最后一次访问数据磁盘块）
* 缺：对小文件不友好，假设系统使用两层索引，对于一个只有1KB的文件也必须访问I/O 3次

#### iii. 混合索引

![image-20250501200947543](imgs\image-20250501200947543.png)

* 混合索引 —— 多种索引分配方式的结合

* 每个文件对应一个顶级索引表，顶级索引表里有直接地址、一级间接、二级间接等

  文件最大容量 = 所有级别的索引分配方式的存储空间之和

* 优：对于小文件，只需要使用到直接地址，访问数据块时，访问I/O次数少


![image-20250501201628088](imgs\image-20250501201628088.png)

![image-20250501201802478](imgs\image-20250501201802478.png)

### 逻辑结构 VS 物理结构

![image-20250501203502377](imgs\image-20250501203502377.png)

* 链式存储 VS 链接分配

  * 链式存储：例如数据结构里创建链表，用户自己设置一个 next 变量指向下一个结点

    ​		   用户创建了怎样的结构体，操作系统不关心

  * 链接分配：不管用户设置的是流式文件、顺序表还是链表，操作系统存储文件数据的方式是离散存储在外存

    ​		   操作系统选用什么样的物理结构存储文件，用户并不清楚

* 索引文件 VS 索引分配

  类似于上一项，一个是用户设置的操作系统不关心，一个是操作系统设置的用户不关心

![image-20250501203445126](imgs\image-20250501203445126.png)

## 文件存储空间管理

<img src="imgs\image-20250430225302095.png" alt="image-20250430225302095" style="zoom: 50%;" />



### 存储空间的划分与初始化

![image-20250502130337536](imgs\image-20250502130337536.png)

* **目录区 + 文件区 = 文件卷** = 逻辑卷 = 逻辑盘 = 逻辑磁盘（C盘、D盘各是一个文件卷）

  * 目录区 —— 存FCB、索引结点、用于磁盘管理的信息（如空闲表）
  * 文件区 —— 文件数据

* 不仅可以一个物理磁盘划分成多个文件卷

  也可以多个物理磁盘合成一个文件卷

### 1）空闲表法

![image-20250502131052645](imgs\image-20250502131052645.png)

* 空闲表法 —— **空闲表项 = 起始块号 + 区块数量**

  ​			 适用于连续分配的物理结构

* 分配磁盘块 —— 首次适应 / 最佳适应 / 最坏适应 / 邻近适应算法

* 回收磁盘块 —— 前空后空 / 前空后满 / 前满后空 / 前满后满（空闲表长度可能增大、减小、不变）

### 2）空闲链表法

![image-20250502131243589](imgs\image-20250502131243589.png)

* 空闲盘块链 —— 每个**空闲盘块**存储下一个空闲盘块的**指针**

  ​			     操作系统存链首和链尾指针

* 空闲盘区链 —— 每个**空闲盘区的首个块**存储 **当前盘区块数度 + 下个盘区指针**

  ​	 		    操作系统存链首和链尾指针

![image-20250502131537769](imgs\image-20250502131537769.png)

* 空闲盘块链 —— 适用于**离散分配**的物理结构
  * 分配磁盘块 —— 从链首数k个块划出，改变链首
  * 回收磁盘块 —— 把块依次挂到链尾，改变链尾

![image-20250502131922678](imgs\image-20250502131922678.png)

* 空闲盘区链 —— 适用于**连续分配、离散分配**的物理结构

  * 分配磁盘块 —— 根据首次适应 / 最佳适应 / 最坏适应 / 邻近适应算法，找到合适的盘块

    ​			     或者没有满足大小的盘块，也可以分配多个盘块

    ​			     改变链指针、盘区大小等因素

  * 回收磁盘块 —— 前空后空 / 前空后满 / 前满后空 / 前满后满（盘区数可能增大、减小、不变）

    ​			     改变链指针、盘区大小等因素

  为一个文件分配多个盘块时，**空闲盘区链**比空闲盘块链**效率更高**

### 3）位示图法

![image-20250502132907376](imgs\image-20250502132907376.png)

* 位示图法 —— 用0/1标识一个块是否已被分配，把所有块号的分配信息按字存储

  * 字号 —— 第几个字，例如字长是16bit，则0-15号块的分配信息就存在0号字，16-31号块的分配信息就在1号字
  * 位号 —— 第几位，例如2号块的分配信息存在2号位，16号字的分配信息存在0号位

  以上以磁盘号、字号、位号均从0开始作为例子，题中可能不同

![image-20250502133436254](imgs\image-20250502133436254.png)

* 位示图法 —— 适用于连续分配、离散分配的物理结构
  * 分配磁盘块 —— 数k个分配信息为空闲的块；字号、位号->盘块号；改这k个块的分配信息
  * 回收磁盘块 —— 盘块号->字号、位号；改这k个块的分配信息

### 4）成组链接法

![image-20250502134702802](imgs\image-20250502134702802.png)

* 空闲表、空闲链表不适用于大型系统（占大量额外空间）
* 超级块 ——
  * 在文件卷的目录区
  * **系统启动时读入内存**
  * 内外存超级块信息，时刻同步
  * 记录 下一组空闲盘块的数量 + 空闲盘块号

![image-20250502143645660](imgs\image-20250502143645660.png)

* 成组链接法 —— **每组的第一个盘块** 记录 **下一组空闲盘块的数量 + 空闲盘块号**（超级块里存的是第一组，访问超级块是在内存）

  相当于把空闲磁盘块分组（每个组包含的空闲磁盘块数目在上一个分组里显示），组间有链接

* **最后**一个分组，代表**下一组第一个**空闲磁盘号的位置，被指为**特殊数字**（0/-1，由系统决定），用于标识已经是最后一个分组了

* 分配磁盘块 —— 检查 第一个分组的块数 和 申请的空闲块数 的关系

  * 大于：

    <img src="imgs\image-20250502143447149.png" alt="image-20250502143447149" style="zoom: 20%;" /> -》<img src="imgs\image-20250502143514843.png" alt="image-20250502143514843" style="zoom:20%;" />

    从第一个分组里分出空闲块，修改下一组空闲盘块的数量

  * 等于： 

     <img src="imgs\image-20250502144115723.png" alt="image-20250502144115723" style="zoom:20%;" /> -》<img src="imgs\image-20250502144159830.png" alt="image-20250502144159830" style="zoom:20%;" />

    把第二个分组的信息存入超级块，然后分配第一个分组所有空闲块

  * 小于：分成 等于 + 等于 + ...等于 + 大于 的情况

* 回收磁盘块 —— 检查回收到第一组后，第一组的状态

  * 回收到第一组后，第一组不溢出（假设提前规定好了每组最多有多少个快）：

    <img src="imgs\image-20250502144518900.png" alt="image-20250502144518900" style="zoom:20%;" /> -》<img src="imgs\image-20250502144547411.png" alt="image-20250502144547411" style="zoom:20%;" />

    回收到第一组，修改下一组空闲盘块的数量

  * 溢出一个块：

    <img src="imgs\image-20250502145033228.png" alt="image-20250502145033228" style="zoom:20%;" /> -》<img src="imgs\image-20250502145110480.png" alt="image-20250502145110480" style="zoom:20%;" />

    把超级块内容存到新块里，新块作为新的第一层分组，原本的第一层变成第二层，超级块刷新数量和指针

![image-20250502172712805](imgs\image-20250502172712805.png)

## 文件的基本操作

### 1）创建文件 create

![image-20250502172955298](imgs\image-20250502172955298.png)

* 创建文件（create系统调用）：

  * 条件 —— 文件路径、文件名、文件大小

  * 操作系统动作 —— 根据文件大小分配空闲块；

    ​				根据文件路径和文件名在对应目录里创建目录项

### 2）删除文件 delete

![image-20250502173605883](imgs\image-20250502173605883.png)

* 删除文件（delete系统调用）：

  * 条件 —— 文件路径、文件名

  * 操作系统动作 —— 根据文件路径和文件名，找到目录项；

    ​				根据目录项的文件大小、物理地址回收磁盘块；

    ​				删除目录项

### 3）打开文件 open

![image-20250502202229198](imgs\image-20250502202229198.png)

* 打开文件（open系统调用）：

  * 条件 —— 文件路径、文件名、操作类型

  * 操作系统动作 —— 根据文件路径和文件名找到目录项；

    ​				根据目录项的用户权限，检查操作是否合法；

    ​				把目录项复制到**内存**中的“**打开文件表**”（后续访问不需要每次都访问磁盘）

    ​				返回 **文件描述符/文件句柄/fd，指向用户进程打开文件表的表项**

#### 用户进程 VS 系统 打开文件表

![image-20250502203015472](imgs\image-20250502203015472.png)

* 用户进程的打开文件表 —— 每个进程一个，记录当前用户进程打开的所有文件

  属性：编号、文件名、**读写指针、访问权限、系统表索引号**

  * “系统表索引号” —— 指向系统的打开文件表的某个表项
  * “读写指针” —— 记录目前访问到文件的哪个位置

* 系统的打开文件表 —— 整个系统只有一个，记录当前所有打开的文件

  属性：编号、文件名、外存地址、**打开计数器**等

  * “打开计数器”，记录有几个进程打开了该文件（删除文件时会查看系统表里打开计数器是不是0）

### 4）关闭文件 close

![image-20250502203208331](imgs\image-20250502203208331.png)

### 5）读文件 read

![image-20250502204102950](imgs\image-20250502204102950.png)

* 在 read、write 操作**之前**必须 open

  操作**之后**必须 close

* read 操作之前，**用户进程打开文件表** 已经存储了目录项，open操作返回了 **文件描述符/文件句柄/fd**

* 读文件（read系统调用）：
  * 条件 —— 文件描述符、读入长度、读入后在内存的存放位置
  * 操作系统动作 —— 根据当前读写位置（来自用户进程打开文件表里的读写指针）、读入长度、内存存放位置读入数据

### 6）写文件 write

![image-20250502204409411](imgs\image-20250502204409411.png)

* 写文件（write系统调用）：

  * 条件 —— 文件描述符、写回长度、写回前在内存的存放位置

  * 操作系统动作 —— 根据写回长度、写回前在内存的存放位置从内存读出数据；

    ​				根据当前读写位置（来自用户进程打开文件表里的读写指针）把数据写回外存

![image-20250502205500041](imgs\image-20250502205500041.png)

* 文件描述符 = 文件句柄 = **fd** = 用户进程打开文件表的**索引号**

* **open**系统调用，只是**把文件目录项调入到内存**（用户进程打开文件表、系统打开文件表）

  **read**系统调用，才是真正的**把文件数据**从外存调入内存

## 文件共享

* 文件共享 —— 操作系统提供的功能，让多个用户可以共享同一个文件

### 基于索引结点的共享方式 (硬链接)

![image-20250502210812441](imgs\image-20250502210812441.png)

* 硬链接 —— 索引结点（不同文件的目录项，**指向同一个索引结点**）
* 索引结点里有一个**count属性**，记录指向该结点的文件个数
* 尽管共享索引结点，指向索引结点的**文件名可以是不同的**

### 基于符号链的共享方式 (软链接)

![image-20250502210959239](imgs\image-20250502210959239.png)

* 软链接 —— 快捷方式（指针的指针）

  不同的文件指向不同的索引结点，但索引结点挂载了其他文件的路径

  ~~~txt
  ccc目录项 -> ccc索引结点 -> aaa目录项 -> aaa索引结点 -> aaa文件的物理地址，以此实现共享
  ~~~

* **软链接**需要经过多层访问，比硬链接**更慢**

* 采用软连接的文件，属于Link类型文件

* 硬链接和软链接可以同时存在

![image-20250502211813437](imgs\image-20250502211813437.png)

* 假如软链接的挂载对象被删除 —— Link文件依然存在，但失效

![image-20250502211935268](imgs\image-20250502211935268.png)

## 文件保护

### 1）口令保护

![image-20250503175210329](imgs\image-20250503175210329.png)

* 口令保护 —— 访问文件需要口令密码

* 优：开销小

  缺：不安全

### 2）加密保护

![image-20250503175919331](imgs\image-20250503175919331.png)

* 加密保护 —— 文件数据被加密成乱码，需要解密密码恢复数据

  ~~~txt
  例如使用“异或加密”的加密方式，采用“01001”做加密密码
  则每五个bit都会和01001异或一次，结果替代原数据
  解密时，通过01001的密码，再次每五个bit和01001异或一次，结果就是原数据
  ~~~

* 优：安全

  缺：开销大

### 3）访问控制 （有ACL）

![image-20250503180159520](imgs\image-20250503180159520.png)

* 访问控制 —— **每个文件**的FCB中，添加**一个访问控制表 ACL**，记录每一个用户的访问权限

![image-20250503180311453](imgs\image-20250503180311453.png)

* 精简的访问列表（节约存储空间） —— 访问分组，每个用户可以属于一个或多个组，每个组指定权限

![image-20250503180746000](imgs\image-20250503180746000.png)

* 如果对某个目录进行了访问权限的控制，那也要对**目录下的所有文件**进行相同的访问权限控制

### Linux文件权限

* 命令格式`chmod 权限 文件名`

* 一共九位
  * 分为三组，$1-3$位数字代表文件所有者的权限，$4-6$位数字代表同组用户的权限，$7-9$数字代表其他用户的权限
  * 每一组的第一位表示可读，第二位表示可写，第三位表示可执行

​	s如$755$，第一组的$7=4+2+1$表示所有者可读可写可执行，$5=4+0+1$表示同组用户和其他用户可读可执行但是不可写

## 文件系统的层次结构 (访问文件流程)

![image-20250503181354464](imgs\image-20250503181354464.png)

* 文件基本操作（用户read、write等系统调用）
* 文件目录（管理目录块的增删改查）
* 文件保护（比较用户操作和用户权限）
* 逻辑结构和文件信息缓冲区（逻辑结构里索引结构的索引表）
* 物理结构（逻辑地址 -> 物理地址)
* 辅助分配模块（非空闲块存储管理、空闲块分配回收）
* 设备管理（磁盘等硬件交互）

![image-20250503181907485](imgs\image-20250503181907485.png)

## 文件系统的全局结构

### 外存结构

![image-20250503182138664](imgs\image-20250503182138664.png)

* 物理格式化 = 低级格式化 —— 划分扇区
* 坏扇区对操作系统是透明的

![image-20250504152114016](imgs\image-20250504152114016.png)

* 逻辑格式化 = 高级格式化 —— 磁盘分区
  * 超级块 和 位示图 都记录空闲块，作用有所不同
    * 超级块 —— 快速查找分配空闲块
    * 位示图 —— 查看特定磁盘块是否是空闲块
  * **i结点区**（存放inode） —— 记录分区内所有文件的索引结点（**索引结点数组**）

### 内存结构

![image-20250504152650481](imgs\image-20250504152650481.png)

* 内存 = 用户区 + 内核区
  * 内核区 ：
    * 目录的缓存（加快检索速度）
    * 系统打开文件表（整个系统一张表）
    * 用户进程打开文件表（每个用户进程一张表，包含在进程PCB中）
  * 用户区：
    * 文件描述符/文件句柄/fd/索引号（open操作后，给用户返回文件描述符，指向用户进程打开文件表的表项）

## 虚拟文件系统 VFS

![image-20250504152958551](imgs\image-20250504152958551.png)

* 不同的硬件可能有不同的文件系统

  不同文件系统里，功能相同函数的函数名、参数个数可能各不相同

  —— 引入**虚拟文件系统 VFS**

* 虚拟文件系统 VFS 在 **内存的内核区**

### 虚拟文件系统的功能

* 为上层的用户进程，提供统一接口
* 对下层的文件系统，规定统一接口
* 用 vnode 提供统一的目录项格式，存储文件系统的函数功能列表

![image-20250504153740305](imgs\image-20250504153740305.png)

![image-20250504153750321](imgs\image-20250504153750321.png)

![image-20250504153608257](imgs\image-20250504153608257.png)

![image-20250504155408859](imgs\image-20250504155408859.png)

* vnode 的功能：

  1. 有 / 没有使用索引结点的目录项结构不同，vnode提供**统一格式**

     vnode 只存在于主存

     inode 是索引结点，访问对应目录项时会被调入内存

  2. 存储所属文件系统的**函数功能列表**

     vnode 是每个文件独有一份

     函数功能列表是每个文件系统独有一份

## 文件系统挂载

![image-20250504160430555](imgs\image-20250504160430555.png)

* 文件系统挂载 —— 如何将一个文件系统，挂载到一个操作系统上（例如插入U盘）

* 文件系统挂载流程：
  1. 修改**内存的挂载表**，添加一个对应表项（包括文件系统的类型、容量大小等属性）
  2. 提供**文件系统的函数地址列表**
  3. 加载**挂载点**，即挂载到某个特定位置（例如Windows系统插入U盘，默认挂载到此电脑下）





