# 设备管理

![image-20250430225706998](imgs\image-20250430225706998.png)

* 操作系统管理硬件和软件
  * 软件 —— 处理机管理、存储器管理、文件管理
  * 硬件 —— 设备管理

## I/O设备的概念

![image-20250430230100747](imgs\image-20250430230100747.png)

* I/O设备就是可以将**数据输入到计算机**，或者可以**接收计算机输出数据**的**外部设备**，属于硬件
  * 输入（鼠标、键盘）
  * 输出（显示器）
  * 输入+输出（U盘）

* UNIX 系统把 I/O 设备抽象为**文件**

  可以进行 read 和 write 操作

## I/O设备的分类

![image-20250430230242227](imgs\image-20250430230242227.png)

![image-20250430230307715](imgs\image-20250430230307715.png)

![image-20250430230337124](imgs\image-20250430230337124.png)

* 块设备可寻址

  字符设备不可寻址，常采用中断驱动的方式（CPU每执行一条指令，都会检查一次外中断）

## I/O硬件

* I/O设备硬件部分 = 机械部件 + 电子部件

  * 机械部件 —— 具体执行 I/O 操作的部件

  * **电子部件 = I/O控制器** —— CPU 和 I/O设备的机械部件 之间的**中介**（印刷电路板）

    用于实现CPU对 I/O 设备的控制

### I/O控制器

![image-20250504212328955](imgs\image-20250504212328955.png)

* 四大功能

![image-20250504212755478](imgs\image-20250504212755478.png)

* 三大部分 —— 和CPU交互、处理逻辑、和外设交互

* 一个I/O控制器可能连接**多个I/O设备**

  一个I/O控制器可能**不止一组寄存器组**

* 控制线 —— 控制命令

  控制寄存器 —— 控制命令参数

### 内存映像I/O VS 寄存器独立编址

![image-20250504213208241](imgs\image-20250504213208241.png)

* **内存映像I/O = 统一编址**
* **寄存器独立编址 = 独立编址**

![image-20250504213307705](imgs\image-20250504213307705.png)

## I/O控制方式

### 1）程序直接控制方式

![image-20250504213603316](imgs\image-20250504213603316.png)

* CPU 轮询

![image-20250504213914797](imgs\image-20250504213914797.png)

* 每次读/写一个字
* 每次读写必须CPU参与
* CPU和I/O设备**串行执行**，设备利用率低

### 2）中断驱动方式

![image-20250504214258528](imgs\image-20250504214258528.png)

* 每次读/写一个字
* 每次读写必须CPU参与
* CPU和I/O设备并行执行，但频繁切换上下文开销大 
* CPU每执行一条指令，都会检查一次外中断

### 3）DMA方式

![image-20250504214908022](imgs\image-20250504214908022.png)

* **直接存储器存取 = DMA**

  DMA控制器是**一种特殊的I/O控制器**

* 每次读/写一个或多个**块**（CPU给DMA读/写外存地址、写/读内存地址、读/写长度，DMA完成一次数据读写才向CPU报告一次）

* CPU仅在一次传送的**开始和结束**时参与

* DMA和内存之间是逐字读入的

![image-20250504215212972](imgs\image-20250504215212972.png)

* 每次DMA只能读写**连续**的块，不能读写离散块

### 4）通道控制方式

![image-20250504215345884](imgs\image-20250504215345884.png)

* CPU通过提供**通道指令（程序清单）内存地址 + 执行对象**，提醒控制通道程序执行指令完成I/O操作

![image-20250504215540591](imgs\image-20250504215540591.png)

* 通道控制方式可以一次读/写一组离散块
* CPU 参与率比DMA更低
* 一个通道可以控制**多个I/O控制器**

![image-20250504215758114](imgs\image-20250504215758114.png)

## 四层I/O软件

![image-20250504222337138](imgs\image-20250504222337138.png)

![image-20250504223710554](imgs\image-20250504223710554.png)

* **中断处理程序 + 设备驱动程序 + 设备独立性软件 = I/O系统 = I/O核心子系统**，属于操作系统**内核**部分

* 用户层软件 —— 把操作系统提供的I/O**系统调用**封装成提供给用户的**库函数**

* 设备独立性软件 = 系统调用处理层 = 设备无关性软件 —— 实现与硬件特性无关的I/O功能

  * 为上层提供系统调用接口

  * 设备保护（权限管理）

  * 差错处理（设备错误处理）

  * 设备分配与回收（I/O设备是临界资源）

  * 数据缓冲区管理（屏蔽设备之间数据**交换单位大小**和**传输速度**的**差异**）

  * 逻辑设备名 -> 物理设备名，根据设备类型调用驱动程序（通过 **逻辑设备表 LUT**）

    * LUT设计方式 —— 整个系统只有一个LUT 或 每个用户都有一个LUT（类似单级目录结构、两级目录结构）

      **用户的LUT存放在用户管理进程的PCB中**

* 设备驱动程序 —— I/O设备厂家提供设备驱动程序，向操作系统提供控制硬件的接口

* 中断处理程序 —— 硬件执行完毕后、或发生异常时发出中断信号，中断处理程序负责处理中断信号执行对应指令

* 用户层软件、设备独立性软件 **不需要**和硬件直接接触

  设备驱动程序、中断处理程序 **可能会**和硬件直接接触

### 层间接口

#### 1）输入输出应用程序接口

![image-20250504225953671](imgs\image-20250504225953671.png)

* 输入输出应用程序接口 —— **I/O子系统 和 用户层软件 之间**的接口
* 字符设备接口 —— get/put（逐字读写）
* 块设备接口 —— seek + read/write（要寻址）
* 网络设备接口 = 网络套接字接口 = socket接口 —— bind + connect + read/write（connect需要IP地址和端口号以建立远程连接）

阻塞I/O 和 非阻塞I/O：

![image-20250504230253810](imgs\image-20250504230253810.png)

* 阻塞I/O —— 进程会**阻塞等待**I/O完成(scanf)
* 非阻塞I/O —— 进程**不等待**I/O完成(write)

#### 2）设备程序驱动接口

![image-20250504230748347](imgs\image-20250504230748347.png)

* 设备独立软件层 调用 驱动程序层

  为了防止操作系统内核代码被不断修改，要**规定驱动程序的统一接口**

![image-20250504230926564](imgs\image-20250504230926564.png)

### 上层软件功能

#### 1）用户层软件

![image-20250504231148325](imgs\image-20250504231148325.png)

##### 假脱机技术 SPOOLing

* 假脱机技术的实现需要用到设备独立性软件层的功能，所以是**用户层软件**技术

  有时被认为是**设备独立性软件**的技术

###### 脱机技术

![image-20250504232450997](imgs\image-20250504232450997.png)

* 脱机技术 —— 从数据 -(手工)-> 计算机 -(手工)-> 数据

  ​			进化为 数据 -(**外围控制机**)-> **磁带** -> 计算机 -> 磁带 -(外围控制机)-> 数据

* 优：

  * 磁带 -> 计算机，比手工输入更快，缓解了低速I/O和CPU的**速度**矛盾
  * 数据 -(外围控制机)-> 磁带、磁带 -(外围控制机)-> 数据 的过程，可以和CPU运行 **并行**执行

###### 假脱机技术的系统组成

![image-20250504235015594](imgs\image-20250504235015594.png)

* 假脱机技术 = SPOOLing技术 —— 用**软件**的方式实现**脱机技术**

* 脱机技术 —— 数据 -(外围控制机)-> 磁带 -> 计算机 -> 磁带 -(外围控制机)-> 数据

  假脱机技术 —— 输入设备 -(输入进程)-> 输入井 -> 计算机 -> 输出井 -(输出进程)-> 输出设备

* 输入井、输出井在**磁盘**

  此外**内存**中会开辟输入缓冲区、输出缓冲区

* 为了实现输入设备 -(输入进程)-> 输入井、输出井 -(输出进程)-> 输出设备、CPU运行的过程**并行**执行

  **输入进程、输出进程、用户进程 必须可以并发执行**，才能实现假脱机技术

###### 共享打印机原理

![image-20250504235440675](imgs\image-20250504235440675.png)

* 独占式设备 —— 不允许并发占用（打印机）

  共享设备 —— 允许并发甚至并行占用（扩音器）

* 打印机本质是**独占式设备**，但使用**SPOOLing技术**伪装实现了**共享**

![image-20250506082414310](imgs\image-20250506082414310.png)

* SPOOLing技术实现共享打印机 —— 
  * 每个用户进程申请打印机，系统都**同意**
  * **假脱机管理进程 + 输出进程**负责实现共享 ——
    * 假脱机管理进程：
      1. 在**磁盘**输出井中，为进程申请一个空闲**缓冲区**，打印**数据**放入缓冲区
      2. 生成用户**打印请求表**（打印说明书），把该表挂到**假脱机文件队列**上
    * 输出进程：
      1. 从假脱机文件队列中取出一个任务
      2. 根据打印请求表执行任务（数据流向：**磁盘输出井缓冲区 -> 内存输出缓冲区 -> 打印机**）

![image-20250506082607983](imgs\image-20250506082607983.png)

* 磁盘**输出井**里，分配给进程的**缓冲区**，相当于给进程分配了一个**逻辑设备**

![image-20250506082748528](imgs\image-20250506082748528.png)

#### 2）设备独立性软件

##### 1）I/O调度

![image-20250504231513657](imgs\image-20250504231513657.png)

* I/O调度 —— 有多个I/O请求时，确定先后处理顺序

##### 2）设备保护

![image-20250504231851349](imgs\image-20250504231851349.png)

* UNIX 系统把 I/O 设备抽象为**文件**

  所以 **I/O设备 也有自己的 文件控制块FCB**

* 通过**文件保护**实现设备保护

##### 3）设备分配与回收

###### 设备分配时的考虑因素

![image-20250506083057586](imgs\image-20250506083057586.png)

* 设备分配时需要考虑的因素：
  * 设备固有属性 —— 独占设备、共享设备、虚拟设备
  * 设备分配算法 —— 先来先服务、高优先级优先、短作业优先等
  * 设备分配方式 —— 
    * 安全分配方式 —— 进程获得设备就阻塞（CPU与外设串行）
    * 不安全分配方式 —— 进程获得设备正常继续运行（可能发生死锁，通过银行家算法避免死锁）

###### 静态分配 VS 动态分配

![image-20250506084646721](imgs\image-20250506084646721.png)

* **静态分配**，破坏了死锁四大条件中的“**请求和保持**”

###### DCT、COCT、CHCT、SDT

![image-20250506084943568](imgs\image-20250506084943568.png)

* 系统中每个**通道**可能管理多个**控制器**

  每个控制器可能管理多个**设备**

* **设备控制表 DCT** —— 每个设备对应一个
  * 指向控制器表的指针 —— 指向设备所属的控制器
  * 重复执行次数或时间 —— 记录失败次数或时间
  * 设备队列的队首指针 —— 设备对应的阻塞队列指针

![image-20250506085454581](imgs\image-20250506085454581.png)

* **控制器控制表 COCT** —— 每个控制器对应一个
  * 指向通道表的指针 —— 指向控制器所属的通道
  * COCT 也有阻塞队列

![image-20250506085613852](imgs\image-20250506085613852.png)

* 通道控制表 CHCT —— 每个通道对应一个
  * 与通道连接的控制器表首址 —— 指向通道控制的控制器表
  * 通道也有阻塞队列

![image-20250506085826294](imgs\image-20250506085826294.png)

* 系统设备表 SDT —— 每个系统对应一个

  记录系统中全部设备的情况

* SDT的表目，用于根据名称快速查找DCT，以及驱动硬件

###### 设备分配步骤和改进

![image-20250506090239875](imgs\image-20250506090239875.png)

* SDT -> DCT -> COCT -> CHCT
* 只有 DCT、COCT、CHCT 三者都分配成功时，这次设备才算分配成功

![image-20250506090558942](imgs\image-20250506090558942.png)

* 缺：需要指定物理设备名；物理设备名可变；不能智能识别空闲的同类型设备
* 解决方案 —— 物理设备名 -> **逻辑设备名(设备类型)**

![image-20250506091142094](imgs\image-20250506091142094.png)

* **逻辑设备表LUT** —— 存储逻辑设备名 -> 物理设备名的映射，驱动程序入口地址
* 根据逻辑设备名，查找到对应物理设备并分配给进程后，**LUT新增一个表项**

* LUT**首次记录**了逻辑设备名 -> 物理设备名的映射，以及逻辑设备名对应的驱动程序入口后

  进程**访问同类型设备** —— 第一步就不需要访问SDT，而是直接访问LUT

* LUT设计方式 —— 整个系统只有一个LUT 或 每个用户都有一个LUT（类似单级目录结构、两级目录结构）

  **用户的LUT存放在用户管理进程的PCB中**

![image-20250506092123247](imgs\image-20250506092123247.png)

##### 4）缓冲区管理

![image-20250506100232850](imgs\image-20250506100232850.png)

1. 硬件作为缓冲区 —— 快表（用专门的硬件做缓冲）

2. 内存作为缓冲区 —— 设备独立性软件的缓冲区（在内存的输出缓冲区和输入缓冲区）

![image-20250506100627250](imgs\image-20250506100627250.png)

###### i. 单缓冲

![image-20250506101020909](imgs\image-20250506101020909.png)

* 默认**一个缓冲区**的大小是**一个块**

* **缓冲区满**才能**取数据**，缓冲区空才能写数据

* 每处理一块数据平均需要多久 —— 假定一个初始状态，分析下次到达**相同状态**需要多少时间（如工作区满，缓冲区空）

* 单缓冲 —— 分配一个缓冲区

  每处理一块数据平均需要：**Max(C, T) + M**（T：外设->缓冲区、M：缓冲区 -> 用户进程、C：CPU处理数据）

###### ii. 双缓冲

![image-20250506101548188](imgs\image-20250506101548188.png)

![image-20250506101607883](imgs\image-20250506101607883.png)

* 双缓冲 —— 分配两个缓冲区

  每处理一块数据平均需要：**Max(T, C+M)**

![image-20250506102119240](imgs\image-20250506102119240.png)

![image-20250506102318794](imgs\image-20250506102318794.png)

* 单/双缓冲除了用于**主机与设备**间数据传输，也可以用于**主机之间**的通信
  * 单缓冲区 —— 同一时刻只能单向传输数据
  * 双缓冲区 —— 同一时刻可以双向传输数据

###### iii. 循环缓冲区

![image-20250506102457321](imgs\image-20250506102457321.png)

* **大小相等**的缓冲区链接成**循环队列**
* in、out 指针分别指向下一个空、满缓冲区

###### iv. 缓冲池

![image-20250506103024639](imgs\image-20250506103024639.png)

* 三个缓冲队列
* 四个工作缓冲区

![image-20250506102757465](imgs\image-20250506102757465.png)

## 磁盘

### 磁盘的结构

![image-20250506135952029](imgs\image-20250506135952029.png)

* 磁盘、磁头、盘块、盘片、磁道、扇区

* 磁盘每个**扇区**存储的数据量**相同**（最内侧扇区的存储密度最大）

  许多操作系统位改善磁盘访问时间，不以扇区为单位，而是以**簇**为单位近空间分配

![image-20250506140411298](imgs\image-20250506140411298.png)

* 盘面、柱面
* 一个盘片可能有两个盘面
* 每个盘面对应一个磁头
* **柱面号 + 盘面号 + 扇区号 = 磁盘块号**

### 磁盘的分类

![image-20250506140519538](imgs\image-20250506140519538.png)

* 活动头磁盘
* 固定头磁盘

![image-20250506140954238](imgs\image-20250506140954238.png)

* 可换盘磁盘
* 固定盘磁盘

![image-20250506140924878](imgs\image-20250506140924878.png)

### 磁盘调度算法（-寻道时间）

![image-20250506141644917](imgs\image-20250506141644917.png)

* **读/写一次磁盘的时间 = 寻道时间 + 延迟时间 + 传输时间**

  * **寻道时间 = 启动磁头臂 + 移动磁头**（$T_s=s+m\times n$，m是跨越一条磁道时间，n是要跨越的磁道数）

  * 延迟时间 —— 找到扇区的平均时间（$T_r=\dfrac{1}{2}\times\dfrac{1}{r}=\dfrac{1}{2r}$，r是转速）

  * 传输时间 —— 传输数据时间（$T_t=\dfrac{b}{rN}$，b/N指要传输的数据占整条磁道的比例）

  * 其中**移动磁头**的时间，根据不同的寻道策略可能发生变化

    其他都和硬件有关，不能通过操作系统的策略改变速度

#### 1）先来先服务算法 FCFS

![image-20250506142756074](imgs\image-20250506142756074.png)

#### 2）最短寻找时间优先算法 SSTF

![image-20250506143054866](imgs\image-20250506143054866.png)

* 追求眼前最优，但不一定总体最优
* 可能导致饥饿

#### 3）扫描算法 SCAN

![image-20250506143244780](imgs\image-20250506143244780.png)

* **扫描算法 = 电梯算法**
* 来回扫描，即使不访问200号，为了能折返访问也必须把磁头移动到200号

#### 4）LOOK调度算法

![image-20250506143450859](imgs\image-20250506143450859.png)

* 解决了 SCAN 的第一个缺点：多余扫描磁道

#### 5）循环扫描算法 C-SCAN

![image-20250506143716453](imgs\image-20250506143716453.png)

* 解决了 SCAN 算法的第二个缺点：扫描频率不平均
* 不再来回扫描，而是从头到尾，扫描到尾部后立刻折返头部（在这期间不处理扫描任务），重新开始从头到尾扫描

#### 6）C-LOOk算法

![image-20250506144019038](imgs\image-20250506144019038.png)

* LOOK + C-SCAN

![image-20250506144231717](imgs\image-20250506144231717.png)

### -延迟时间的方法

![image-20250506144911099](imgs\image-20250506144911099.png)

* 磁头每访问一个扇区都需要时间处理

  如果**连续访问相邻扇区**需要等待不止一轮磁盘转动

#### 1）交替编号

<img src="imgs\image-20250506152545592.png" alt="image-20250506152545592" style="zoom: 50%;" />

* 此时访问连续的0、1、2、3逻辑块，只需要**转一轮**
* 如果要访问0、1、2、3、4、5、6、7，需要**转两轮**

#### 磁盘地址结构设计

![image-20250506152957669](imgs\image-20250506152957669.png)

![image-20250506153038300](imgs\image-20250506153038300.png)

* **磁盘块号 = 柱面号 + 盘面号 + 扇区号**
* **柱面号在盘面号之前**，这样读取地址连续的磁盘块时，可以**减少磁头移动消耗的时间**

#### 2）错位命名

![image-20250506153756820](imgs\image-20250506153756820.png)

![image-20250506153932794](imgs\image-20250506153932794.png)

* 采用错位命名前 —— 所有盘面相对位置相同处扇区号相同

  访问连续数据时（跨盘），访问下一个扇区需要再等待一轮

* 错位命名 —— 下一个盘面相比上一个盘面，扇区号按照磁盘转动的方向往后错了一位

  访问连续数据时（跨盘），可以直接访问下一个扇区

![image-20250506154441795](imgs\image-20250506154441795.png)

### 磁盘的管理

#### 磁盘初始化

![image-20250506154829955](imgs\image-20250506154829955.png)

* 低级格式化 = 物理格式化 —— 分扇区

  每个扇区由头和尾组成，**头部存储数据**，尾部存储链接指针（链接存储时用）、校验码之类数据

* 磁盘分区 —— 分C、D、E盘

* 逻辑格式化 —— 创建文件系统

#### 磁盘引导块

![image-20250506225645032](imgs\image-20250506225645032.png)

* **自举程序 = 初始化程序** —— 完成计算机开机需要执行的初始化步骤（例如初始化内存、寄存器等）
* **内存** = RAM + ROM

  * 其中ROM是 基本输入输出系统BIOS，包含ROM引导程序，即**自举程序**
  * ROM的特点是**只读**，大多数ROM不会断电即失

  自举程序在内存，而且只读

* 然而有时需要**更新自举程序** —— 
  * **ROM**里仅存放**自举装入程序**
  * 自举程序在**启动磁盘/系统磁盘/C盘**的**启动快/引导块/启动分区**上

#### 坏块的管理

![image-20250506230009953](imgs\image-20250506230009953.png)

1. 对操作系统不透明 —— 在**逻辑初始化**时，把坏块标注到 **FAT** 上
2. 对操作系统透明 —— 在**物理初始化**时，把坏块用**备用扇区**替代

![image-20250506230203239](imgs\image-20250506230203239.png)

### 固态硬盘 SSD

![image-20250506230353479](imgs\image-20250506230353479.png)

* 机械硬盘 —— 由**盘片**等组成，通过磁性物质记录数据
* 固态硬盘SSD —— 由**芯片**组成，本质是电可擦除ROM（**EEPROM**），基于**闪存技术**记录数据

#### SSD 结构

![image-20250506230948562](imgs\image-20250506230948562.png)

* **SSD = 闪存翻译层 + 存储介质（芯片）**

* **闪存翻译层** —— 逻辑地址 -> 物理地址

* 1个SSD -> n个闪存芯片

  1个闪存芯片 -> n个块

  1个块 -> n个页

* 系统对 SSD 的 **读写以页为单位**

  ​			 **擦除以块为单位**

* 修改某个页的数据 —— 

  * 把所属块**其它页的数据复制到新块**
  * 把**修改过的页写到新块**
  * 闪存翻译层**重新建立映射**（使用SSD，一个逻辑块号对应的物理块号可能发生改变）

  SSD **读块写慢**

* SSD **支持随机访问**（直接从闪存翻译层获取映射关系，得到物理地址）

  机械硬盘 不支持随机访问，读/写一次磁盘的时间 = 寻道时间 + 延迟时间 + 传输时间

![image-20250506232405428](imgs\image-20250506232405428.png)

* SSD 的一个块**擦除次数过多**时可能会**坏**

* 磨损均衡技术：

  + 动态磨损均衡：**优先**把数据存到新块里

  + 静态磨损均衡：把**读多**的任务**迁移**给老旧的块，把**写多**的任务迁移给新块

![image-20250506232659676](imgs\image-20250506232659676.png)
